<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
 <TITLE>IPtables for Fun -- Implementare un firewall in linux: NAT con iptables</TITLE>
 <LINK HREF="iptables4fun-30.html" REL=next>
 <LINK HREF="iptables4fun-28.html" REL=previous>
 <LINK HREF="iptables4fun.html#toc9" REL=contents>
</HEAD>
<BODY>
<A HREF="iptables4fun-30.html">Avanti</A>
<A HREF="iptables4fun-28.html">Indietro</A>
<A HREF="iptables4fun.html#toc9">Indice</A>
<HR>
<H2><A NAME="s9">9.</A> <A HREF="iptables4fun.html#toc9">NAT con iptables</A></H2>

<P>Col paragrafo precedente abbiamo completato la configurazione di una
piccola rete per quanto riguarda il filtraggio. </P>
<P>Argomento di questa sezione &egrave; il NAT, ovvero ``Network Address Translation''.</P>
<P>Il NAT consente ad un firewall o router linux di non limitarsi 
a bloccare o consentire i pacchetti in transito, bens&igrave; anche di
modficarli secondo delle regole ben definite. </P>
<P>Il codice che in linux gestisce il NAT &egrave; stato completamente 
ridisegnato per iptables ed il risultato &egrave; stato un sistema molto pi&ugrave;
pulito e flessibile rispetto quello utilizzato da ipchains. ipchains,
per effettuare modifiche ai pacchetti, utilizzava semplicemente dei 
target diversi come MASQ (per mascherare i pacchetti). Questo per&ograve; creava
molta confusione sul meccanismo di scansione delle regole ed andava ad interferire
con le regole di filtraggio. In iptables, invece, la parte di filtraggio 
dei pacchetti &egrave; completamente indipendente da quella di modifica 
e di gestione delle regole di nat. Per raggiungere questa indipendenza
&egrave; stato infatti introdotto il concetto di ``tabella'' di cui fin'ora
non avevamo parlato. Ebbene, le 3 catene principali di cui abbiamo
parlato fin'ora (INPUT, OUTPUT, FORWARD) si trovano nella tabella ``filter''.
La tabella di filter &egrave; quella che viene scelta in automatico se non
viene specificata un'altra tabella (per questioni di compatibilit&agrave;). </P>
<P>Esistono quindi altre tabelle in iptables, ognuna delle quali mette
a disposizione diverse catene di base:
<UL>
<LI>la tabella <I>filter</I>, le cui catene principali sono <B>INPUT, OUTPUT, FORWARD</B></LI>
<LI>la tabella <I>nat</I>, le cui catene principali sono <B>PREROUTING, OUTPUT, POSTROUTING</B></LI>
<LI>la tabella <I>mangle</I>, le cui catene principali sono <B>PREROUTING, OUTPUT</B></LI>
</UL>

Beh, ci sono 3 tabelle in totale. La prima, che normalmente non viene mai 
indicata esplicitamente, che serve per filtrare i pacchetti. La seconda, quella di
nat, che serve normalmente per modificare ci&ograve; che ha a che vedere col mittente o il
destinatario di un pacchetto, ed infine la tabella di mangle che consente di modificare 
tutte le altre caratteristiche dei pacchetti. </P>
<P>La distinzione tra mangle e nat non &egrave; cos&igrave; netta, si tratta soltanto di un
criterio di base, ed il manuale vi sapr&agrave; sicuramente indicare la tabella migliore 
da utilizzare a secondo delle vostre necessit&agrave;.</P>
<P>Ma guardiamo meglio i nomi delle catene: nella tabella filter, ci troviamo
le solite INPUT, OUTPUT, FORWARD, col significato che ormai conosciamo.
Nella tabella di nat abbiamo invece 3 nuove catene: la catena di PREROUTING,
la catena di OUTPUT e la catena di POSTROUTING. La catena di OUTPUT mantiene
lo stesso significato che aveva nella tabella di filter. La catena di PREROUTING
e quella di POSTROUTING classificano invece i pacchetti diversamente: non pi&ugrave; in
base alla direzione dei pacchetti, bens&igrave; al fatto che sia gi&agrave; stata presa
una decisione di routing su questi pacchetti. Vediamo di spiegare meglio l'idea:
quando un pacchetto di qualsiasi protocollo deve uscire da una macchina connessa ad una rete (poco
importa la provenienza del pacchetto) deve essere presa una decisione di routing. Deve cio&egrave; essere
stabilito da che interfaccia dovr&agrave; uscire questo pacchetto e con quali caratteristiche dovr&agrave; 
essere mandato (es, il TTL dovrebbe essere decrementato, l'MTU potrebbe essere diverso
e necessitare una frammentazione, l'indirizzo hardware specificato potrebbe essere quello
di un gateway...). Dal punto 
di vista logico, quindi, ogni pacchetto che deve uscire da un'interfaccia di 
rete passa prima dalla catena di PREROUTING, viene presa una decisione sull'interfaccia
da cui fare uscire il pacchetto, dopodich&egrave; passa dalla catena di POSTROUTING. </P>
<P>PREROUTING e POSTROUTING sono state introdotte proprio per consentire di realizzare diversi
comportamenti: ad esempio, se si vuole cambiare l'indirizzo di destinazione di un pacchetto
sar&agrave; importante farlo prima che venga deciso da dove fare uscire il pacchetto (se cos&igrave; non 
fosse, il pacchetto uscirebbe dall'interfaccia sbagliata, a meno che questo non sia
l'effetto desiderato). Mentre, al
contrario, quando si cambia il mittente di un pacchetto potrebbe essere importante farlo dopo
che una decisione di routing &egrave; stata presa (in questo caso per&ograve; l'errore non sarebbe cos&igrave; palese).</P>
<P>Comunque sia, in ognuna di queste tabelle &egrave; possibile specificare dei target differenti utilizzando
per&ograve; le stesse opzioni e gli stessi moduli per creare delle regole. Di base, i target pi&ugrave; conosciuti
per la tabella di NAT sono proprio:
<UL>
<LI> <B>SNAT</B> consente di cambiare l'indirizzo ip sorgente di un pacchetto (POSTROUTING)</LI>
<LI> <B>DNAT</B> consente di cambiare l'indirizzo ip destinazione di un pacchetto (PREROUTING)</LI>
<LI> <B>MASQUERADE</B> consente di cambiare l'indirizzo ip sorgente di un pacchetto (verr&agrave; spiegata in 
seguito la differenza - POSTROUTING).</LI>
<LI> <B>REDIRECT</B> consente di cambiare la porta di destinazione di un pacchetto (PREROUTING)</LI>
</UL>

Torniamo ora al nostro esempio: la nostra lan utilizza degli indirizzi ip del tipo 192.168, e 
come tali non possono viaggiare su internet (192.168 &egrave;  una classe di indirizzi ip riservati per reti private). 
Per consentire 
quindi ai computer della nostra rete di navigare, sarebbe necessario o un proxy (che per&ograve; gestisca
tutti i protocolli) o fare in modo che l'indirizzo ip sorgente dei pacchetti originati dalla nostra
rete venga cambiato con un indirizzo ip valido per viaggiare in internet (come quello del nostro firewall,
per esempio).</P>
<P>Realizzare questo a livello di regole di iptables &egrave; estremamente facile. Bisogna per&ograve; fare una piccola introduzione
e dare un minimo di spiegazioni. A molti di voi, ad esempio, sar&agrave; sorto spontaneo chiedersi come 
diavolo pu&ograve; fare un firewall a nascondere 20 computer (per esempio) dietro un unico indirizzo ip. Voglio dire,
in uscita funziona bene: il client FOO dietro il firewall manda un pacchettino al gateway (il nostro firewall),
il nostro firewall cambia l'indirizzo ip sorgente col suo (valido su internet) e manda avanti il pacchettino, 
il server remoto risponde, il pacchettino torna indietro, e... il pacchettino che gli torna indietro ha come 
mittente il server remoto, come destinatario il firewall... non sembra funzionare tanto... come fa il firewall 
a capire a quale dei nostri client deve rimandare il pacchetto, se l'indirizzo di destinazione &egrave; il suo 
indirizzo esterno? E anche ipotizzando di avere un indirizzo ip solo per i client, come farebbe a mandare la
risposta al client corretto? Se guardasse l'indirizzo ip del server remoto, solo un client per volta potrebbe
navigare su un determinato sito... non proprio funzionale. Una soluzione potrebbe essere quella di avere
tanti ip esterni quanti client. Ma allora perch&eacute; usare il nat? La sicurezza potrebbe essere un
buon motivo, ma normalmente il nat si usa quando ci sono meno (o molti meno) indirizzi esterni a disposizione
rispetto ai client della propria rete (attualmente, gli indirizzi ip hanno un costo, e non indifferente).</P>
<P>Beh, la soluzione che &egrave; stata trovata per risolvere questo problema si basa sull'idea di porta. Quando stabilite
una connessione tcp verso un server, l'unica porta veramente importante &egrave; quella di destinazione, che identifica
univocamente un servizio. Quella mittente, invece, non viene quasi mai guardata e spesso viene scelta a caso.</P>
<P>Con il NAT, il nostro firewall linux cambier&agrave; (se necessario) la porta sorgente dei pacchetti in uscita
ed utilizzer&agrave; quella per identificare univocamente un client. Se la soluzione vi convince poco, provate
a pensare al flusso dei pacchetti... il client A manda un pacchetto proveniente da A porta <I>x</I> al server
B porta 80. Il firewall riceve il pacchetto, cambia x in y (dove x pu&ograve; essere uguale a y, se tale
porta non &egrave; utilizzata da nessuno), si segna che y &egrave; associata solo ad A e cambia l'indirizzo
ip sorgente con il suo, il pacchetto arriva al server remoto R porta 80 come proveniente da F:y, e risponde creando un pacchetto
proveniente da R:80 e destinato al firewall F porta y. Firewall riceve il pacchetto, vede che la connessione
non &egrave; stata creata direttamente da lui (ogni sistema operativo sa quali connessioni ha iniziato)
cerca nella tabella e vede che la porta y era in origine x ed era associata al client A. Prende il pacchetto,
modifica il destinatario in modo che indichi A porta x e rimanda il pacchetto ad A. Sembra funzionare, no?
L'idea &egrave; abbastanza furba e permette di identificare univocamente un client utilizzando qualche bit
in pi&ugrave; di informazioni. Il problema &egrave; che a volte questa tecnica non funziona:
<UL>
<LI>ad esempio, quando la trasmissione non fa uso del concetto di porta (solo le trasmissioni tcp e udp
hanno delle porte associate). Fortunatamente per&ograve;, oltre all'icmp, non esistono protocolli
realmente utilizzati che non usino il concetto di porta, e gli errori sono facilmente associabili
(non sono specifici al client: se un server non &egrave; raggiungibile, questo non sar&agrave;
raggiungibile per <EM>tutti</EM> i client dietro al NAT box). Cio&egrave;, questi protocolli esistono ma vengono comunque
normalmente gestiti non dal kernel ma da demoni dedicati per cui il problema non si pone.</LI>
<LI>ad esempio, quando c'&egrave; bisogno che i pacchettini provengano da una porta specifica: un client, nascosto
dal firewall, non sapr&agrave; mai in realt&agrave; che porta sorgente utilizzer&agrave; il firewall per rispedire i suoi
pacchetti.</LI>
<LI>ad esempio, quando il protocollo si basa su connessioni effettuate da un server
esterno verso un client interno. 
<P> Per vedere dove sta il problema, proviamo a vedere un esempio.
Ipotizziamo che il solito client FOO si colleghi a uno strano server con uno strano protocollo. 
Per via di questo strano protocollo, il server deve aprire una connessione verso
la porta 789 del client e tenta quindi di collegarsi. Quello che per&ograve; per lui 
&egrave; l'indirizzo del client &egrave; in realt&agrave; l'indirizzo del firewall, per via
del NAT che ha cambiato l'indirizzo del mittente. </P>
<P>Cos&igrave; facendo, il server tenter&agrave; di collegarsi al firewall, che per&ograve; questa volta
non avr&agrave; nessuna associazione nella sua tabella (l'associazione si crea solo per le  
connessioni che escono, e non &egrave; possibile indovinarle per quelle che entrano, a meno
che non vengano stabilite a priori dall'amministratore) e sar&agrave; quindi costretto a
buttare via il pacchetto rispondendo al server con un messaggio icmp con scritto qualcosa del 
tipo ``la porta &egrave; chiusa e io non so chi tu sia''. </P>
</LI>
</UL>

Fortunatamente per&ograve; il primo caso &egrave; estremamente raro (non credo sia stato mai nemmeno preso in considerazione
il problema), il secondo capita ancora molto raramente, mentre per il terzo esistono delle soluzioni: il
tracciamento delle connessioni.</P>
<P> 
Infatti, i moduli del kernel prima caricati che si occupavano di aprire o chiudere dinamicamente le 
porte sono anche in grado di aggiungere o rimuovere associazioni dalla famosa tabella, o di fare
delle piccole modifiche al protocollo in modo che questo possa funzionare. Per fare questo per&ograve;,
se non avete compilato staticamente il kernel, dovete caricare anche i moduli ``ip_nat_ftp'', ``ip_nat_irc''
o ``ip_nat_protocollo_strano_che volete usare'' con il solito ``modprobe''.</P>
<P>Il problema che a volte si incontra, per&ograve;, &egrave; che questi moduli non sono proprio facili
da scrivere, per cui &egrave; relativamente facile trovarne per i protocolli standard, mentre non 
esistono per quei protocolli inventati dalla fantasia dei venditori di software di turno,
che non sentono il dovere morale di rispettare degli standard.</P>
<P> Normalmente i problemi si incontrano
solo per parti dei vari ``protocolli'' (ad esempio, dietro un firewall linux di questo tipo, col messanger
sarebbe difficile farsi mandare dei file da altri utenti, pur funzionando per tutte le altre cose).
E se per ftp e IRC (anche netmeeting, ma sperimentale) sono stati scritti dei moduli, per altri protocolli
meno utilizzati credo che sar&agrave; difficile che qualcuno si occupi di realizzarli.</P>
<P>In questi casi, un ``socks server'' vi consentir&agrave; il pi&ugrave; delle volte di rendere felici i 
vostri utenti. Il prezzo da pagare &egrave; che un socks server di base &egrave; molto aperto ed una 
configurazione errata o superficiale di questo potrebbe vanificare completamente i vostri sforzi. In
pi&ugrave;, preparatevi a ricevere chiamate a tutte le ore del tipo ``come si fa ad impostare il socks
server su fuffolo 3.0 piuttosto che kazzat 2.8''...</P>

<HR>
<A HREF="iptables4fun-30.html">Avanti</A>
<A HREF="iptables4fun-28.html">Indietro</A>
<A HREF="iptables4fun.html#toc9">Indice</A>
</BODY>
</HTML>
