<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
 <TITLE>IPtables for Fun -- Implementare un firewall in linux</TITLE>
</HEAD>
<BODY>
<H1>IPtables for Fun -- Implementare un firewall in linux</H1>

<H2>Carlo Contavalli -- Copyright &copy; 2000-2003</H2>$Revision: 1.12 $ -- $Date: 2003/07/29 3:12:46 $
<HR>
<EM>Col passare del tempo, Linux sta diventando una piattaforma
sempre pi&ugrave; utilizzata nel mondo di internet. Con il maggior numero di utenti e con l'interesse
suscitato ultimamente, le sue potenzialit&agrave; come server di rete sono cresciute in maniera esponenziale. In particolare, il kernel Linux 2.4.x offre strumenti
 estremamente potenti e flessibili per la realizzazione di  firewall avanzati. Questo documento si propone come scopo  quello di introdurre gli utenti alla configurazione di linux  come firewall utilizzando tutti gli strumenti pi&ugrave; recenti  messi a disposizione. L'ultima versione di questo documento pu&ograve; essere reperita
 in vari formati su 
<A HREF="https://github.com/ccontavalli/doc-it-iptables4fun">https://github.com/ccontavalli/doc-it-iptables4fun</A></EM>
<HR>
<P>
<H2><A NAME="toc1">1.</A> <A HREF="iptables4fun.html#s1">Copyright e note legali...</A></H2>

<P>
<H2><A NAME="toc2">2.</A> <A HREF="iptables4fun.html#s2">Prima di cominciare</A></H2>

<UL>
<LI><A NAME="toc2.1">2.1</A> <A HREF="iptables4fun.html#ss2.1">Ringraziamenti</A>
</UL>
<P>
<H2><A NAME="toc3">3.</A> <A HREF="iptables4fun.html#s3">Nozioni di base sui firewall</A></H2>

<UL>
<LI><A NAME="toc3.1">3.1</A> <A HREF="iptables4fun.html#ss3.1">Tipologie di firewall</A>
</UL>
<P>
<H2><A NAME="toc4">4.</A> <A HREF="iptables4fun.html#s4">Preparare il proprio sistema</A></H2>

<UL>
<LI><A NAME="toc4.1">4.1</A> <A HREF="iptables4fun.html#ss4.1">Procurarsi i sorgenti</A>
<LI><A NAME="toc4.2">4.2</A> <A HREF="iptables4fun.html#ss4.2">Patchare e prepararsi a ricompilare...</A>
<LI><A NAME="toc4.3">4.3</A> <A HREF="iptables4fun.html#ss4.3">Preparare il kernel</A>
<LI><A NAME="toc4.4">4.4</A> <A HREF="iptables4fun.html#ss4.4">Compilare iptables</A>
<LI><A NAME="toc4.5">4.5</A> <A HREF="iptables4fun.html#ss4.5">Compilare iproute</A>
</UL>
<P>
<H2><A NAME="toc5">5.</A> <A HREF="iptables4fun.html#s5">Hardening the system </A></H2>

<UL>
<LI><A NAME="toc5.1">5.1</A> <A HREF="iptables4fun.html#ss5.1">Ridurre i punti di ingresso</A>
<LI><A NAME="toc5.2">5.2</A> <A HREF="iptables4fun.html#ss5.2">Ripulire il sistema</A>
<LI><A NAME="toc5.3">5.3</A> <A HREF="iptables4fun.html#ss5.3">Rilevare le intrusioni</A>
</UL>
<P>
<H2><A NAME="toc6">6.</A> <A HREF="iptables4fun.html#s6">Pericoli -- ovvero, da cosa dovr&agrave; difendervi il firewall</A></H2>

<UL>
<LI><A NAME="toc6.1">6.1</A> <A HREF="iptables4fun.html#ss6.1">Assunzioni errate</A>
<LI><A NAME="toc6.2">6.2</A> <A HREF="iptables4fun.html#ss6.2">Sicurezza degli switch</A>
</UL>
<P>
<H2><A NAME="toc7">7.</A> <A HREF="iptables4fun.html#s7">Preparare il kernel ad andare in rete -- overview di /proc </A></H2>

<UL>
<LI><A NAME="toc7.1">7.1</A> <A HREF="iptables4fun.html#ss7.1">Utilizzo dei file in /proc</A>
<LI><A NAME="toc7.2">7.2</A> <A HREF="iptables4fun.html#ss7.2">Alcuni file importanti</A>
</UL>
<P>
<H2><A NAME="toc8">8.</A> <A HREF="iptables4fun.html#s8">Filtrare il traffico con iptables</A></H2>

<UL>
<LI><A NAME="toc8.1">8.1</A> <A HREF="iptables4fun.html#ss8.1">Preambolo</A>
<LI><A NAME="toc8.2">8.2</A> <A HREF="iptables4fun.html#ss8.2">Configurare le interfacce</A>
<LI><A NAME="toc8.3">8.3</A> <A HREF="iptables4fun.html#ss8.3">Il comando iptables </A>
<LI><A NAME="toc8.4">8.4</A> <A HREF="iptables4fun.html#ss8.4">Definizione delle policy</A>
<LI><A NAME="toc8.5">8.5</A> <A HREF="iptables4fun.html#ss8.5">La nostra configurazione</A>
<LI><A NAME="toc8.6">8.6</A> <A HREF="iptables4fun.html#ss8.6">Prime catene</A>
</UL>
<P>
<H2><A NAME="toc9">9.</A> <A HREF="iptables4fun.html#s9">NAT con iptables</A></H2>

<UL>
<LI><A NAME="toc9.1">9.1</A> <A HREF="iptables4fun.html#ss9.1">Dalla teoria alla pratica</A>
</UL>
<P>
<H2><A NAME="toc10">10.</A> <A HREF="iptables4fun.html#s10">Mettere tutto insieme</A></H2>

<UL>
<LI><A NAME="toc10.1">10.1</A> <A HREF="iptables4fun.html#ss10.1">Configurazione dei client</A>
</UL>
<P>
<H2><A NAME="toc11">11.</A> <A HREF="iptables4fun.html#s11">Modifiche on the fly - iptables da riga di comando</A></H2>

<UL>
<LI><A NAME="toc11.1">11.1</A> <A HREF="iptables4fun.html#ss11.1">Manipolare le catene</A>
<LI><A NAME="toc11.2">11.2</A> <A HREF="iptables4fun.html#ss11.2">Salvare le modifiche</A>
</UL>
<P>
<H2><A NAME="toc12">12.</A> <A HREF="iptables4fun.html#s12">Conclusioni</A></H2>


<HR>
<H2><A NAME="s1">1.</A> <A HREF="#toc1">Copyright e note legali...</A></H2>

<P>Copyright &copy; 2000-2003 Carlo Contavalli.</P>

<P>&egrave; garantito il permesso di copiare, distribuire e/o modificare
questo documento seguendo i termini indicati dalla Licenza per
Documentazione Libera GNU (GNU Free Documentation License -- FDL) 
in lingua originale, Versione 1.1 o ogni versione
successiva come pubblicata dalla Free Software Foundation; senza 
Sezioni Non Modificabili (Invariant Sections), senza Testi
Copertina (Front-Cover Texts), e senza Testi di Retro Copertina (Back-Cover Texts).  Una
copia della licenza in lingua originale pu&ograve; essere reperita all'indirizzo
<A HREF="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</A> oppure
contattando l'autore tramite email.</P>
<P>Ogni esempio di codice fornito in questo documento deve essere considerato
protetto secondo i termini indicati dalla GNU General Public License 
in lingua originale. Una copia di questa licenza pu&ograve; essere
reperita all'indirizzo 
<A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A>
oppure ottenuta tramite posta ordinaria scrivendo a:
Free Software Foundation, Inc., 59 Temple Place, Suite 330,
MA 02111-1307, USA. </P>
<P>Per ogni eventuale chiarimento o per maggiori
dettagli potete contattare l'autore all'indirizzo di posta elettronica
&lt;ccontavalli at gmail.com&gt;.</P>
<P>Una versione aggiornata e completa di questo documento potr&agrave; essere reperita su
<A HREF="https://github.com/ccontavalli/doc-it-iptables4fun">https://github.com/ccontavalli/doc-it-iptables4fun</A> in diversi formati.</P>


<P>Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.1 or any later version 
published by the Free Software Foundation; with no Invariant Sections, with no
Front-Cover Texts, and with no Back-Cover Texts. A copy of the license
can be found at 
<A HREF="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</A> or
contacting the author by email. </P>
<P>Any example of code provided in this document should be considered
protected under the terms of the GNU General Public License. A copy
of this license can be found at 
<A HREF="http://www.gnu.org/copyleft/gpl.html">http://www.gnu.org/copyleft/gpl.html</A>
or writing
to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
MA 02111-1307, USA.</P>
<P>You can contact the author of this document by email at 
&lt;ccontavalli at gmail.com&gt; to obtain more details or
information about this document and its license.</P>
<P>An updated version of this document can be found on
<A HREF="https://github.com/ccontavalli/doc-it-iptables4fun">https://github.com/ccontavalli/doc-it-iptables4fun</A> in
different formats.</P>

<H2><A NAME="s2">2.</A> <A HREF="#toc2">Prima di cominciare</A></H2>

<P>Questa che state leggendo &egrave; la seconda versione (precisamente, $Revision: 1.12 $) di un 
documento che scrissi parecchio tempo fa, agli albori del kernel 2.4. 
Da allora, diverse versioni del kernel sono state rilasciate e nuove funzionalit&agrave;
sono state lentamente introdotte. Troverete quindi notevoli differenze tra questa
versione e le versioni precedenti, sia in termini di contenuto tecnico sia in termini
di linguaggio utilizzato. </P>
<P>Nelle versioni dalla 1.9 in poi, inoltre, il nome di questo tutorial &egrave; 
stato cambiato da ``Iptables for Dummies'' a ``Iptables for Fun'', al fine di sottolineare
l'estraneit&agrave; dello stesso dalla serie ``for dummies'' pubblicata in libreria
e di evitare problemi che si sarebbero potuti venire a creare in relazione a 
marchi, trademark o diritti della ``Hungry Minds'', diritti che non intendo in 
alcun modo violare.</P>
<P>A questo proposito, vorrei ringraziare alcuni lettori per aver segnalato 
il problema.</P>
<P>Spero che questo documento possa esservi utile e sarei felice di
ricevere commenti, domande o richieste di chiarimenti (nonch&egrave;
qualche invito a bere una birra in compagnia :-) al mio indirizzo 
di posta elettronica &lt;ccontavalli at gmail.com&gt;...</P>
<P>Devo inoltre ringraziare tutti coloro che mi hanno scritto
aiutandomi a capire quali parti potevano essere di maggiore 
interesse, quali potevano essere migliorate o segnalando errori
che spero ora aver corretto, o semplicemente incoraggiandomi 
nell'andare avanti, contribuendo a migliorare il documento
che anche voi state leggendo.</P>
<P>Mi scuso se qualche volta non ho avuto il tempo di 
rispondere alle vostre email o se non sono sempre stato in grado 
di esservi di aiuto.</P>
<P>Purtroppo (pi&ugrave; che altro per me), non riesco a dedicare a 
questo tutorial il tempo di cui avrebbe bisogno e le nuove sezioni 
su cui (ormai da mesi) sto lavorando verranno introdotte sempre
pi&ugrave; lentamente, quasi tanto quanto le correzioni che
gentilmente mi avente inviato.</P>
<P>Comunque sia, versioni aggiornate di questo documento potranno 
essere reperite su 
<A HREF="https://github.com/ccontavalli/doc-it-iptables4fun">https://github.com/ccontavalli/doc-it-iptables4fun</A>.</P>

<P>Inoltre, nel corso di questo tutorial, quando si parler&agrave; di IP e di protocolli di 
rete (se non esplicitamente indicato) mi riferir&ograve; alla versione 4 del 
protocollo IP (aka, IPv4).</P>
<P>Infine, se non vi interessa nulla di iptables, iproute, del kernel 2.4 e di tutte le funzioni
avanzate messe a disposizione e volete proteggere semplicemente il vostro computer
o la vostra piccola lan, potete limitarvi a digitare da riga di comando, come utente ``root'',
qualcosa di simle a:
<BLOCKQUOTE><CODE>
<PRE>
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

ed eventualmente:
<BLOCKQUOTE><CODE>
<PRE>
iptables -A FORWARD -s ip_rete_interna/24 -j ACCEPT
iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t nat -A POSTROUTING -s nostrareteinterna/24 -j MASQUERADE
echo 1 > /proc/sys/net/ipv4/ip_forward
</PRE>
</CODE></BLOCKQUOTE>

dove <I>ip_rete_interna</I> pu&ograve;, per esempio, essere sostituito con 10.0.0.0 
o 192.168.0.0. Con queste ultime regole, consentirete ai computer della vostra 
rete che avranno impostato come gateway l'indirizzo ip del vostro firewall di
condividere la connessione ADSL, ISDN o il vostro modem 56k (se siete
abbastanza coraggiosi) ad esso collegati.</P>


<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Ringraziamenti</A>
</H2>

<P>Non c'&egrave; dubbio che per il tempo che mi hanno dedicato o per l'aiuto
che mi &egrave; stato dato (anche solo inviandomi commenti o incoraggiandomi
nell'andare avanti), debba
ringraziare:</P>
<P>Andrea Ciancone, Guido Caruso, Gianluca D'inc&agrave;, Giovanni Bassetto, 
Gabriele Biarese, Matteo Nastasi, Gianluca, Tony Arcucci, BlueRaven</P>
<P>e tutti gli amici del linux_var 
<A HREF="http://www.linuxvar.it">http://www.linuxvar.it</A>,
nonch&eacute; coloro che ho dimenticato di citare in questa lista
(mandatemi una mail!).</P>


<H2><A NAME="s3">3.</A> <A HREF="#toc3">Nozioni di base sui firewall</A></H2>

<P>Prima di entrare nel cuore della trattazione, conviene fare una 
piccola introduzione. Se gi&agrave; sapete cos'&egrave; un firewall
e avete una discreta idea di come funzioni una rete, potete saltare
senza troppi rimpianti questa sezione. Se invece non avete le 
idee tanto chiare o se per la prima volta vi trovate ad affrontare
problematiche di questo tipo, vi consiglio di continuare...</P>
<P>Comunque sia, partendo da zero, un firewall linux non &egrave; 
altro che un semplice personal computer normalmente collegato 
fisicamente (con dei cavi) a pi&ugrave; di una rete. </P>
<P>Un firewall avr&agrave; quindi installata una scheda di rete (interfaccia)
per ogni rete cui sar&agrave; collegato. Inoltre, dovr&agrave;
costituire l'unico punto di contatto tra le reti cui &egrave; connesso.</P>
<P>Per spiegarmi meglio, un firewall dovr&agrave; costituire l'unico punto 
di collegamento tra due o pi&ugrave; reti. Un po' come un ponte che 
collega due o pi&ugrave; isole. 
Senza entrare nei dettagli del protocollo ip, tutte le comunicazioni 
tra queste reti saranno quindi costrette a passare da questo computer.</P>
<P>Questo computer, una volta configurato come firewall, sar&agrave; in
grado di decidere cosa far passare, cosa scartare o come reagire a 
determinati eventi. Tornando all'esempio del nostro ponte, configurare
il computer come firewall pu&ograve; essere considerato equivalente
a mettere una stanga e 2 finanzieri che controllano tutti i veicoli
e le persone in transito. Questi 2 finanzieri saranno quindi in grado
di agire secondo le istruzioni che gli verranno date dal ministero, 
bloccando veicoli, arrestando i contrabbandieri o sparando a vista
ai ricercati.</P>
<P>In linux, la stanga e i finanzieri sono messi a disposizione direttamente
dal kernel. Per controllare il kernel, per dare cio&egrave; le direttive
ai finanzieri, vengono messi a disposizione diversi comandi: con il
kernel 2.4, i principali e pi&ugrave; avanzati sono comunque il 
comando ``ip'', ``tc'' e ``iptables'', i primi due inclusi nel
pacchetto ``iproute'' mentre il terzo distribuito indipendentemente.</P>
<P>Procedendo con ordine, in linea di principio il comando ``ip'' vi consente di creare nuove isole
e nuovi ponti, di gestire quindi le tabelle di routing e le interfacce di
rete, il comando iptables di istruire i finanzieri dicendo
cosa far passare e cosa non far passare o come reagire a determinate
condizioni, consente cio&egrave; di creare dei filtri. Infine, il 
comando tc, vi consente di stabilire delle priorit&agrave; e dei
limiti sul traffico in ingresso ed in uscita. Ad esempio, un compito
che esula dal filtraggio e che quindi riguarda tc potrebbe essere quello
di riservare alcune corsie al passaggio di veicoli di emergenza o
di servizio, limitando magari il traffico automobilistico, di 
riservare cio&egrave; determinate quantit&agrave; di banda a
determinate tipologie di traffico. </P>
<P>Riassumendo, quindi, si parler&agrave; del comando 
<UL>
<LI>ip -- per configurare, attivare, disattivare o creare
interfacce di rete, nonch&eacute; per gestire
le tabelle di routing (da solo rimpiazza
i comandi ifconfig, route e arp).</LI>
<LI>iptables -- per bloccare, consentire o registrare
il traffico, per effettuare cio&egrave; 
firewalling, ovvero per modificare
alcune caratteristiche dei pacchetti in transito,
per effettuare cio&egrave; NAT (Network Address
Translation).</LI>
<LI>tc -- per assegnare delle priorit&agrave;, imporre
delle precedenze o dei limiti di banda (tc
sta per ``traffic classifier''), in poche
parole, per effettuare dello shaping.</LI>
</UL>

In questo documento si parler&agrave; prevalentemente del comando iptables.</P>

<H2><A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">Tipologie di firewall</A>
</H2>

<P>Adesso che abbiamo detto cos'&egrave; e a cosa serve un firewall, &egrave;
importante parlare un pochettino delle tipologie di firewall che esistono
sul mercato.</P>
<P>Questa non vuole essere n&eacute; una trattazione completa n&eacute; ``esatta''
dal punto di vista tecnico. Lo scopo &egrave; semplicemente quello di introdurre
il lettore alla terminologia utilizzata normalmente parlando di firewall e di 
dare una breve panoramica sulle soluzioni disponibile per la configurazione, gestione
e amministrazione delle reti.</P>


<H3>Firewall stateless e firewall statefull</H3>

<P>Prima di tutto, esistono firewall che vengono classificati come ``stateless''
ed altri che vengono chiamati ``statefull''. La differenza &egrave; abbastanza
importante: firewall stateless prendono la decisione di bloccare o consentire
una comunicazione soltanto sulla base delle caratteristiche della comunicazione
stessa. Al contrario, firewall statefull sono in grado di riconoscere le connessioni
e le trasmissioni, e, tenendone traccia, sono in grado di prendere decisioni in
base ad altri parametri. Rifacendomi sempre all'esempio dei finanzieri, un finanziere
``stateless'' potr&agrave; bloccare o consentire un autoveicolo soltanto in base
a caratteristiche come il numero di targa, il tipo di veicolo o il numero di passeggeri.
Al contrario, un finanziere ``statefull'' sar&agrave; in grado di valutare caratteristiche
come il numero di volte che un veicolo &egrave; passato, se fa parte di una comitiva
di altri veicoli, piuttosto che se il veicolo dovr&agrave; fare altri viaggi per svolgere
le sue mansioni. Non &egrave; proprio l'esempio migliore, ma credo che possa rendere 
bene l'idea. Parlando invece con un linguaggio pi&ugrave; ``tecnico'', un firewall stateless
conosce solo il concetto di pacchetto singolo, mentre un firewall statefull &egrave; in
grado di riconoscere le connessioni e perfino alcuni protocolli. Firewall creati con
il vecchio comando ``ipchains'' vengono considerati stateless, mentre quelli creati con 
``iptables'' possono essere statefull.</P>


<H3>Firewall e protocolli</H3>

<P>I firewall possono essere poi classificati a secondo del ``livello'' (termine non strettamente 
corretto) a cui lavorano:
<UL>
<LI>Quelli che si intendono normalmente per firewall, lavorano solitamente al livello del protocollo
ip o del protocollo tcp, filtrando il traffico in base al contenuto di queste intestazioni.
Per esempio, sono in grado di filtrare il traffico in base all'indirizzo ip del mittente di un 
pacchetto, di destinazione o in base al protocollo utilizzato (dove per protocollo si intende
la porta tcp o udp). Normalmente, un firewall di questo tipo &egrave; impostato
come gateway delle reti cui &egrave; collegato.</LI>
<LI>Firewall ``trasparenti'' lavorano invece ad un livello pi&ugrave; basso
del protocollo ip, molto vicino all'hardware, per cui vengono normalmente
inseriti tra una rete e l'altra ma non devono essere impostati come gateway, non
essendo visibili al livello del protocollo ip   (&egrave; questo il motivo per cui 
vengono detti trasparenti - non sono visibili,
e i client non devono essere configurati per usare il gateway).
<P>In linux, &egrave; possibile ottenere un firewall quasi trasparente 
utilizzando funzioni come il ``proxy arp'' in combinazione con qualche 
regola di iptables per modificare i pacchetti, oppure utilizzando il 
codice di ``bridging'' sempre in combinazione
con ``iptables''. Attenzione per&ograve; che attualmente il codice di 
bridging non &egrave; in grado di lavorare in coppia con iptables, a
meno che non usiate un kernel sperimentale versione dal 2.5.45 in su 
o alcune patch disponibili su internet.</P>
</LI>
<LI>Esistono poi firewall che lavorano a livelli pi&ugrave; alti dell'ip, in 
grado ad esempio di censurare informazioni fornite con i vari protocolli o
di consentire l'accesso solo a quegli url raggiungibili tramite link nelle
pagine visitate.</LI>
</UL>

Parlando poi di reti e di filtraggio, capita spesso che il discorso cada su proxy server 
e socks server. </P>

<H3>Proxy server</H3>

<P>Quando utilizzate un proxy server in
rete (avete presente i parametri di configurazione di Internet Explorer o Mozilla?)
il vostro browser non si collegher&agrave; direttamente al sito relativo alla pagina da voi richiesta, 
bens&igrave; si collegher&agrave; al proxy richiedendo tale pagina. Il proxy, in vece dei client,
si prodigher&agrave; per fornire questa pagina scaricandola da internet o leggendola
dalla sua cache. In pratica, un proxy server non &egrave; altro che un software che tiene
una memoria (cache) delle pagine visitate di recente, mettendo tale memoria a disposizione
di tutti gli utenti collegati ad una rete il cui browser &egrave; configurato per utilizzare
tale cache. Questo pu&ograve; portare ad un risparmio di banda 
davvero notevole, soprattutto in quegli ambienti dove molte persone si collegano pi&ugrave; 
o meno agli stessi siti (e se lo spazio a disposizione per la cache &egrave; molto, 
sar&agrave; molto probabile che molti siti si trovino in cache).</P>
<P>Oltre a consentirvi di risparmiare banda (una percentuale spesso rilevante di banda),
il vantaggio di utilizzare un proxy server &egrave; che vi consentono di creare
delle regole molto avanzate e di interagire facilmente con gli utenti. </P>
<P>Con poche righe di configurazione per esempio, installando <I>squid</I> e 
<I>squidGuard</I> su una macchina linux &egrave; possibile filtrare le pagine 
web in base al contenuto, applicare delle espressioni regolari agli URL e redirigere 
gli utenti su particolari pagine in caso le politiche impostate vengano violate 
(cose estremamente difficili ed inefficienti da fare con un normale firewall). 
In pi&ugrave;, i delay pools di squid consentono una distribuzione abbastanza equa 
della banda e con l'appoggio di un semplice firewall, un proxy server pu&ograve; essere reso 
trasparente (transparent proxy): in questo caso non ci sar&agrave; bisogno di configurare 
tutti i computer connessi alla rete (client) per utilizzare il proxy e tutte le connessioni verranno
automaticamente deviate (redirette) sul proxy dal firewall. </P>

<H3>Socks server</H3>

<P>Esiste poi un fratello povero dei proxy server, di cui vi ho accennato prima: il 
socks server. Questo, invece di fare da cache, &egrave; un software che si occupa
soltanto di applicare restrizioni imponendo dei limiti o dando privilegi
in base a regole stabilite dall'amministratore.</P>
<P>Lo svantaggio principale di un socks server &egrave; che le applicazioni utilizzate
devono essere fatte apposta per parlare la ``lingua'' di quest'ultimo e che non 
pu&ograve; essere automaticamente imposto a tutti i computer di una rete (non si pu&ograve;
impostare un ``transparent socks server'').
Fortunatamente per&ograve;, la maggior parte delle applicazioni attualmente 
disponibili sono a conoscenza di questa lingua.</P>
<P>Un buon motivo per utilizzare un socks server &egrave; che firewall statefull classici 
sono in grado di riconoscere e gestire soltanto i protocolli standard. 
Spesso capita quindi che protocolli inventati dai produttori di turno senza 
rispettare alcuno standard (o modificando gli standard a proprio piacimento) incontrino 
problemi non indifferenti. Configurando le applicazioni che fanno uso di questi protocolli
in modo da collegarsi tramite un socks server li si costringer&agrave; a parlare una ``lingua'' 
standard che consentir&agrave; al socks server di far funzionare anche i protocolli
pi&ugrave; strani.</P>
<P>Normalmente quindi, utilizzando un firewall linux, a secondo delle esigenze degli utenti
della rete che andr&agrave; a proteggere, si potr&agrave; installere e configurare
anche un socks server per consentire a questi protocolli di funzionare. </P>
<P>E' importante notare per&ograve; che i ``socks server'' in generale godono di una brutta 
fama per quanto concerne la sicurezza, non tanto perch&egrave; tutti i socks server
siano pericolosi, quanto perch&egrave; c'&egrave; stato un periodo storico nel quale
venivano preinstallati su determinati sistemi operativi senza 
imporre restrizione alcuna, consentendo ad utenti maliziosi di entrare nella vostra
rete o di fare cose non proprio piacevoli. </P>
<P>Installando un socks server &egrave; quindi importante fare attenzione alle configurazioni
imponendo delle regole il pi&ugrave; possibile restrittive e cercando di evitare software 
notoriamente bacati. Ricordatevi infine che un socks server costituisce spesso l'unica 
alternativa per poter utilizzare alcuni programmi in rete, a meno di sviluppare un apposito 
modulo per il kernel.</P>



<H2><A NAME="s4">4.</A> <A HREF="#toc4">Preparare il proprio sistema</A></H2>

<P>Per poter usufruire delle nuove funzionalit&agrave; messe a disposizione 
dal kernel di linux, &egrave; indispensabile che il vostro sistema 
soddisfi alcuni prerequisiti.</P>
<P>In particolare, dovrete avere a disposizione:
<UL>
<LI>Un kernel compilato con supporto per iptables, per il tracking (tracciamento)
delle connessioni e per tutti i tipi di NAT (i kernel delle maggiori
distribuzioni vengono distribuiti con i moduli necessari).</LI>
<LI>Una versione di iptables compilata per il vostro kernel.</LI>
<LI>Eventualmente, una versione del pacchetto ``iproute'', sempre compilato
per essere usato con il vostro kernel.</LI>
</UL>

Tutti questi strumenti sono solitamente preimpacchettati e disponibili nella maggior
parte delle distribuzioni, per cui, probabilmente, non avrete nulla da fare 
se non qualche ``apt-get install iproute iptables'' o ``rpm -i''. Per verificare
la loro presenza, potreste provare ad eseguire come ``root'' da riga di
comando i comandi ``iptables'', ``tc'', ip. Se linux non vi restituisce un
errore del tipo ``commando not found'' o ``comando non trovato'', allora sono
gi&agrave; installati e probabilmente il kernel supporta tutte le funzionalit&agrave;
di cui avrete bisogno.</P>
<P>Se per&ograve; volete dilettarvi con funzionalit&agrave; particolarmente avanzate ed
avere il massimo di flessibilit&agrave; possibile, vi consiglio di ricompilare
indipendentemente sia il kernel che iptables ed iproute. Come avrete capito,
questa non &egrave; proprio una strada semplice da seguire, soprattutto se siete utenti
linux alle prime armi. Non vi potrei biasimare quindi se decideste di usufruire
degli strumenti messi a disposizione dalla vostra distribuzione e se decideste di 
saltare completamente questa sezione. In caso contrario, i prossimi paragrafi 
cercheranno di esservi di aiuto nel processo di ricompilare e nel capire 
alcuni meccanismi che stanno alla base del sistema di ricompilazione del codice di 
networking di linux.</P>
<P>Comunque sia, se avete deciso di andare avanti per la strada del ``ricompilare'' vi consiglio di fare
tutto su una macchina che non sia il firewall: avrete la certezza di non dimenticare in
giro tools come gcc, make, o le binutils. Attenzione per&ograve; che senza usare i tool di impacchettamento
messi a disposizione dalla vostra distribuzione, potrebbe diventare alquanto complesso e tedioso
spostare i programmi appena compilati da una macchina all'altra... in questo documento verranno
dati spunti per utilizzare i tool di Debian a questo proposito.</P>
<P>Infine, vi consiglio di eseguire le operazioni nell'ordine in cui sono presentate, onde
evitare problemi di dipendenze.</P>


<H2><A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">Procurarsi i sorgenti</A>
</H2>

<P>Prima di iniziare a ricompilare, potrebbe essere utile procurarsi
i sorgenti dei vari programmi. Come prima cosa quindi, potreste voler scaricare:
<UL>
<LI>Gli ultimi sorgenti del kernel 
<A HREF="http://www.kernel.org">http://www.kernel.org</A> di 
linux, oppure gli ultimi forniti con la vostra distribuzione (apt-cache search kernel-source;
apt-get install kernel-source-2.4.x).</LI>
<LI>L'ultima versione di iptables disponibile su 
<A HREF="http://www.iptables.org">http://www.iptables.org</A>.</LI>
<LI>L'ultima versione del patch-o-matic, disponibile su 
<A HREF="ftp://ftp.netfilter.org/pub/patch-o-matic/">ftp://ftp.netfilter.org/pub/patch-o-matic/</A>.</LI>
<LI>L'ultima versione del pacchetto iproute, disponibile su 
<A HREF="ftp://ftp.inr.ac.ru/ip-routing/">ftp://ftp.inr.ac.ru/ip-routing/</A>.</LI>
</UL>

Ok, verificate quindi di avere tutto il necessario a disposizione per ricompilare 
(gcc, make, binutils, libncurses, ncurses-dev, modutils...) e date un'occhiata ai vari 
README, Changes o INSTALL per evitare di incappare in qualche incompatibilit&agrave; e per verificare 
di avere eventuali librerie (o tools necessari) installati.</P>
<P>Spostatevi quindi in /usr/src o in una directory che vi fa comodo e decomprimete
tutti i vari .tar.gz o .tar.bz2, con i soliti 
<BLOCKQUOTE><CODE>
<PRE>
  # tar -xjf file.tar.bz2
</PRE>
</CODE></BLOCKQUOTE>

oppure
<BLOCKQUOTE><CODE>
<PRE>
  # tar -xzf file.tar.gz
</PRE>
</CODE></BLOCKQUOTE>

supponendo che stiate utilizzando una versione di GNU tar relativamente recente.
Ricordatevi, inoltre, che per ricompilare il kernel vi servir&agrave; per lo meno 
gcc, make, le binutils e gli header delle libncurses (nonch&eacute; qualche
tool che sicuramente ho dimenticato).</P>

<H3>Se usate debian...</H3>

<P>Andate in /usr/src e date:
<BLOCKQUOTE><CODE>
<PRE>
        # apt-get install gcc make binutils libncurses5-dev
        # apt-get install kernel-source-2.4.x
        # apt-get build-dep kernel-source-2.4.x
        # apt-get install kernel-package
        # tar -xjf ./kernel-source-2.4.x.tar.bz2 &amp;

        # apt-get source iptables
        # apt-get build-dep iptables

        # apt-get source iproute
        # apt-get build-dep iproute
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Patchare e prepararsi a ricompilare...</A>
</H2>

<P>Prima di ricompilare, &egrave; bene fare una precisazione. Il ``netfilter'' code del
kernel di linux, ovvero la parte di kernel che si occupa di fare da firewall,
&egrave; realizzato e rilasciato da un gruppo indipendente da quello
che prettamente si occupa del kernel di linux. Capita quindi spesso che persino
l'ultimissima release del kernel di linux sia rimasta
indietro rispetto all'ultima versione del codice di filtraggio (il netfilter).</P>
<P>Considerando poi che molto velocemente vengono rilasciati bug fix e nuove funzioni
vengono introdotte, una delle cose pi&ugrave; importanti da fare &egrave; aggiornare iptables
ed il kernel all'ultimissima versione, stando attenti per&ograve; a mantenerli in
sincronia. Per fare questo, il gruppo di sviluppo del netfilter ha messo a disposizione
uno strumento estremamente potente quanto facile da usare: il patch-o-matic.</P>
<P>Col passare del tempo, per&ograve;, questo strumento si &egrave; evoluto e modificato. 
Per cui, a secondo della versione di iptables che vorrete installare, dovrete seguire
due percorsi diversi. In particolare, se i sorgenti di iptables che avete scaricato
sono della versione 1.2.6 o minore, seguite le istruzioni indicate nella sezione 
``iptables 1.2.6'', altrimenti seguite quelle indicate nella sezione ``iptables 1.2.7a''.</P>

<H3>iptables 1.2.6 - Usare il patch-o-matic</H3>

<P>Entrate quindi nella directory dei sorgenti di iptables, collegatevi ad internet ed iniziate dando
un comando come:
<BLOCKQUOTE><CODE>
<PRE>
        # make pending-patches KERNEL-DIR=path_assoluto/delvostrokernel
</PRE>
</CODE></BLOCKQUOTE>

A questo punto, un'interfaccia a men&ugrave; vi guider&agrave; nell'aggiornamento del
vostro kernel. Attenzione che &egrave; meglio (a volte indispensabile) specificare un path assoluto per 
il proprio kernel. In pratica, usate qualcosa come /usr/src/linux anzich&eacute;
../linux o &nbsp;/src/linux. </P>
<P>Questo comando applicher&agrave; sia al kernel che ai vostri sorgenti di 
iptables tutte quelle patch che sarebbero dovute essere applicate prima
del rilascio del kernel ufficiale, ma che per motivi vari non hanno fatto
in tempo ad essere inserite (normalmente,
si tratta di correzione di bug o piccole modifiche realizzate dopo
il rilascio del kernel). Se state utilizzando i sorgenti del kernel della
vostra distribuzione preferita, non dovreste preoccuparvi pi&ugrave;
di tanto. Il patch-o-matic &egrave; infatti in grado di capire da solo 
quali aggiornamenti sono gi&agrave; stati applicati e di evitare la maggior
parte dei problemi.</P>
<P>Dopo questo primo passo, nel caso vi sentiste particolarmente coraggiosi 
ed inebriati dal successo appena ottenuto, potreste voler proseguire
con un 
<BLOCKQUOTE><CODE>
<PRE>
        # make most-of-pom KERNEL-DIR=path_assoluto/delvostrokernel
</PRE>
</CODE></BLOCKQUOTE>

Come prima, apparir&agrave; un'interfaccia a men&ugrave; che vi guider&agrave;
nell'aggiornamento dei vari sorgenti. A differenza di prima, per&ograve;,
questo comando tenter&agrave; di installare anche le estensioni che ancora non
sono parte del kernel o classificate sperimentali. Tra queste, ce ne
sono parecchie che la maggior parte delle distribuzioni includono
perch&eacute; ormai abbastanza testate, o che comunque saranno incluse nelle 
prossime versioni del kernel... c'&egrave; sempre un sacco di materiale interessante
che spesso vale la pena di installare. Alcune funzioni poi, vi
torneranno utili dopo, magari se vorrete dilettarvi con firewall
trasparenti o imponendo limiti per orari o 
sul numero di connessioni parallele o ancora buttando via casualmente
i pacchetti delle persone che pi&ugrave; vi stanno antipatiche.</P>
<P>Non preoccupatevi poi se avete paura di applicare patch incompatibili
o troppo instabili: most-of-pom &egrave; fatto in modo da evitarvi 
simili errori. In pratica, cercher&agrave; di evitere che vi facciate male da soli.</P>
<P>Se invece vi sentite ancor pi&ugrave; coraggiosi e tutte le ultime feature
del netfilter vi piacciono veramente tanto, potete provare un
<BLOCKQUOTE><CODE>
<PRE>
        # make patch-o-matic KERNEL-DIR=path_assoluto/delvostrokernel
</PRE>
</CODE></BLOCKQUOTE>

che invece vi metter&agrave; a disposizione tutte le nuove feature, dalle
pi&ugrave; inoffensive a quelle pi&ugrave; pericolose, dalle pi&ugrave; testate a quelle
pi&ugrave; instabili, comprese quelle incompatibili tra di loro. In questo
caso, star&agrave; alla vostra abilit&agrave; ottenere qualcosa di funzionante.</P>

<H3>iptables 1.2.7 - Usare il patch-o-matic</H3>

<P>Ok, in questo caso, dovrete avere a disposizione sia i sorgenti di iptables, sia
i sorgenti del patch-o-matic. Dall'1.2.7 in poi, infatti, i sorgenti del patch-o-matic
vengono distribuiti indipendentemente dal codice di iptables. </P>
<P>Ipotizzando di aver decompresso tutto in /usr/src, dovrete iniziare
entrando nella directory del patch o matic, ovvero
<BLOCKQUOTE><CODE>
<PRE>
  # cd patch-o-matic-xxxxxxxx
</PRE>
</CODE></BLOCKQUOTE>

dove le 8 x non sono altro che la data di rilascio del patch-o-matic.
Da qui, vi dovrebbe bastare eseguire:
<BLOCKQUOTE><CODE>
<PRE>
  # ./runme pending KERNEL_DIR=/path/assoluto/del/kernel
</PRE>
</CODE></BLOCKQUOTE>

dove ``/path/assoluto/del/kernel'' &egrave; il path dove avete decompresso
il kernel, per esempio ``/usr/src/kernel-source-2.4.19''. In questo caso,
il ``pending'' sta ad indicare che volete installare tutte quelle patch
che sarebbero dovute essere state inserite  prima del rilascio del kernel
ma che per un motivo o per l'altro non sono state applicate.</P>
<P>Come per iptlables 1.2.6, i coraggiosi potrebbero voler riprovare ad
eseguire il comando di prima sostituendo a ``pending'' un ``base'' e poi un ``extra''.</P>
<P>Il ``base'' vi proporr&agrave; l'installazione di quelle patch addizionali che 
dovrebbero lavorare bene insieme e che comunque si sono dimostrate abbastanza stabili. 
Al contrario, un ``extra'' vi proporr&agrave; l'installazione
di <I>tutte</I> le patch disponibili, anche di quelle che potrebbero causare
problemi. Fra queste, alcune possono essere particolarmente utili, come il
supporto per l'h323 o per protocolli o filtri un po' esotici, come lo ``string''
o l'``iplimit''. In ogni caso, vi verr&agrave; presentata una simpatica e
semplice da utilizzare interfaccia a men&ugrave;.</P>


<H3>iptables 1.2.7 - in Debian</H3>

<P>Il pacchetto Debian per iptables 1.2.7 &egrave; strutturato in
modo che nella directory upstream vi siano alcuni file di documentazione ed i
sorgenti originali di iptables (in formato tar.bz2), mentre nella directory debian vi
siano i file necessari per ricompilare iptables.</P>
<P>Automaticamente quindi, il processo di compilazione (avviato utilizzando
il solito ``debuild'' o ``dpkg-buildpackage'')si occuper&agrave; di prendere
i sorgenti del kernel indicati nel file debian/control (campo
Depends, che dovranno gi&agrave; essere installati sul sistema), decomprimerli 
e patcharli con il patch-o-matic contenuto nella directory ``upstream'' ed 
utilizzando tutte le patch elencate nel file ``patch-o-matic.accepted.list''.</P>
<P>Alla fine del processo di compilazione, dovreste quindi trovarvi con i nuovi pacchetti
.deb per iptables ed un nuovo .tar.bz2 contenente i sorgenti del kernel patchati in automatico
da ``debuild''. A questo punto, dovrete rimuovere i sorgenti precedentemente decompressi in 
/usr/src ed utilizzare quelli appena generati dal processo di compilazione di 
iptables, proseguendo poi con il processo di compilazione standard del kernel.</P>
<P>Se invece volete personalizzare il processo di compilazione, dovrete:
<UL>
<LI>Per utilizzare un kernel diverso da quello per cui &egrave; stato
creato il pacchettino, vi consiglio di dare un comando, dalla directory
dove avete decompresso i sorgenti (per esempio, /usr/src/iptables-1.2.7a)
simile a:
<BLOCKQUOTE><CODE>
<PRE>
  # perl -pi -e s/kernel-source-2.4.19/kernel-source-2.4.20/g `find ./ -type -f`
</PRE>
</CODE></BLOCKQUOTE>

per utilizzare i sorgenti del 2.4.20 anzich&eacute; quelli del 2.4.19. 
Questo comando, semplicemente, sostituisce in ogni file della directory
la stringa ``kernel-source-2.4.19'' con la stringa ``kernel-source-2.4.20''.
Abbiate fiducia, la stringa ``kernel-source-2.4.19'' appare solo dove
viene utilizzata per decomprimere i sorgenti del kernel.</LI>
<LI>Per utilizzare una versione diversa del patch-o-matic, scaricate tale
versione in formato .tar.bz2 nella directory upstream, dopodich&egrave; date:
<BLOCKQUOTE><CODE>
<PRE>
  # perl -pi -e s/patch-o-matic-20020825/patch-o-matic-20030220/g `find ./ -type -f`
</PRE>
</CODE></BLOCKQUOTE>

per utilizzare la versione 20030220 al posto della versione 20020825.</LI>
<LI>Infine, per elencare delle patch aggiuntive da applicare, potreste voler
aggiungere delle nuove righe nel file ``patch-o-matic.accepted.list'' nello
stesso formato in cui le altre righe sono indicate (in poche parole, non
cambiate la directory, fate un copia &amp; incolla cambiando solo il nome della
patch).</LI>
</UL>

Questa probabilmente non &egrave; la procedura pi&ugrave; facile o pi&ugrave; semplice
da utilizzare, ma il pacchettino debian non &egrave; stato progettato per essere 
facilmente  modificato dagli utenti.</P>
<P>In questi casi, la soluzione migliore potrebbe essere quella di aspettare la nuova 
versione del pacchetto.</P>
<P>Comunqe, per compilare i sorgenti, dovrete ancora una volta utilizzare ``debuild'' o
``dpkg-buildpackage'', ricordandovi di utilizzare la nuova versione del kernel 
che verr&agrave; generata sotto forma di .tar.bz2 dal processo di compilazione di
iptables.</P>

<H3>Altre patch</H3>

<P>Ok, adesso avete l'ultimissima versione del netfilter e di iptables. Se 
state per&ograve; configurando un firewall ad uso provider, reti di grosse/medie
dimensioni o se avete intenzione di installarlo in posti particolarmente
selvaggi con un minimo di banda a disposizione (non vale la pena se avete
solo una ADSL o poco di pi&ugrave;...), potreste voler essere in grado di
effettuare dello shaping. Alcune tra le patch pi&ugrave; famose per lo shaping 
sono:
<UL>
<LI>L'HTB, ovvero Hicerical Token Bucket filter, un class based queue
molto pi&ugrave; facile da usare e pi&ugrave; preciso (nonch&eacute; altrettanto potente)
dell'equivalente CBQ (tra l'altro, molto ben documentato). E' incluso
nei kernel dal 2.4.20 in su.</LI>
<LI>Il wrr, o Weighted Round Robin, utile soprattutto se avete tanti utenti
dove alcuni si divertono con flashget o equivalenti a saturare completamente
la banda bloccando a tutti gli altri persino la navigazione. 
Disponibile su 
<A HREF="http://wipl-wrr.sourceforge.net">http://wipl-wrr.sourceforge.net</A>, distribuisce equamente la banda
in base alle persone collegate.</LI>
<LI>Se invece non avete una connessione dedicata ma tante ADSL, potreste volere
patchare il kernel in modo che possa essere in grado di fare il bilanciamento
non solo per pacchetto (non funzionerebbe per via del NAT, probabilmente) ma 
per connessione. Non ricordo per&ograve; l'URL della patch.</LI>
</UL>

In questo documento, comunque, non tratteremo l'uso di queste patch, bens&igrave; solo
la loro installazione.</P>
<P>Comunque sia, per queste e tutte le altre patch che vorrete applicare sul codice
di filtraggio o di shaping, la procedura generica &egrave; questa:
<OL>
<LI>Se la patch riguarda nuove capacit&agrave; di filtraggio, probabilmente
riguarda iptables, mentre se introduce nuovi metodi per gestire il traffico
dei pacchetti o le tabelle di routing, probabilmente riguarda iproute.</LI>
<LI>Decomprimete la patch da qualche parte sul vostro disco. Dovrebbero venir
fuori due file .diff: uno per iproute o iptables, l'altro per il vostro kernel.</LI>
<LI>Entrate nella directory del vostro kernel (per esempio, &nbsp;/src/linux/) e
date un 
<BLOCKQUOTE><CODE>
<PRE>
        # patch -p1 &lt; path/file_del_kernel_patch.diff
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Entrate nella directory di iptables o di iproute (per quanto riguarda il 
netfilter ed il codice di shaping, il 99% delle volte ad ogni patch
del kernel corrisponde una di iptables o iproute) e date:
<BLOCKQUOTE><CODE>
<PRE>
        # patch -p1 &lt; path/file_di_iptables_o_iproute_patch.diff
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</OL>
</P>

<H2><A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Preparare il kernel</A>
</H2>

<P>Esistono centinaia di howto (se non migliaia) in giro per internet su come ricompilare
il kernel e per questo mi limiter&ograve; a dare le istruzioni fondamentali per avere un buon 
kernel adatto per un firewall.</P>
<P>Ricordatevi per&ograve; sempre di configurare il kernel <B>dopo</B> :-) aver applicato tutte
le patch, onde evitare di faticare ad applicare delle patch che non verranno mai utilizzate per 
via dei parametri scelti con ``menuconfig'' (o ``xconfig'' o ...).</P>


<H3>Configurarlo</H3>

<P>Ok, a questo punto dovreste avere il vostro kernel decompresso in giro da qualche
parte su una delle vostre partizioni. Entrate dunque nella directory dove &egrave; stato decompresso
e preparatevi per compilarlo con il solito:
<BLOCKQUOTE><CODE>
<PRE>
        # make menuconfig
</PRE>
</CODE></BLOCKQUOTE>

Se vi si presenta un errore qui, la maggior parte delle volte &egrave; perch&eacute;
vi mancano gli header delle ncurses o dei tool fondamentali. Rileggete la sezione
sul <I>prepararsi a ricompilare</I> e su come <I>procurarsi i sorgenti</I>.
Abilitate quindi tutto ci&ograve; che vi serve, con particolare attenzione per&ograve; al men&ugrave;
delle ``networking options''. Abilitate dunque, tenendo le feature sperimentali 
disabilitate:
<BLOCKQUOTE><CODE>
<PRE>
Packet socket
  Packet socket: mmapped IO
Netlink device emulation
Network Packet filtering
Socket Filtering
Unix Domain Sockets
TCP/IP networking
  IP: multicasting
  IP: advanced router 
       e tutte le voci che appariranno
  IP: Tunnelling
  IP: GRE tunnels over IP
    IP: Broadcast GRE over IP
  IP: multicast routing
       e tutte le voci che appariranno
  
  IP: TCP syncookie support 
       (solo se avete un kernel relativamente recente, non ricordo 
       la versione corretta, ma ogni &gt; 2.4.10 dovrebbe andare)
  IP: Netifilter configuration
    Connection Tracking 
       e tutte le voci che appariranno
    IP Tables support
       e tutte le voci che appariranno
802.1d Ethernet Bridging
E tutte le voci sotto 'QoS' and fair queuing
</PRE>
</CODE></BLOCKQUOTE>

Attenzione che la maggior parte di queste opzioni non sono indispensabili (anzi, probabilmente
non le userete mai). Quando per&ograve; mi capita di ricompilare un kernel per un firewall, mi piace 
pensare che abbia tutto ci&ograve; che al momento &egrave; disponibile, e spesso torno indietro abilitando
anche le feature sperimentali, in modo da poter selezionare:
<UL>
<LI>Tutte quelle feature aggiunte tramite patch</LI>
<LI>Il supporto per le VLAN</LI>
<LI>Molti altri componenti gi&agrave; forniti col kernel, parte di iptables, ma considerati
sperimentali.</LI>
</UL>

Attenzione che il vostro kernel non influenzer&agrave; soltanto il comportamento del firewall in 
rete, ma sar&agrave; un componente indispensabile per la sicurezza e la stabilit&agrave; del vostro sistema.
Assicuratevi quindi di comprendere pienamente tutto ci&ograve; che selezionate (comprese le cose
che vi ho indicato), e fatte le dovute considerazioni, non sentitevi in colpa a fare diversamente
da quanto suggerito. Nella peggiore delle ipotesi, dovrete ricompilare il kernel...</P>
<P>Ci sono quindi diverse cose che potreste considerare configurando il kernel del vostro firewall:
<UL>
<LI>Aggiungere delle patch per ``rinforzare'' il sistema (la openwall, www.openwall.com 
non appena sar&agrave; disponibile, oppure la LIDS, che per&ograve; &egrave; molto
invasiva).</LI>
<LI>Disabilitare il supporto per i moduli (esiste almeno un rootkit basato su moduli del kernel, ed
un kernel senza supporto per i moduli potrebbe complicare non di poco il lavoro di un possibile intruso).</LI>
<LI>Abilitare file system come il reiser, l'ext3 o il devfs (per essere in grado di montare i dischi read-only
e per avere una macchina che si comporti un po' come un videoregistratore: che si possa cio&egrave; 
tranquillamente spegnere e accendere senza avere alcuna competenza di linux, o che comunque
in caso di mancanza di corrente non abbia alcun problema a ripartire velocemente).</LI>
<LI>Abilitare il frame buffer, per riuscire a scrivere facilemente regole pi&uacute; lunghe.</LI>
</UL>

Questi sono soltanto spunti o suggerimenti, sta al vostro estro produrre un kernel il pi&ugrave; utile e 
funzionale possibile.</P>
<P>Ricordatevi poi che in un firewall non esiste solo il networking, e non dimenticatevi quindi di
scegliere opportunamente il processore, le periferiche e... </P>
<P>Infine, dopo aver ricompilato ed incluso tutte le funzioni che pi&ugrave; vi stanno a cuore, 
ricordatevi di verificare di aver ottenuto qualcosa di stabile ed utilizzabile, provando il
vostro firewall prima di metterlo in produzione.</P>

<H3>Ricompilarlo</H3>

<P>Per molti di voi sar&agrave; probabilmente superfluo dire di dare:
<BLOCKQUOTE><CODE>
<PRE>
        # make dep bzImage modules modules_install
</PRE>
</CODE></BLOCKQUOTE>

Seguite poi la procedura della vostra distribuzione (o prevista dal vostro boot loader) per installare
il nuovo kernel (lilo piuttosto che grub).</P>
<P>Se ci dovessero essere errori, l'unica cosa che posso suggerirvi &egrave; di provare a correggere gli errori
o eventualmente disabilitare una patch per volta (via menuconfig) fino a riottenere qualcosa di 
ricompilabile...</P>

<H3>In Debian</H3>

<P>Date:
<BLOCKQUOTE><CODE>
<PRE>
        # apt-get install kernel-package
        # make-kpkg binary modules
        # cd ..; dpkg -i kernel-image-2.4.x....deb; dpkg -i kernel-headers*.deb
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss4.4">4.4</A> <A HREF="#toc4.4">Compilare iptables</A>
</H2>

<P>Non dovreste avere grossi problemi... seguite le istruzioni indicate nel file INSTALL e tutto vi andr&agrave; 
bene, a meno che non abbiate abilitato qualche patch troppo sperimentale... comunque, se siete abbastanza
pigri da non voler leggere un file in inglese, vi dovrebbe bastare qualcosa come (dalla directory di iptables):
<BLOCKQUOTE><CODE>
<PRE>
        # make install KERNEL_DIR=path_assoluto/delvostrokernel/
</PRE>
</CODE></BLOCKQUOTE>

Se avete debian, dovreste gi&agrave; avere i pacchettini compilati nei precedenti passi. Questo &egrave;
il momento buono per utilizzare ``dpkg -i iptables_*.deb'' per installarli.</P>

<H2><A NAME="ss4.5">4.5</A> <A HREF="#toc4.5">Compilare iproute</A>
</H2>

<P>iproute normalmente &egrave; un pochettino pi&ugrave; problematico. Questo soprattutto perch&eacute; ha bisogno che
gli headers file del kernel installato sul sistema siano relativi al kernel che avete appena
patchato e ricompilato. Se avete gi&agrave; provato a fare questa procedura, avrete senz'altro visto 
diversi errori relativi a dei tipi non definiti o errori in pak_sched.h (a meno che non
abbiate applicato alcuna patch). Ma andiamo per gradi:
<UL>
<LI>Andate in /usr/include e fate sparire momentaneamente la directory ``linux'' (ad esempio, con
un ``mv ./linux &nbsp;/''). Attenzione! Cos&iacute; facendo potreste creare problemi ad eventuali
altri utenti del sistema, e non &egrave; certo il metodo pi&ugrave; corretto!</LI>
<LI>Date un ``ln -s /path_assoluto_sorgenti_nuovo_kernel/include/linux ./linux''</LI>
</UL>

In questo modo avete messo a posto gli headers file per poter ricompilare iproute (esistono centinaia
di modi pi&ugrave; furbi per farlo, ma credo che questo sia uno dei pi&ugrave; semplici).</P>
<P>Entrate quindi nella directory di iproute e provate a compilarlo seguendo le istruzioni fornite (dovrebbe 
bastare un semplice ``make install''). Non vi spaventate se non va liscio la prima
volta: alcune versioni di iproute citano in uno dei file .c una costante che non &egrave; pi&ugrave; definita negli 
headers di linux.</P>
<P>Per risolvere il problema, baster&agrave; semplicemente aprire con un editor il file nella directory
lib chiamato ll_proto.c (iproute/lib/ll_proto.c) e commentare via la riga (sul mio sistema la 36)  
<BLOCKQUOTE><CODE>
<PRE>
__PF(ECHO,echo) 
</PRE>
</CODE></BLOCKQUOTE>

sostituendola con la riga 
<BLOCKQUOTE><CODE>
<PRE>
/* __PF(ECHO,echo) */
</PRE>
</CODE></BLOCKQUOTE>

Non vi preoccupate, non &egrave; una mia idea ed &egrave; un problema abbastanza documentato dove &egrave; prassi
normale per risolverlo commentare via la riga indicata (tra l'altro, al momento del rilascio
di questo documento, potrebbe essere un problema gi&aacute; risolto).</P>
<P> Riprovate quindi a compilare... 
se ancora non vi va bene, controllate di aver sistemato correttamente
/usr/include/linux e di aver applicato a iproute tutte le patch che avete applicato 
al vostro kernel e viceversa.</P>
<P>Se ancora non riuscite a compilare e non avete delle buone conoscenze del C, vi consiglio di riprovare a ricompilare
iproute senza nessuna patch, poi con una, poi con due... finch&eacute; non smette di funzionare. Se gi&agrave; dall'inizio
non si ricompila, probabilmente vi manca qualche tool necessario per la compilazione o avete qualche
header un po' particolare. Provate a chiedere sulle mailing-lists delle vostre distribuzioni.</P>
<P>Se invece non vi ha dato problemi, ed &egrave;
andato tutto liscio al primo colpo, probabilmente siete stati fortunati... non vi preoccupate :-)...</P>


<H3>In Debian</H3>

<P>La procedura &egrave; la stessa di iptables: entrate nella directory di iproute e date
<BLOCKQUOTE><CODE>
<PRE>
        # debuild 
        # cd ..; dpkg -i *.deb  
</PRE>
</CODE></BLOCKQUOTE>

oppure
<BLOCKQUOTE><CODE>
<PRE>
        # dpkg-buildpackage 
        # cd ..; dpkg -i *.deb  
</PRE>
</CODE></BLOCKQUOTE>

per fabbricare i .deb contenenti la vostra versione personalizzata di iproute.</P>
<P>Se la procedura si blocca durante la compilazione, leggete le raccomandazioni nella
sezione precedente, dove si descrive la procedura di installazione manuale, e verificate
di aver gi&agrave; installato il nuovo kernel con dpkg.</P>

<H2><A NAME="s5">5.</A> <A HREF="#toc5">Hardening the system </A></H2>

<P>Con ``hardening the system'' si intende la procedura utilizzata
per rendere il sistema il pi&ugrave; resistente possibile ai vari tentativi
di attacco. La procedura di per s&eacute; &egrave; abbastanza semplice, e si pu&ograve; riassumere
in quattro semplici passi: 
<UL>
<LI>Eliminare tutto ci&ograve; che &egrave; inutile al funzionamento del firewall,
ovvero tutto ci&ograve; che potrebbe essere utilizzato contro di
voi.</LI>
<LI>Rendere difficilmente identificabile il sistema in modo da rendere
pi&ugrave; difficile per un attaccante capire che strumenti utilizzare
per potervici entrare.</LI>
<LI>Limitare le capacit&agrave; del firewall in maniera da rendere la vita il
pi&ugrave; difficile possibile per un intruso (dischi readonly, mancanza
di tool basilari, strette regole di firewalling anche per la 
catena in OUTPUT...).</LI>
<LI>Mettersi nella posizione di poter rilevare facilmente un'intrusione.</LI>
</UL>

In questo documento vi vengono date delle indicazioni molto sbrigative
e sommarie in proposito, che dovrebbero essere interpretate pi&ugrave; che 
altro come spunti. Vi consiglio di riferirvi a documentazione specifica in 
proposito.</P>

<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Ridurre i punti di ingresso</A>
</H2>

<P>L'idea di base &egrave; quella di eliminare tutto ci&ograve; che in rete
potrebbe essere facilmente attaccato. Potreste quindi voler seguire
le indicazioni contenute nelle prossime sezioni.</P>

<H3>inetd.conf</H3>

<P>In questo file sono indicati alcuni servizi di rete che dovranno essere attivi
sulla vostra macchina. Alcune distribuzioni, invece dello standard inetd, utilizzano
xinetd che fa uso di una struttura a directory e di un diverso file di configurazione.
Se la vostra distribuzione utilizza inetd.conf, vi dovrebbe bastare commentare tutte le
righe che servono per attivare servizi che non vi interessa offrire, inserendo un 
``#'' all'inizio della riga stessa. Un
tipico file inetd.conf al termine dell'installazione di debian (a secondo di quello
che &Egrave; stato installato) potrebbe essere simile al seguente:
<BLOCKQUOTE><CODE>
<PRE>
# [...]
#
#:INTERNAL: Internal services
echo            stream  tcp     nowait  root    internal
echo            dgram   udp     wait    root    internal
chargen         stream  tcp     nowait  root    internal
chargen         dgram   udp     wait    root    internal
discard         stream  tcp     nowait  root    internal
discard         dgram   udp     wait    root    internal
daytime         stream  tcp     nowait  root    internal
daytime         dgram   udp     wait    root    internal
time            stream  tcp     nowait  root    internal
time            dgram   udp     wait    root    internal

#:STANDARD: These are standard services.
ftp             stream tcp nowait root /usr/sbin/tcpd /usr/sbin/proftpd

#:BOOT: Tftp service is provided primarily for booting.  Most sites
# run this only on machines acting as "boot servers."
#tftp           dgram   udp     wait    nobody  /usr/sbin/tcpd  /usr/sbin/in.tftpd /boot

# [...]
</PRE>
</CODE></BLOCKQUOTE>

La maggior parte di questi servizi (il nome indicato nella prima colonna), 
sono servizi *nix standard, forniti per motivi di conformit&agrave; con altri
sistemi *nix e per lo pi&ugrave; inutili.</P>
<P>Nel nostro caso, il firewall non offrir&agrave; alcun servizio, nel senso
che non vi sar&agrave; installato alcun server, salvo, forse, per il server
``ssh'' per l'amministrazione remota. Dovremmo quindi provvedere a commentare
tutte le righe inserendo un cancelletto all'inizio della riga, come mostrato
per il servizio ``tftp''.</P>
<P>Nel caso decidiate di lasciare alcuni servizi aperti, fate attenzione alla
quinta colonna, che contiene i privilegi con cui il programma verr&agrave;
eseguito, e alla sesta, che contiene il programma da eseguire. A parte 
i programmi indicati come internal, la maggior parte delle volte vedrete
in sesta colonna il comando ``/usr/sbin/tcpd''. Questo, in gergo,
viene definito un ``wrapper''. Quello che fa questo comando, infatti,
&egrave; semplicemente eseguire ci&ograve; che viene indicato nella
colonna successiva. L'utilit&agrave; del wrapper &egrave; che prima di 
eseguire il comando indicato, quando ricever&agrave; una connessione, questo 
si occuper&agrave; di effettuare alcune verifiche
decidendo se bloccare o consentire l'utilizzo del servizio.</P>
<P>Le decisioni di questo wrapper sono normalmente basate sul contenuto
del file /etc/hosts.allow e /etc/hosts.deny.
Maggiori informazioni sul formato di questo file possono essere
reperite sulla pagina di manuale di ``hosts_access'' e ``hosts_options''.</P>

<H3>Directory /etc/init.d</H3>

<P>In questa directory sono normalmente contenute due categorie di script:
<UL>
<LI>quelli necessari per effettuare alcune operazioni durante l'accensione
e lo spegnimento del computer.</LI>
<LI>quelli necessari per far partire o bloccare quei servizi che una volta
attivati dovrebbero continuare a funzionare finch&egrave; non esplicitamente
bloccati (facendo il logout non si fermano -- demoni come apache, bind,
sendmail o ...).</LI>
</UL>

In Debian e in altre distribuzioni con un sistema di boot conforme a quello di System V,
in /etc (o /etc/rc.d) esistono altre directory chiamate rc0.d,
rc1.d, rc2.d e cos&igrave; via. Queste directory contengono dei link
simbolici agli script in ``init.d'' che dovranno essere eseguiti quando si passa rispettivamente
a runlevel 0, 1, 2 e cos&igrave; via.</P>
<P> Ogni runlevel, poi, pu&ograve; essere utilizzato in 
modo diverso e gli pu&ograve; venire assegnato un particolare significato. Ad esempio, l'operazione
di shutdown consiste nel passaggio dal runlevel corrente al runlevel 0 (per cui, tutti gli script
in rc0.d verranno utilizzati per bloccare i vari servizi e per eseguire le operazioni
di spegnimento), il runlevel 2 &egrave; quello standard
che viene eseguito quando si accende il computer, ed il 6 viene usato per il reboot.</P>
<P>Per rendere pi&ugrave; sicuro il nostro firewall, dovremmo quindi prodigarci per evitare che
durante l'accensione vengano avviati dei servizi che potrebbero essere utilizzati contro di noi.</P>
<P>Il metodo normalmente utilizzato &egrave; quello di eliminare i link simbolici (con un semplice rm)
relativi a servizi che non ci interessano dalla directory relativa al runlevel utilizzato per avviare 
il sistema (normalmente ``rc2.d'', almeno in Debian).
Alcune distribuzioni utilizzano metodi pi&ugrave; esotici per gestire questi link simbolici, per cui
vi conviene dare un'occhiata alla documentazione che vi &egrave; stata fornita.</P>
<P>In Debian per esempio, &egrave; possibile utilizzare lo script ``update-rc.d'', con 
qualcosa di simile a:
<BLOCKQUOTE><CODE>
<PRE>
  update-rc.d apache remove
</PRE>
</CODE></BLOCKQUOTE>

per evitare che apache venga caricato durante l'avvio o lo shutdown. Un'altra alternativa
potrebbe essere quella di rimuovere del tutto apache (probabilmente inutile se non lo si 
fa partire a boot-up), con il solito:
<BLOCKQUOTE><CODE>
<PRE>
  apt-get --purge remove apache
</PRE>
</CODE></BLOCKQUOTE>

Per avere un elenco dei programmi attivi che offrono servizi in rete, potreste
voler utilizzare il comando netstat, con 
<BLOCKQUOTE><CODE>
<PRE>
  # netstat -npla |less
</PRE>
</CODE></BLOCKQUOTE>

che vi dovrebbe indicare le porte rimaste aperte ed i relativi processi.</P>



<H3>Demoni</H3>

<P>In generale comunque, per i servizi che deciderete di lasciare attivi, ricordatevi
dove possibile di:
<UL>
<LI>eliminare banner di benvenuto o comunque quelle informazioni che 
mostrino il nome e la versione dei programmi utilizzati.</LI>
<LI>controllate mailing list di sicurezza, come per esempio bugtraq, 
per verificare che i demoni lasciati attivi non contengano bug
pericolosi.</LI>
<LI>non lasciate demoni attivi con privilegi di root.</LI>
</UL>

Per ci&ograve; che offre servizi in rete, se vi voleste veramente divertire,
potreste utilizzare delle porte diverse rispetto quelle standard: se metteste per esempio 
ssh sulla porta 42 piuttosto che sulla 54, potreste evitare tutti quegli scanner che 
mandano pacchettini in giro per la rete alla ricerca di particolari versioni di particolari 
software da poter facilmente bucare. Certo, questo pu&oacute; creare parecchia confusione 
anche dal punto di vista dell'amministrazione (soprattutto se ogni volta utilizzate una porta 
diversa), ma a lungo andare potrebbe dimostrarsi una utile contromisura. Attenzione
per&ograve; che se il demone che state utilizzando contiene dei bachi di sicurezza, questo
continuer&agrave; ad averne anche se deciderete di utilizzare una diversa porta.</P>
<P>Per cambiare impostazioni come la porta, i privilegi che il demone dovr&agrave;
avere o per cambiare i banner di benvenuto, riferitevi alla documentazione specifica
fornita col demone installato.</P>

<H2><A NAME="ss5.2">5.2</A> <A HREF="#toc5.2">Ripulire il sistema</A>
</H2>

<P>
<UL>
<LI>Eliminate tutti i tool di compilazione (make, gcc...), gli header file, o
tutti quei tool di debugging (gdb, objdump...) che potrebbero essere usati
contro di voi. Se avete bisogno di ricompilare, potrete sfruttare una macchina
di appoggio e i tool per creare i pacchetti messi a disposizione 
dalla vostra distribuzione. In questo modo, non rischierete di dimenticare
tool pericolosi o sorgenti in giro.

</LI>
<LI>Cercate poi tutti quei programmi noti come ``suid'' root, cio&egrave; che possono
prendere i privilegi dell'amministratore una volta caricati (find / -perm +4000),
e togliete loro questa possibilit&agrave; <B>valutando per&ograve; caso per caso</B>. Ad esempio 
vorrete probabilmente lasciare /bin/login suid root, mentre a ping, mount &amp; co. credo
possa essere tolto tranquillamente questo privilegio con comandi del tipo ``chmod ug-s nomefile''.</LI>
<LI>Configurate propriamente fstab, lasciando solo
/var scrivibile e lasciando tutte le altre partizioni read-only, limitando persino la
creazione di dispositivi o l'esecuzione di file suid root. Un esempio di fstab 
potrebbe essere il seguente:
<BLOCKQUOTE><CODE>
<PRE>
proc          /proc     proc      defaults                       0 0 
/dev/hda1     none      swap      sw                             0 0
/dev/hda5     /         ext2      ro,defaults,errors=remount-ro  0 1 
/dev/hda2     /boot     ext2      ro,nosuid,noexec,nodev,nouser  0 3 
/dev/hda7     /var      reiserfs  rw,nosuid,nodev,nouser         0 3 
/dev/hda8     /home     reiserfs  rw,nosuid,nodev,nouser         0 3
</PRE>
</CODE></BLOCKQUOTE>

dove <I>nosuid</I> indica al kernel di non eseguire programmi con privilegi suid, <I>noexec</I> di non
eseguire alcun programma, <I>nodev</I> di non consentire la creazione di dispositivi
e infine <I>nouser</I> di non permettere agli utenti di montare o smontare la partizione indicata.
<P>Attenzione per&ograve; che la vostra distribuzione potrebbe non essere troppo contenta
di avere a che fare con dischi readonly, soprattutto per quanto riguarda la 
root. Una soluzione che ho visto funzionare abbastanza bene (salvo qualche directory)
&eacute; stata quella di scrivere due script, mkro e mkrw, il primo per rendere la root
read only ed il secondo per renderla read write, e di installarli in modo che venissero
eseguiti rispettivamente come l'ultimo comando a startup ed il primo comando a shutdown.
In Debian, &egrave; possibile fare questo copiando i due file nella directory /etc/init.d
e dando i comandi ``update-rc.d mkro start 99 2'' e ``update-rc.d mkrw stop 00 6''.</P>
<P> 
Cos&igrave; facendo, la partizione di root dovrebbe essere indicata come ``rw'' nel file 
fstab.</P>
<P>Notate inoltre che in /var viene consentita l'esecuzione di programmi: questo perch&eacute; la 
maggior parte delle distribuzioni utilizzano /var per conservare gli 
script di installazione/disinstallazione dei vari pacchettini che devono essere eseguiti.</P>
<P>Infine, attenzione che la partizione che contiene la directory /dev deve essere montata 
come rw... una buona soluzione &eacute; quella di utilizzare o una partizione a parte, o una partizione
creata da un ramdisk o shm, oppure utilizzare il devfs con il demone devfsd (soluzione sicuramente 
migliore).</P>
<P>Per quanto riguarda /tmp, questa viene utilizzata da molti programmi e deve quindi 
essere scrivibile. Sempre che non abbiate creato una partizione indipendente per /tmp, una soluzione 
potrebbe essere quella di creare un symlink /tmp a /var/tmp, oppure sfruttare 
le nuove capacit&agrave; del kernel 2.4 aggiungendo da qualche parte nei file eseguiti all'avvio un comando
del tipo:
<BLOCKQUOTE><CODE>
<PRE>
  mount --bind /var/tmp /tmp
</PRE>
</CODE></BLOCKQUOTE>

che monterebbe in maniera molto particolare (estremamente simile ad un hard link) la directory 
/var/tmp su /tmp. Attenzione per&ograve; che il FHS (lo standard per 
la struttura del file system), indica che in /tmp i file possono essere rimossi 
in qualsiasi istante dall'amministratore del sistema, e consiglia di ripulire /tmp durante i 
reboot. Al contrario, /var/tmp non deve essere ripulita durante i reboot e deve consentire la 
creazione di file ``abbastanza persistenti''.  Per evitare problemi con la vostra distribuzione, 
&egrave; quindi consigliabile far puntare /tmp ad una sottodirectory di /var/tmp in 
modo che un'eventuale pulizia periodica di /tmp non rimuova tutti i file di /var/tmp. 
Per esempio, potreste fare qualcosa del tipo:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
mkdir /var/tmp/removable/
mount --bind /var/tmp/removable/ /tmp
</PRE>
</CODE></BLOCKQUOTE>

Piuttosto che
<BLOCKQUOTE><CODE>
<PRE>
mkdir /var/tmp/removable/
cd /; ln -s /var/tmp/removable ./tmp
</PRE>
</CODE></BLOCKQUOTE>

Infine, parlando di partizioni read only o read write, &egrave; bene dedicare un minimo di 
attenzione al file /etc/mtab. In questo file viene mantenuto l'elenco delle
partizioni montate col comando ``mount''. In pratica, quando date il comando ``mount'' da 
solo, per vedere le partizioni montate, vi viene mostrato il contenuto di questo file.
Il problema &egrave; che montando la root read only, mount non sar&agrave; in 
grado di aggiornare questo file e di capire quali partizioni sono montate, dando origine a 
degli errori piuttosto bizzarri. Una buona soluzione &egrave; quella di eliminare il file 
mtab completamente e di creare un link simbolico in /etc che punti al file
/proc/mounts. Questo file mostra le informazione conosciute dal kernel a proposito dei
dischi montati, e non pu&ograve; quindi contenere errori. In pratica date:
<BLOCKQUOTE><CODE>
<PRE>
cd /etc
rm ./mtab
ln -s /proc/mounts ./mtab
</PRE>
</CODE></BLOCKQUOTE>
</P>
</LI>
<LI> Per i file system ext2/3 potreste poi volere utilizzare il comando ``chattr +i nomefile'',
per marcare i file a livello di filesystem come immodificabili. Questo &egrave; utile
soprattutto perch&eacute; si tratta di una modifica poco visibile (normalmente non si vede con ls -al)
e non consente nemmeno a root di modificare il file, a meno che prima non esegua
un comando come ``chattr -i nomefile'', sempre che chattr non sia stato preventivamente
rimosso dal sistema :-).

</LI>
<LI>Date un'occhiata a /etc/crontab e alle varie directory, eliminando ci&ograve;
che non serve.  Ad esempio, su un sistema con dischi read-only non credo sia necessario
aggiornare il database di ``locate''.  Spesso poi, gli script eseguiti da cron interagiscono con il
sistema e pu&ograve; capitare che possano essere imbrogliati costringendoli a fare cose non volute. Normalmente
tutte le distribuzioni tendono ad evitare errori di questo tipo ed &eacute; molto raro trovarne, ma una 
verifica non costa nulla
e pu&ograve; garantirvi un grado di sicurezza maggiore.</LI>
<LI>Se sul sistema vi saranno altri utenti oltre root, date un'occhiata alle restrizioni imposte dalla 
pam (/etc/pam.d) agli utenti ed al file /etc/login.defs.</LI>
<LI>Se avete un kernel relativamente recente, date un'occhiata al comando ``lcap'' (in Debian, installate
l'omonimo pacchetto, con ``apt-get install lcap''). lcap &egrave; un comando che vi consente di
dire al kernel che <B>non</B> volete pi&ugrave; usufruire di determinati servizi (capability, ovvero
``capacit&agrave;'' del kernel). Una volta detto questo al kernel, le capability non potranno
pi&ugrave; essere acquisite dal kernel, a meno che la macchina non venga spenta e riavviata.
Il fatto che il kernel di linux perda determinate ``capacit&agrave;'' pu&ograve; quindi dare 
notevoli vantaggi dal punto di vista della sicurezza. Utilizzando il comando ``lcap'' senza
alcun argomento, vi verr&agrave; data una lista delle ``capacit&agrave;'' che il kernel
pu&ograve; decidere di lasciare, come per esempio:
<BLOCKQUOTE><CODE>
<PRE>
Current capabilities: 0xFFFFFEFF
   0) *CAP_CHOWN                   1) *CAP_DAC_OVERRIDE         
   2) *CAP_DAC_READ_SEARCH         3) *CAP_FOWNER               
   4) *CAP_FSETID                  5) *CAP_KILL                 
   6) *CAP_SETGID                  7) *CAP_SETUID               
   8)  CAP_SETPCAP                 9) *CAP_LINUX_IMMUTABLE      
  10) *CAP_NET_BIND_SERVICE       11) *CAP_NET_BROADCAST        
  12) *CAP_NET_ADMIN              13) *CAP_NET_RAW              
  14) *CAP_IPC_LOCK               15) *CAP_IPC_OWNER            
  16) *CAP_SYS_MODULE             17) *CAP_SYS_RAWIO            
  18) *CAP_SYS_CHROOT             19) *CAP_SYS_PTRACE           
  20) *CAP_SYS_PACCT              21) *CAP_SYS_ADMIN            
  22) *CAP_SYS_BOOT               23) *CAP_SYS_NICE             
  24) *CAP_SYS_RESOURCE           25) *CAP_SYS_TIME             
  26) *CAP_SYS_TTY_CONFIG       
    * = Capabilities currently allowed
      
</PRE>
</CODE></BLOCKQUOTE>

Ad esempio, con ``lcap CAP_CHOWN'' il kernel mollerebbe la capacit&agrave; di far andare la
chiamata di sistema CHOWN, rendendo impossibile il cambio di proprietario di un file.
Eseguendo quindi il comando ``chown'', questo ci restituirebbe un errore del tipo ``Operation
not permitted''. In breve, disattivare la capacit&agrave; del kernel:
<UL>
<LI>CAP_CHOWN -- inibisce il cambio di proprietario di un file, blocca il comando chown.
Attenzione che, ad esempio in Debian, ogni volta che un utente completa il login
viene fatto un chown sul dispositivo corrispondente alla sua console, onde evitare
che altri (senza la sua autorizzazione) possano scrivere su tale dispositivo. Bloccare
chown bloccher&agrave; quindi l'accesso a <B>tutti</B>, compreso l'amministratore,
a meno che questa feture non venga disabilitata.</LI>
<LI>CAP_NET_BIND_SERVICE -- inibisce l'apertura di porte TCP o UDP inferirori alla 1024, 
impedendo il caricamento di nuovi servizi su porte standard.</LI>
<LI>CAP_NET_ADMIN -- inibisce: il cambio di configurazione delle interfacce di rete o
la configurazione di nuove interfacce, le operazioni di amministrazione del codice
di firewalling, nat, accounting, l'abilitazione del debugging sulle socket, la 
modifica delle tabelle di routing, l'abilitazione/disabilitazione del promiscuous
mode e altre.</LI>
<LI>CAP_SYS_MODULE -- inibisce il caricamento o la rimozione di moduli.</LI>
<LI>CAP_SYS_CHROOT -- inibisce l'utilizzo di jail root, ovvero del comando chroot.</LI>
<LI>CAP_SYS_PACCT -- inibisce il cambio di configurazione del process accounting .</LI>
<LI>CAP_SYS_BOOT -- inibisce la possibilit&agrave; di riavviare la macchina tramite
comandi.</LI>
<LI>CAP_SYS_RESOURCE -- inibisce il cambio dei limiti di risorse imposti ai vari
processi o delle quote imposte su disco (per fs ext2).</LI>
<LI>CAP_SETUID -- inibisce l'utilizzo di programmi suid.</LI>
<LI>CAP_LINUX_IMMUTABLE -- inibisce la possibilit&agrave; di cambiare il flag 
immutabile tramite il comando ``chattr''</LI>
<LI>CAP_NET_RAW -- inibisce la possibilt&agrave; di aprire PACKET o RAW socket,
ovvero quelle socket che consentono a programmi come hping o nmap di
scrivere direttamente i pacchetti sulle interfacce di rete.</LI>
<LI>CAP_SYS_RAWIO -- inibisce la possibilit&agrave; di accedere direttamente
ai dispositivi fisici. In pratica, non sar&agrave; pi&ugrave; possibile
accedere a /dev/hda, /dev/hdb e cos&igrave; via.</LI>
<LI>CAP_SYS_PTRACE -- inibisce l'utilizzo di ``ptrace()'', la chiamata che 
consente a comandi come strace, ltrace o gdb di seguire il comportamento
di un processo. </LI>
<LI>CAP_SYS_ADMIN -- inibisce:
<UL>
<LI>la configurazione di quote su disco, la creazione di dispositivi,
l'amministrazione di /dev/random e urandom.</LI>
<LI>la configurazione dei messaggi inviati dal kernel a syslog, il cambio
di nome di dominio, il cambio di hostname.</LI>
<LI>l'utilizzo di mount e umount, l'abilitazione disabilitazione dello swap,
la configurazione di dispositivi raid ed il tuning dei parametri ide.</LI>
</UL>

e cos&igrave; via.</LI>
</UL>

Per maggiori informazioni, potete dare un'occhiata a ``lids.planetmirror.com'' 
oppure cercare le ``capacit&agrave;'' direttamente in google.
L'utilizzo di ``lcap'' apre diversi nuovi orizzonti. Si potrebbe, per esempio, inserire
in init.d uno script simile al seguente: 
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash

        lcap CAP_NET_BIND_SERVICE CAP_NET_ADMIN CAP_SYS_MODULE CAP_SYS_PACCT \
             CAP_SYS_RESOURCE CAP_SETUID CAP_LINUX_IMMUTABLE CAP_NET_RAW CAP_SYS_RAWIO \
             CAP_SYS_PTRACE CAP_SYS_ADMIN
</PRE>
</CODE></BLOCKQUOTE>

in modo da disabilitare la maggior parte delle funzioni che potrebbero risultare
pericolose. Allo stesso modo, utilizzando il comando ``chattr +i'' si potrebbero
impostare come immutabili tutti i file coinvolti con il processo di boot, cos&igrave;
da impedire che il sistema possa essere riavviato senza chiamare ``lcap''.
Per avere ancora una maggior sicurezza, si potrebbe poi disabilitare il ``reboot''
del sistema, in modo che da remoto, anche ipotizzando che un attaccante possa
riuscire a far s&igrave; che lcap non venga chiamato nel prossimo reboot, il
sistema non possa essere riavviato senza la presenza fisica di una persona
in sala macchine. In pi&ugrave;, lasciare la capacit&agrave; CAP_NET_ADMIN
e CAP_NET_RAW impedir&agrave; all'attaccante di installare degli sniffer che 
impostino l'interfaccia in promiscuous mode ed il cambio delle regole di
firewalling. 
<P>Questo stesso script, potrebbe poi essere inserito in ``runlevel 2'',
creando un link da /etc/rc2.d/S99-lcap a /etc/init.d/script_appena_creato,
in modo che specificando qualcosa come ``runlevel=3'' dal prompt di lilo
e di grub sia possibile accedere al sistema senza i limiti imposti da 
questo comando.</P>
</LI>
</UL>
</P>

<H2><A NAME="ss5.3">5.3</A> <A HREF="#toc5.3">Rilevare le intrusioni</A>
</H2>

<P>Beh, di tool per rilevare le intrusioni ce ne sono a decine disponibili sulla 
rete. Alcuni che vi posso consigliare sono:
<UL>
<LI>logcheck, per rilevare le differenze nei file di log in maniera pi&ugrave; o meno
intelligente, in modo da non aver mega e mega di log da leggere ogni giorno.</LI>
<LI>tripwire o equivalenti (in debian sono disponibili debsums e debsig-verify, sicuramente molto
utili e funzionali), per rilevare modifiche non volute ai file.</LI>
<LI>msyslogd o syslog-ng, per essere sicuri che i log non vengano alterati (possono usare entrambi
dei sistemi di checksumming crittografici per memorizzare i log). Inoltre, sono in grado di trasmettere in
maniera abbastanza sicura i log da una macchina all'altra. Questo potrebbe darvi garanzie
ancora maggiori sull'autenticit&agrave; di questi log.</LI>
<LI>snort, per rilevare scansioni o attacchi conosciuti dalla rete (viene considerato un
IDS, ovvero, Intrusion Detection System).</LI>
<LI>netacctd, per tenere traccia delle connessioni effettuate.</LI>
<LI>arpwatch, per monitorare le workstation sulle varie reti ed eventualmente
rilevare tentativi di arp spoofing.</LI>
<LI>tcpdump, nel caso in cui il peggio accada, per loggare tutto il traffico
e tentare di risalire al colpevole (creando, magari, uno script che lo carichi
come demone con delle opzioni tipo -nei eth0 -s 2048 -w /var/log/traffic.dump).</LI>
</UL>

E molti altri... (suggerimenti sono benvenuti).</P>

<H3>Process accounting</H3>

<P>Abilitando nel kernel l'opzione ``General Setup/BSD Process Accounting'' &egrave; 
possibile utilizzare
il ``process accounting''. Il ``process accounting'' consente di mantenere
delle statistiche su ogni comando eseguito sul sistema, statistiche come
l'utente che l'ha eseguito, la cpu che ha utilizzato, il tempo che e`
stato eseguito e simili.</P>
<P>Per utilizzare il process accounting &egrave; possibile installare
utility come ``acct'', ``lastcomm'' ed ``sa'', in Debian contenute tutte
nel pacchetto ``acct''. Questo stesso pacchetto si occupa durante
il processo di boot di chiamare ``accton nomefile.log'', che altro
non fa che abilitare il process accounting dicendo al kernel di
salvare le informazioni acquisite nel file di log indicato, generalmente
``/var/account/pacct''.</P>
<P>Una volta abilitato, sar&agrave; possibile utilizzare utility
come ``sa'', per avere delle statistiche sugli ultimi comandi eseguiti e
``lastcomm'' per vedere i comandi eseguiti da ogni utente, divisi
per tempo di esecuzione, terminale da cui sono stati lanciati e da
alcuni flag indicanti come il comando sia stato eseguito.</P>

<H2><A NAME="s6">6.</A> <A HREF="#toc6">Pericoli -- ovvero, da cosa dovr&agrave; difendervi il firewall</A></H2>

<P>Per rendere la trattazione pi&ugrave; semplice, &egrave; meglio chiarirsi 
le idee fin dall'inizio. Il firewall che andr&agrave; a proteggere la vostra
rete sar&agrave; in grado di filtrare il traffico secondo delle regole
da voi stabilite. Lo scopo di queste regole sar&agrave; quindi principalmente
quello di: 
<OL>
<LI>proteggere i vostri computer e i vostri server, rendendo accessibili
solo alcuni servizi dall'esterno della vostra rete.</LI>
<LI>fare in modo che gli utenti della vostra rete non facciano operazioni non consentite.</LI>
<LI>evitare che il traffico consentito possa provocare dei danni. Per spiegarmi meglio,
se aveste un web server interno alla vostra rete disponibile anche tramite internet,
dovreste consentire il traffico sulla porta 80 ma al contempo fareste il possibile
per evitare attacchi come syn flood o simili (vedi prossima sezione), conosciuti
come ``DoS'' o ``DDoS'', rispettivamente ``Denyal of Service'' e ``Distributed
Denyal of Service'', attacchi che mirano a sovraccaricare o a interrempore un
servizio da voi offerto.</LI>
<LI>evitare che i vostri server o i vostri client possano essere utilizzati da qualcun
altro per sferrare degli attacchi a danni di terzi.</LI>
<LI>evitare il pi&ugrave; possibile i danni che vi potrebbe arrecare un attaccante
nel caso riuscisse ad impossessarsi di una delle vostre macchine o dei vostri
server.</LI>
</OL>

Per quanto riguarda i primi 3 punti, non credo di aver detto nulla di originale. 
Normalmente lo scopo di un firewall &egrave; proprio quello o di proteggere 
servizi da noi offerti (o utilizzati internamente
alla nostra rete), o limitare ci&ograve; che i nostri utenti possono fare. </P>
<P>Gli ultimi due punti, invece, vengono spesso sottovalutati o completamente ingorati, pur essendo
fondamentali per almeno due motivi:
<OL>
<LI>Per evitare un effetto ``domino'', per evitare cio&egrave; che ``caduto'' (bucato) un
server, questo possa essere sfruttato per far ``cadere'' tutti gli altri. Spesso infatti, quando una ditta dispone
di pi&ugrave; server, vengono impostate delle politiche meno restrittive (se queste vengono
impostate) per le comunicazioni da un server all'altro che potrebbero consentire ad 
un attaccante di bucare una macchina e da l&igrave; bucare tutte le altre.</LI>
<LI>Per evitare che la vostra macchina possa essere utilizzata per sferrare attacchi a terzi.
Se tutti utilizzassero delle politiche di questo tipo sarebbe molto pi&ugrave; facile
tracciare eventuali attaccanti.</LI>
</OL>

Una configurazione normalmente utilizzata che tiene in considerazione
tutti i punti sopra elencati fa uso di quella che viene detta una DMZ, ovvero di una
``Zona Demilitarizzata''.</P>
<P>In pratica la rete di un'azienda viene divisa dal punto di vista hardware in tre segmenti, ed il firewall
viene dotato di 3 schede di rete (ognuna collegata ad un segmento). Di queste schede,
una viene collegata alla rete interna (utilizzata, per esempio, dai dipendenti), una collegata ad internet 
mentre l'ultima ad una piccola rete che conterr&agrave; soltanto i vostri server.</P>
<P> 
In questo modo, il firewall sar&agrave; in grado di proteggere i vostri server sia da attacchi 
provenienti dalla rete interna (e, da questo punto di vista, ci sono stati casi davvero eclatanti) 
sia da attacchi provenienti da internet.</P>
<P>Allo stesso modo, sar&agrave; in grado di proteggere la vostra rete interna da attacchi provenienti
sia dai vostri server che da internet, e di proteggere internet da attacchi provenienti 
sia dai vostri server che dalla vostra rete interna. Il fatto che <I>sia in grado</I> non implica 
per&ograve; che lo faccia sul serio. Spesso viene sottovalutata la pericolosit&agrave; di attacchi 
provenienti dai propri server o dalla propria rete interna e vengono scritte delle regole meno restrittive 
o non vengono scritte affatto.  Questo &egrave; un errore sicuramente da evitare. Un altro
errore da evitare &egrave; quello di non sfruttrae le capacit&agrave; di firewalling sui 
server, o di allentare le politiche di sicurezza ``visto che c'&egrave; il firewall'': &egrave;
vero che il firewall c'&egrave; e funziona, ma essere un po' paranoici il pi&ugrave; delle volte
non guasta. Pu&ograve; capitare, per esempio, di fare una modifica sul firewall dimenticandosi 
del tale server, piuttosto che cambiare lo spinotto a cui era collegato. </P>

<H2><A NAME="ss6.1">6.1</A> <A HREF="#toc6.1">Assunzioni errate</A>
</H2>

<P>Esistono poi alcuni errori che &egrave; facile commettere o miti che &egrave; bene sfatare prima di 
fare delle assunzioni errate a proposito della propria rete. Tenete quindi ben presente
che in una rete:
<UL>
<LI><B>tutti i dati possono essere falsificati</B> -- una ``scheda di rete'' non &egrave; altro
che un dispositivo fatto per scrivere su di una rete, un po' come una testina &egrave;
in grado di scrivere su dei dischi magnetici. I pacchetti non sono altro che dati che vengono
scritti su di una rete, e possono essere quindi falsificati o inventati di sana pianta. Nessuno
mi impedisce di ``scrivere'' con la mia scheda di rete dei pacchetti che indicano
come mittente il computer di qualcun altro o delle informazioni assolutamente insensate.
Scrivete quindi sempre delle regole che vietino o consentano anche ci&ograve; che pu&ograve;
sembrare ovvio. Per esempio,
se avete una intefaccia collegata alla rete 10.0.0.0/8, potreste scrivere come prima
regola ``vieta tutto ci&ograve; che viene dalla determinata scheda di rete ma che non
ha 10.0.0.0/8 come indirizzo del mittente''. Pu&ograve; sembrare stupido, ma questo vi
potrebbe evitare un sacco di problemi. Cosa succederebbe ad esempio se riceveste dei
pacchetti provenienti da 127.0.0.1? Con queste regole verrebbero immediatamente scartati,
ma senza (e con l'rp_filter disabilitato, vedi prossima sezione) &egrave; difficile valutare
cosa succederebbe (soprattutto su sistemi non linux -- 127.0.0.1 &egrave; un indirizzo di loopback).</LI>
<LI><B>un computer collegato ad una lan &egrave; in grado di vedere tutto il traffico in transito dalla
rete</B> -- se <I>foo</I> &egrave; collegato allo stesso switch
di <I>bar</I>, <I>foo</I> sar&agrave; in grado di vedere (sniffare, da ``fare sniffing'') tutto il 
traffico generato o ricevuto da <I>bar</I>, a partire
dalle email fino ad arrivare alle password per accedere ai siti ftp preferiti.
E' credenza comune che gli switch siano pi&ugrave; sicuri degli hub e che non consentano
questo tipo di operazioni. Si tratta per&ograve; di un'assunzione il pi&ugrave; delle
volte errata. Per maggiori informazioni vi consiglio di dare un'occhiata alla sezione dedicata
agli switch.</LI>
<LI><B>&egrave; possibile fare hijacking e spoofing</B> -- 
spoofing consiste nel fingersi qualcun altro. In una rete locale, &egrave; possibile
fare spoofing molto facilmente, per esempio con quello che viene definito ``arp spoofing''.
Anche volendo utilizzare tecniche di spoofing pi&ugrave; ``classiche'' basate sul protocollo tcp e ip
non esistono molti problemi: su una rete locale, potendo vedere i pacchetti, non c'&Egrave;
bisogno di indovinare alcun parametro, e non &egrave; quindi necessario utilizzare tecniche 
di ``blind spoofing'', notoriamente pi&ugrave; complesse.
L'hijacking consiste invece nel ``dirottare'' le connessioni di qualcun 
altro, dopo che sono state stabilite. L'utilit&agrave; dell'hijacking si dimostra 
ad esempio con protocolli non cifrati dove l'autenticazione viene effettuata 
in modo sicuro. Facendo sniffing non sarebbe possibile rubare la password, mentre utilizzando 
l'hijacking si potrebbe rubare la connessione dopo che l'amministratore (o il nostro bersaglio)
ha effettuato il login con successo, evitando il problema di aver bisogno di una password.</LI>
<LI><B>il protocollo udp &egrave; insicuro</B> -- se il tcp fa uso di syn e ack
per verificare e rendere le connessioni pi&ugrave; sicure e affidabili, l'udp 
non fa uso di nessuno di questi sistemi. E' quindi estremamente facile falsificare
delle trasmissioni udp, anche al di fuori di una lan. 

</LI>
<LI><B>il dns non &egrave; sicuro</B> -- Il protocollo dns fa uso del protocollo udp. E' 
quindi difficile considerarlo un protocollo sicuro (nonostante qualche precauzione 
venga presa), soprattutto in una lan, dove &egrave; estremamente facile falsificare dei 
pacchetti. In pi&ugrave; spesso si parte dall'assunzione che se la comunicazione 
tra client e dns &egrave; sicura allora i dati forniti dal dns sono corretti. Anche in
questo caso esistono delle tecniche (usate per lo pi&ugrave; in passato o con software
dns di pessima qualit&agrave; - compresi quelli inclusi in alcuni sistemi operativi) che 
consentono di inserire nel dns informazioni false (cache poisoning). Infine, l'amministratore
del vostro dns (o qualcuno in grado di gestire il dns da voi utilizzato), pu&ograve; 
modificare quasi a piacimento le associazioni tra nomi di dominio ed indirizzi ip forniti
da tale dns. Non si dovrebbe quindi mai fare affidamento sull'autenticit&agrave; e 
correttezza delle informazioni fornite da un dns.</LI>
<LI><B>tutti i dati, se non cifrati, possono essere intercettati e letti da 
chiunque si trovi tra il mittente e il destinatario</B></LI>
<LI><B>se un protocollo &egrave; cifrato, non &egrave; detto che sia sicuro</B> -- un problema
di internet e delle reti in generale non &egrave; soltanto il fatto che i dati 
possono essere facilmente intercettati. Anche ipotizzando che tutte le connessioni 
fossero cifrate, si creerebbe un problema di <I>autenticazione</I>. Per fare un esempio, se A deve 
mandare dei dati a B in maniera sicura, pu&ograve; creare un canale 
cifrato da A a B. Ma come fa A ad essere veramente sicura dell'identit&agrave; di B?
Se io fossi C, interessato ai dati trasmessi, potrei fingermi B (con
tecniche di spoofing o simili). In questo caso, la connessione tra A e B sarebbe
ancora cifrata, ma i dati arriverebbero in realt&agrave; a C. Il problema, in questo
caso, &egrave; l'autenticazione del server. Esistono diverse soluzioni
per questo problema. Con ssh, &egrave; consigliabile utilizzare sempre crittografia asimmetrica
(le famose chiavi di ssh) anzich&eacute; digitare le password e verificare sempre
il ``fingerprint'', un numero che rappresenta la chiave del computer remoto e mostrato
ad ogni connessione.
<P> 
Con protocolli come l'http, l'ftp, o la posta elettronica (sia pop che imap e smtp),
&egrave; possibile fare uso di ``certificati'' emessi da particolari autorit&agrave;
(autorit&agrave; che si fanno garanti della identit&agrave; dell'utilizzatore del
certificato) che provino l'identit&agrave; del server.</P>
<P>In Italia purtroppo, per risparmiare qualche euro, si &egrave; instaurata la pratica
di generare da s&eacute; i propri certificati senza utilizzare quelli emessi da
particolari autorit&agrave; anche in strutture che per dimensioni, per necessit&agrave;,
e per competenze tecniche dovrebbero per lo meno porsi qualche problema (parlo di 
universit&agrave;, enti pubblici, e di alcune strutture che costituiscono lo scheletro
di internet in Italia). Vorrei pertanto approfittare di questo documento per evidenziare 
che se un certificato non &egrave; emesso da una autorit&agrave; riconosciuta o da 
un'autorit&agrave; terza di cui avete ottenuto i certificati in maniera sicura 
(<B>non</B> scaricandoli da internet), la validit&agrave; del certificato stesso dovrebbe 
essere considerata <B>nulla</B>. Non ignorate quindi la finestrella di IE o Mozilla
che vi si presenta davanti dicendo che il certificato del sito non &egrave; valido:
chiunque potrebbe aver generato tale certificato
(man 1 openssl) ed essersi messo in mezzo tra voi ed il vostro sito. Non siate
tolleranti e mandate email all'amministratore di tale rete finch&eacute; non avr&agrave; 
acquistato un valido certificato!</P>
<P>Protocolli di autenticazione come kerberos invece, partono dal principio che non
&egrave; solo l'utente a dover provare la sua identit&agrave; ma anche il server remoto. 
In questo caso, se il server non &egrave; chi dichiara di essere non sar&agrave; in 
grado di decifrare i dati dell'utente stesso.</P>
</LI>
<LI><B>un firewall non &egrave; in grado di garantirvi la sicurezza</B> -- 
se sulla vostra rete usate sistemi operativi notoriamente insicuri,
potreste trovarvi facilmente dei troiani (virus particolari)
installati che consentono a terzi di controllare i vostri computer
da remoto, senza che il vostro firewall possa farci nulla. Una politica
di sicurezza deve quindi comprendere molto pi&ugrave; di un singolo firewall.</LI>
<LI><B>un sistema non &egrave; sicuro solo se non possono rubarvi dati</B> --
per esempio, potreste trovarvi nelle condizioni
di avere un servizio critico per la vostra azienda offerto da una macchina
estremamente sicura. Cosa succederebbe per&ograve; se un attaccante riuscisse
a sovraccaricarla di lavoro fino a bloccarla, pur senza riuscire 
ad entrarvici? Vi posso garantire che il vostro boss non sarebbe affatto felice...
In alcuni ambiti poi, un'interruzione di servizio potrebbe portare molti pi&ugrave;
danni di quanti potrebbe causarne un'intrusione.</LI>
<LI><B>esiste sempre qualcuno pi&ugrave; bravo, pi&ugrave; competente o pi&ugrave; 
furbo di voi</B> -- per
quante difese possiate approntare, esister&agrave; sempre quel bug di cui
non siete a conoscenza o quella persona in grado di ``bucare'' il vostro
sistema. Se avrete usato per bene le carte a vostra disposizione, sar&agrave; per lui una dura
partita ed il pi&ugrave; delle volte moller&agrave; prima di raggiungere
l'obiettivo. Sarete inoltre in grado di rendervi conto di quello
che sta succedendo e dei problemi che si sono venuti a creare.</LI>
<LI><B>non fidatevi</B> -- sebbene possa sembrare un'osservazione faziosa 
e quasi paranoica, ricordatevi che avere il codice sorgente dei programmi
che state utilizzando vi mette <I>direttamente</I> nelle condizioni di poter
verificare l'assenza di backdoor (porte sul retro, accessi lasciati dai programmatori)
o l'assenza di bug ed errori che potrebbero compromettere la sicurezza della vostra rete.
<P>Mettere a disposizione il codice sorgente di un determinato prodotto pu&ograve;
quindi essere considerato come un atto di fiducia nei vostri confronti
e costituire garanzia del buon operato dei programmatori coinvolti, che
dimostrano di non aver nulla da nascondere n&eacute; a voi ``clienti'' n&eacute; 
ad eventuali attaccanti. 
Una cassaforte non dovrebbe essere considerata sicura perch&egrave; il suo 
meccanismo &egrave; tenuto segreto (un meccanismo si pu&ograve; sempre studiare), 
ma perch&egrave; pur rendendone pubblico il funzionamento <I>nessuno &egrave; in
grado di aprirla</I> se non utilizzando la combinazione impostata. </P>
<P>Quando comprate un apparecchio come uno switch, un router o un firewall, provate a cercare
sul sito del produttore le procedure indicate per il recupero delle password 
dimenticate: alcune volte vi verr&agrave; detto di rendere l'apparecchiatura
raggiungibile tramite internet e di contattare il servizio di assistenza (non 
&egrave; uno scherzo). Questo
dovrebbe dirla lunga sull'assenza di backdoor e sulla sicurezza del prodotto.</P>
<P>Infine, se la vostra preoccupazione maggiore &egrave; la sicurezza, ricordatevi
che spesso questo non &egrave; l'interesse maggiore di chi 
vi vende un prodotto (e non sta a me ricordarvi che viviamo in un mondo dove 
l'economia &egrave; basata sul marketing e sulla massimizzazione dei guadagni). 
Non accontentatevi di belle parole o pubblicit&agrave;
accattivanti: se vi verr&agrave; rilasciato il codice sorgente sarete in grado
di verificare in prima persona la qualit&agrave; del prodotto.</P>

</LI>
</UL>

Se pu&ograve; tranquillizzarvi, in questo momento non mi viene pi&ugrave; in mente
nulla da aggiungere. Spero che questa notte riusciate a dormire sonni senza incubi...</P>
<P>Le solite raccomandazioni, ormai, credo che siano superflue: non scambiate mail con
password (&egrave; molto pi&ugrave; facile falsificare una mail che non intercettare
una comunicazione), scegliete password che non siano contenute in un dizionario e che
contengano caratteri maiuscoli e minuscoli, cifre e simboli, utilizzate tecnologie
di firma digitale e verificate l'identit&agrave; delle persone che vi richiedono
informazioni sensibili, magari richiamandole per telefono o utilizzando qualche
sorta di Web Of Trust.</P>

<H2><A NAME="ss6.2">6.2</A> <A HREF="#toc6.2">Sicurezza degli switch</A>
</H2>

<P>Alcuni paragrafi fa avevo parlato di switch e della loro sicurezza. La differenza
principale tra uno switch ed un hub, &egrave; che gli hub rimandano tutti i dati ricevuti
a tutti i computer collegati all'hub stesso, mentre gli switch si limitano ad inviare
i dati ricevuti ai soli computer coinvolti in una trasmissione. Teoricamente, quindi,
utilizzando uno switch non sarebbe possibile in una rete effettuare lo ``sniffing'' dei
dati trasmessi nelle connessioni tra altri computer.</P>
<P>In pratica per&ograve;, gli switch sono in grado di isolare le connessioni mantenendo
in memoria una sorta di tabella che associa ad ogni cavo un computer. Per cui, quando
due computer devono comunicare, lo switch consulta questa tabella ed in base a questa
sceglie su quali cavi dovr&agrave; trasmettere il traffico.</P>
<P>Questo modello presenta diversi problemi:
<UL>
<LI>Prima di tutto, questa tabella viene creata in base al traffico che inizialmente
viene visto transitare. Per cui, generando traffico fasullo, &egrave; possibile
imbrogliare lo switch facendogli credere che un altro computer &egrave; collegato
al cavo cui si &egrave; in realt&agrave; collegati (e se su due cavi risulta uno
stesso computer, lo switch, normalmente, riinvier&agrave; i dati trasmessi su
entrambi i cavi).</LI>
<LI>In secondo luogo, gli switch sono collegabili in cascata. Questo comporta che nella
tabella nella memoria dello switch ad ogni cavo possa essere associato pi&ugrave;
di un computer. La memoria di uno switch, per&ograve;, ha dimensione limitata e la
maggior parte degli switch si comporter&agrave; esattamente come un hub nel caso
esaurisse la memoria e non fosse pi&ugrave; in grado di mantenere tale tabella.
<P>Questo principalmente per evitare malfunzionamenti in reti di grosse dimensione.  </P>
</LI>
<LI>In terzo luogo, &egrave; possibile collegare pi&ugrave; switch tra di loro utilizzando 
collegamenti multipli. Per esempio, una 
rete di medie dimensioni potrebbe utilizzare qualcosa come 20/30 switch, tutti
collegati tra di loro. Se fossero tutti collegati in cascata, il guasto di
uno switch comporterebbe il malfunzionamento di buona parte della rete (probabilmente, 
dividerebbe la rete in due parti).
<P>Normalmente quindi, si stabiliscono pi&ugrave; connessioni tra gli stessi 
switch (stendendo pi&ugrave; cavi) in modo che il guasto di un solo apparecchio
comprometta la funzionalit&agrave; dei soli computer connessi a tale apparecchio.</P>
<P>Per consentire l'utilizzo di percorsi multipli, gli switch devono costruirsi una
sorta di ``mappa'' della rete in modo da sapere che percorso far fare ai vari pacchettini
per evitare che si vengano a creare dei loop (pacchetti che continuano a rimbalzare
da uno switch ad un altro senza mai arrivare a destinazione). Per costruire questa
mappa, gli switch devono comunicare tra di loro con un protocollo chiamato spanning
tree protocol (IEEE 802.1d, scambiandosi quelli che vengono detti BPDU). In questo caso, 
quindi, un computer collegato allo switch potrebbe falsificare
i dati del protocollo spanning tree in modo da far credere di essere a sua volta
uno switch e di costituire il percorso pi&ugrave; breve per raggiungere determinati
computer, in modo da intercettare il traffico di tali computer.</P>
</LI>
<LI>Infine, gli switch possono essere solitamente configurati tramite 
interfacce web o telnet, che non fanno uso di alcun protocollo crittografico
o di particolari protezioni, se non un username ed una password.
<P>Allo stesso modo vengono spesso utilizzati protocolli come l'snmp (``Simple
Network Management Protocol'' - le prime versioni del protocollo, definito dall'RFC1157), 
che non richiedono nemmeno una password, se non un semplice nome di comunit&agrave;.</P>

</LI>
</UL>

Se la sicurezza della vostra rete dipende molto dalla sicurezza dei vostri switch,
potreste considerare l'utilizzo di:
<UL>
<LI>VLAN (IEEE 802.1q) -- questa tecnologia vi consente di assegnare un numero ad ogni porta di
uno switch. Una volta fatto questo, solo le porte con lo stesso numero potranno
comunicare tra di loro. In pi&ugrave;, i collegamenti tra uno switch ed un altro
passeranno per quelli che alcuni produttori chiamano ``trunk'', ovvero dei collegamenti
dove tutti i dati, indipendentemente dal numero di VLAN, possono essere trasmessi.
Attenzione per&ograve;, che alcuni switch supportano una modalit&agrave; di apprendimento,
dove ad una porta &egrave; assegnata una particolare VLAN in base alle caratteristiche
dei pacchetti trasmessi. Un utente malizioso, con questa funzionalit&agrave; abilitata,
potrebbe fingersi un altro switch e farsi inviare tutti i pacchetti delle VLAN che gli
interessano. Inoltre, linux supporta il VLAN tagging (802.1Q), ovvero &egrave; in grado 
di creare delle interfacce virtuali su diverse VLAN, senza bisogno di hardware aggiuntivo.
<P>Un altro vantaggio delle VLAN consiste nel fatto che alcuni switch possono essere configurati
in modo che esista una VLAN amministrativa: in questo caso, le configurazioni potranno essere
cambiate e visualizzate soltanto da computer connessi ad una di queste VLAN.</P>
</LI>
<LI>Alcuni switch supportano delle funzionalit&agrave; di sicurezza relative alle porte ethernet.
Per esempio, alcuni switch possono essere configurati in modo che se su una determinata porta 
viene visto un indirizzo ip o un mac address (o una coppia dei due) diversi da quelli impostati, la porta
viene spenta. In pi&ugrave;, possono essere normalmente indicate delle associazioni statiche
tra porte ed indirizzi ip o mac address, senza che per questo venga bloccata la porta.</LI>
<LI>A volte, lo spanning tree protocol pu&ograve; essere semplicemente disabilitato o perch&egrave;
l'hardware utilizzato consente di impostare dei percorsi alternativi manualmente, o perch&egrave;
non &egrave; necessario per la topologia della rete. In altre situazioni, alcuni switch supportano 
restrizioni (normalmente basate su VLAN) sull'invio e sulla ricezione di questi pacchetti.</LI>
</UL>

Ricordatevi infine che un router od uno switch potrebbero costituire un obiettivo molto pi&ugrave; 
succulento di quanto possiate pensare: controllando un router, infatti, si potrebbe creare un tunnel 
tra la vostra rete ed una rete bersaglio, piuttosto che impostare delle regole per deviare o fare delle 
modifiche al traffico.</P>

<H2><A NAME="s7">7.</A> <A HREF="#toc7">Preparare il kernel ad andare in rete -- overview di /proc </A></H2>

<P>Adesso che siamo consapevoli di quello che ci pu&ograve; accadere e di quali
siano i nostri obiettivi, iniziamo dando un'occhiata alla directory
/proc/sys/net. In questa directory ci sono dei file e delle 
directory che ci consentono di modificare il comportamento della nostra 
macchina in rete, che ci consentono cio&egrave; di modificare molti
dei parametri usati dal kernel per prendere le decisioni sui pacchetti
che riceve o che deve trasmettere. </P>
<P>In pratica, ad ogni file contenuto in questa directory corrisponde una variabile,
il cui valore regola il funzionamento di una determinata parte del kernel.</P>
<P>Le directory, invece, sono utilizzate semplicemente per raggruppare i file
e per renderne pi&ugrave; facile l'utilizzo.</P>

<H2><A NAME="ss7.1">7.1</A> <A HREF="#toc7.1">Utilizzo dei file in /proc</A>
</H2>

<P>Per conoscere il valore delle variabili impostate in tali file, &egrave; sufficiente 
leggere il contenuto del file stesso, utilizzando, per esempio, un ``cat nomefile''.</P>
<P>Per modificare tale valore, &egrave; sufficiente scrivere il nuovo valore
all'interno del file utilizzando un comando 
simile a ``echo nuovovlaore > nomefile''.</P>
<P>Per convenzione, una variabile che pu&ograve; assumere come valore 
``vero'' o ``falso'' oppure ``attivo'' o ``inattivo'' avr&agrave;
rispettivamente come valori 1 o 0.</P>
<P>Per esempio, per disabilitare l'ecn (di cui si parler&agrave; tra
poco), baster&agrave; un comando simile a:
<BLOCKQUOTE><CODE>
<PRE>
echo "0" > /proc/sys/net/ipv4/tcp_ecn
</PRE>
</CODE></BLOCKQUOTE>

Le modifiche fatte in questo modo, per&ograve;, non vengono conservate
tra un reboot e l'altro. Per renderle definitive, &egrave; quindi necessario 
inserire i relativi comandi in un file eseguito all'avvio della macchina oppure
usare il file di configurazione /etc/sysctl.conf. In questo file
dovrete scrivere la ``variabile'' seguita da un ``='' e dal valore
che volete assegnare. Il nome della variabile corrisponde al nome
del file nella directory di proc, togliendo per&ograve; ``/proc/sys''
e sostituendo dei ``.'' alle ``/''. Per esempio, per disabilitare
per sempre l'utilizzo dell'ecn, sar&agrave; sufficiente aggiungere
la riga:
<BLOCKQUOTE><CODE>
<PRE>
net.ipv4.tcp_ecn=0
</PRE>
</CODE></BLOCKQUOTE>

nel file /etc/sysctl.conf.</P>


<H2><A NAME="ss7.2">7.2</A> <A HREF="#toc7.2">Alcuni file importanti</A>
</H2>

<P>Alcune delle variabili in /proc/sys/net sono particolarmente importanti dal 
nostro punto di vista in quanto ci consentono di proteggere il kernel da diversi
tipi di attacchi.</P>
<P>Di base, la directory che pi&ugrave; ci interessa di 
/proc/sys/net &egrave; sicuramente
ipv4.</P>
<P> 
In quest directory, dovreste trovare alcuni file tra cui:
<UL>
<LI><I>icmp_echo_ignore_broadcasts</I> -- questo file vi consente
di dire al kernel se accettare o ignorare dei ``ping'' inviati
ad indirizzi di broadcast. Un ping non &egrave; altro che il 
pacchetto generato dal comando ``ping'' per vedere se un computer
&egrave; in funzione o meno. In questo caso, un valore di 0 (falso)
dice al kernel di non ignorare i ping di broadcast, mentre un valore
di 1 (vero) di ignorarli. Normalmente, &egrave; meglio impostare
questo file ad ``1''. Provate ad immaginare cosa potrebbe succedere se 
una persona qualsiasi mandasse un ping (aka icmp echo request) a 16 milioni 
di computer, utilizzando come destinazione un indirizzo di broadcast
e come mittente l'indirizzo ip del vostro computer.
<P>Con una cinquantina di byte, vi manderebbe contro circa 16 milioni 
di risposte al ping... (fortunatamente, la maggior parte dei computer
in rete non rispondono a ping di broadcast).</P>
<P>Questa variabile viene principalmente utilizzata all'interno di
net/ipv4/icmp.c:icmp_rcv.</P>
</LI>
<LI><I>icmp_ignore_bogus_error_responses</I> -- disabilita o abilita 
il logging di risposte errate mandate da alcune apparecchiature di rete.
Utile soltanto per evitare di riempire i vostri log. Fa riferimento
principalmente all'RFC1122 e alla funzione icmp_unreach chiamata da icmp_rcv
in net/ipv4/icmp.c.</LI>
<LI><I>ip_forward</I> -- questo file, invece, vi consente di abilitare
o disabilitare il ``forwarding''. Il forwarding consiste
nel consentire a linux di ``copiare'' i dati ricevuti da un'interfaccia
di rete ad un'altra. Senza il forwarding abilitato, non potremmo
utilizzare linux come firewall ed i pacchettini non potrebbero passare
da un'interfaccia all'altra. </LI>
<LI><I>ipfrag_*</I> -- sebbene i default siano normalmente pi&ugrave;
che validi, &egrave; bene spendere due parole sui terribili frammenti.
Alcune reti, a livello hardware, non riescono a trasmettere pi&ugrave;
di un numero di byte limitato per volta. Una rete ethernet per esempio,
non consente di trasmettere pi&ugrave; di 1500 (circa) bytes
per volta (questo limite viene anche detto MTU, ovvero Max Transfer Unit). 
Esiste per questo un sistema per spezzettare i pacchetti
ed inviarli come tante unit&agrave; indipendenti. Questi vengono normalmente
chiamati frammenti e possono creare diversi problemi:
<UL>
<LI>Per esempio, inviando frammenti sufficientemente piccoli la
parte iniziale del pacchetto che contiene le informazioni sul
protocollo tcp o udp viene suddivisa su pi&ugrave; pacchetti. 
Queste informazioni per&ograve;, vengono utilizzate proprio dai
firewall per capire la destinazione e lo scopo del pacchetto.
In passato, alcuni firewall facevano semplicemente
passare questi frammenti, altri si inceppavano, mentre 
altri ancora li buttavano via. L'approccio utilizzato attualmente
da linux &egrave; quello di assemblare lui direttamente come firewall 
tutti i frammenti. In pratica, linux decider&agrave; se far passare o
meno un pacchetto solo dopo averlo completamente riassemblato.
Questo protegger&agrave; i nostri server anche da altri tipi di attacco.</LI>
<LI>Al contrario, dividendo il pacchetto in frammenti sufficientemente 
grossi, l'header tcp/udp viene inserito solo nel primo frammento. 
Cos&igrave;, se arrivano prima frammenti successivi al primo, il 
firewall deve decidere se
far passare o meno il pacchetto senza avere tutte le informazioni
necessarie a disposizione. Anche in questo caso, far assemblare
i pacchetti al firewall pu&ograve; essere una buona soluzione.</LI>
<LI>Un altro esempio &egrave; quello di alcuni attacchi che prendevano
dei grossi pacchetti, li spezzettavano in frammenti molto
piccoli e li mandavono poi ad una macchina bersaglio in un ordine 
completamente casuale. 
<P>Questa macchina si doveva quindi prodigare per ricomporre
il puzzle riordinando e riunendo i pacchetti nel corretto ordine,
sovraccaricando notevolmente la cpu arrivando persino a bloccare
la macchina.</P>
<P>Per rimediare, in linux si utilizzano proprio i file ipfrag_*. In 
pratica, si stabiliscono dei limiti oltrepassati i quali linux si 
``arrender&agrave;'' nel tentare di riordinare i pacchetti, evitando
di bloccarsi su questo compito. I valori di default di tali limiti
sono ben tarati, anche se
potrebbe rendersi necessario abbassarli, a seconda della tipologia di macchina
utilizzata e a secondo dell'attacco cui si &egrave; soggetti.</P>
<P>Capita raramente poi, che per migliorare le prestazioni di alcuni
servizi, come per esempio NFS, tali limiti debbano essere alzati.</P>
</LI>
<LI>Alcuni vecchi attacchi attualmente praticamente
inoffensivi erano basati sul produrre frammenti che si sovrapponessero (``overlapping
fragments'') in modo da portare i 
sistemi operativi a sbagliare il calcolo della memoria da utilizzare, bloccando
il sistema (CERT CA-1997-28).</LI>
</UL>

Il significato dei file &egrave; quello classico di tutti i meccanismi
basati su un limite (threshold). Quando la memoria utilizzata per riassemblare
i frammenti supera ipfrag_high_thresh questi vengono bloccati fintanto che il valore non
torna sotto ipfrag_low_thresh. ipfrag_time indica per quanto tempo al
massimo un frammento pu&ograve; essere mantenuto in memoria. 
<P>Questi limiti sono utilizzati principalmente in net/ipv4/ip_fragment.c:ip_defrag ed
ip_evictor.</P>
</LI>
<LI><I>tcp_ecn</I> -- questo file regola l'utilizzo dell'ecn, ovvero ``Explicit
Congestion Notification protocol''. Non che sia un rischio per la sicurezza,
ma spesso firewall vecchi non conformi agli standard (RFC3168) tagliano via tutte
le connessioni che utilizzano questo protocollo. Se da linux non riuscite
a collegarvi a dei siti che invece non avete problemi a raggiungere con
altri sistemi operativi, probabilmente dovete disabilitare l'ecn. Sicuramente
quindi, almeno finch&eacute; le cose non saranno cambiate, vi conviene
tenerlo sempre disabilitato.</LI>
<LI><I>tcp_max_syn_backlog e tcp_syncookies</I> -- un altro tipo di attacco,
abbastanza pericoloso e abbastanza in voga di questi tempi viene detto
syn flood, ovvero inondazione di syn (CERT CA-1996-21). Il giochetto 
anche in questo caso &egrave; molto semplice: viene inviato il pacchetto 
tcp per iniziare
una connessione ma non ne viene mai confermata l'apertura, costringendo
il sistema operativo a ricordarsi di questa connessione in attesa che
una conferma venga inviata.
<P>Facendo un paio di grossolani conti, considerando che esistono 65535 porte
e che per ogni porta devono poter essere accettate pi&ugrave; connessioni,
&egrave; abbastanza evidente che il kernel di un qualsiasi sistema operativo
non pu&ograve; permettersi di ricordarsi tutti i pacchetti di inizio delle
connessioni ricevuti. In pratica, per ogni porta viene creata una coda di 
dimensioni molto piccole (si parla di numeri nell'ordine delle decine o 
centinaia). 
Quando questa coda &egrave; piena, la porta non pu&ograve; pi&ugrave; accettare
pacchetti. A peggiorare la situazione, le rfc indicano un timeout abbastanza 
alto (nell'ordine dei minuti) prima che il kernel possa buttare via questi 
pacchetti, svuotando la coda e dedicandosi ad altro. E' quindi abbastanza facile
dimostrare che
un attaccante, mandando pochi kilobyte di syn al secondo con un semplice modem 
56k, pu&ograve; rendere inutilizzabile una porta di un qualsiasi server, senza 
nemmeno alzare il carico della cpu n&eacute; saturare la banda.</P>
<P>Le soluzioni sono diverse, ma poche si sono rivelate veramente valide:
<UL>
<LI>alcuni firewall limitano il numero massimo di syn al secondo inviati
ad ogni server protetto, facendo in modo che quando questo limite
viene sorpassato vengano fatti passare ``equamente'' (e ci sono diverse discussioni
su cosa si debba intendere per ``equamente'') syn inviati da mittenti
diversi.  Il problema &egrave; che essendo
sufficiente un basso numero di syn al secondo per bloccare
un server, &egrave; difficile riconoscere un attacco da un comportamento
``legale''. Esistono diversi algoritmi per gestire queste situazioni, e 
su internet sono disponibili i benchmark sull'efficacia di questo tipo
di protezione, divisi per firewall e per rivenditore (cercate con google!).
Non si tratta comunque della soluzione migliore ed &egrave; stato mostrato
che con attacchi di particolari dimensioni si tratta di una difesa molto
poco efficace che pu&ograve; tagliare facilmente del traffico che invece
dovrebbe essere consentito.  </LI>
<LI>un approccio pi&ugrave; efficace adottato da altri firewall si &egrave; 
rivelato quello di far gestire le connessioni dal firewall stesso.
In pratica, quando il firewall riceve un syn, questo ``si finge'' il server 
fino al ricevimento dell'ack di conferma della connessione. A questo punto,
stabilisce una connessione ``vera'' con il server fingendosi il client
dopodich&eacute; fa continuare la connessione come se il client ed il server
si parlassero direttamente.
<P>In questo modo, un syn flood andrebbe a colpire solo il firewall proteggendo
molto efficacemente i server.</P>
<P>Firewall di questo tipo sono poi strutturati in modo da resistere 
molto bene a dei syn flood anche con un numero molto alto di syn al
secondo, utilizzando tabelle pi&ugrave; grosse di quanto si possa permettere 
un normale server e creando delle infrastrutture dinamiche in grado di gestire
tali situazioni.</P>
</LI>
<LI>molto originale invece &egrave; l'approccio utilizzato da linux e da
molti altri sistemi. Il sistema viene chiamato syn cookie, ``biscottini
nel syn''. Tornando a parlare di three way handshake e tcp, quando un 
syn viene ricevuto (e per syn si intende un pacchetto che contenga il
numero iniziale di sequenza, o numero di sincronia, e il cui syn flag
sia settato), il sistema che lo riceve deve rispondere a sua volta 
inviando un syn con un ack. Questo secondo syn &egrave; normalmente un numero casuale difficile
da indovinare ed &egrave; proprio dopo aver inviato quest'ultimo che il sistema deve
rimanere in attesa del famoso ack.
Il sistema utilizzato dai syn cookies
consiste nel prendere un numero non casuale da inviare  
che contenga quelle informazioni (o parte di quelle 
informazioni) che verrebbero memorizzate nella famosa coda (se ci 
fosse spazio a disposizione...). 
In pratica, una volta che la coda &egrave; piena, le informazioni
che dovrebbero essere memorizzate vengono inviate nel syn ack di
risposta. Se l'handshake viene completato correttamente dal client
inviando l'ack finale (il terzo passo dell'handshake), le informazioni
vengono estratte dal pacchetto ricevuto (l'ack di risposta viene
sempre calcolato a partire dal syn, ed &egrave; quindi possibile
partendo da un ack ricalcolare il syn originale), non risentendo
quindi del problema.
<P>Il syn per&ograve;, deve continuare ad essere difficilmente indovinabile 
ed aumentare di pacchetto in pacchetto (non avrebbe ragione di esistere
altrimenti, e sono condizioni imposte dall'rfc 793). Vengono quindi normalmente utilizzate
delle funzioni one-way o degli hash che rispecchino queste
caratteristiche, e l'informazione inviata si riduce normalmente
in un ``connessione inizializzata correttamente'' (per maggiori informazioni,
potete vedere il file net/ipv4/tcp_ipv4.c, in particolare
la funzione tcp_v4_conn_request, oppure il 
file drivers/char/random.c funzione secure_tcp_syn_cookie per
sapere come un syn cookie viene calcolato).
Il problema &egrave; che 
&egrave; stato dimostrato che in particolari condizioni con particolari
versioni del kernel linux era possibile indovinare questi syn e 
fare spoofing delle connessioni tcp. Sebbene attacchi di questo tipo
siano stati raramente (se mai) utilizzati (non mi riferisco allo spoofing 
in generale, pratica largamente utilizzata, ma all'indovinare i syn grazie
a questo bug nella creazione dei syn cookies), &egrave; bene abilitare i syn 
cookies solo su kernel relativamente recenti (dal 2.4.6 in su funzionano
sicuramente correttamente), o in particolari condizioni
(quando si &egrave; sotto attacco, per esempio).</P>
<P>Ultima cosa da dire a proposito dei syn cookies &egrave; che questi vengono
considerati da alcuni violare lo standard del tcp (ci sono state diverse discussioni 
in proposito, si veda per esempio il sito http://cr.yp.to/syncookies.html, di Dan Bernstein) e 
possono quindi introdurre dei problemi. I syn cookies, se abilitati,
verranno quindi utilizzati da linux soltanto nel caso in cui la famosa coda si
riempia.</P>
</LI>
</UL>

Tornando a parlare dei file in /proc, tcp_max_syn_backlog consente di specificare
il numero massimo di connessioni che possono rimanere in coda per ogni porta (normalmente &egrave;
impostato a 128 su sistemi con meno di 32 mega di ram e a 1024 su tutti gli altri
sistemi - net/ipv4/tcp.c:tcp_listen_start, net/ipv4/tcp-ipv4.c:tcp_v4_conn_request e tcp_synq_is_full)
mentre tcp_syncookies consente di abilitare o disabilitare i syn cookies. </P>
<P>Rimane soltanto da aggiungere una cosa: come si fa a rendersi conto di essere sotto
syn flood? Beh, con i syn cookies disabilitati, potreste dare un comando come:
<BLOCKQUOTE><CODE>
<PRE>
          # netstat -npla |grep SYN_RECV
        
</PRE>
</CODE></BLOCKQUOTE>

Normalmente, dovreste vedere non pi&ugrave; di 1-2 connessioni provenienti da
indirizzi ip diversi. Se ne vedete pi&ugrave; di una trentina, allora &egrave; molto
probabile che vi troviate sotto syn flood. Per esperienza, posso dirvi che con
un kernel 2.2 senza i syn cookies abilitati con circa 110-120 connessioni in 
SYN_RECV la porta attaccata diventava irraggiungibile.</P>
<P>Per avere una ulteriore conferma, potreste infine verificare con tcpdump...
se arrivano dei nuovi syn da uno stesso ip prima ancora che voi abbiate risposto 
con un altro syn-ack o dopo aver temporaneamente bloccato l'ip o il demone
responsabile della porta, allora siete sotto syn-flood. Anche questa prova per&ograve;
non pu&ograve; essere considerata definitiva: il syn-flood viene considerato un blind
attack, ovvero un attacco che non ha bisogno di ricevere le risposte per poter essere
effettuato, per cui &egrave; estremamente semplice utilizzare dei ``mittenti'' 
falsificati nei pacchetti (ed utilizzare quindi ip multipli e differenti). L'ip che vedete in 
netstat o tcpdump potrebbe quindi essere quello di qualcuno che 
nulla ha a che vedere con l'attacco. L'unica condizione perch&egrave; un ip possa essere utilizzato &egrave; infatti che
questo risulti irraggiungibile dalla vostra macchina (altrimenti manderebbe un reset
dopo il vostro syn-ack). Infine, nel caso in cui il kernel si trovi a dover far uso
dei syn cookies, dovreste vedere dei messaggi nei file di log.</P>
</LI>
<LI><I>directory conf</I> ok, qua dentro trovate i parametri per le singole interfacce
di rete. A parte ``all'' e ``default'', che consentono rispettivamente di cambiare i
parametri di tutte le interfacce o i default per le future
interfacce, ogni sottodirectory contiene i parametri di una singola interfaccia di 
rete.
<P>Diamo quindi un'occhiata alla directory all (o eth0, o lo, o...):
<UL>
<LI><I>accept_redirects</I> fa in modo che vengano accettati redirect dalla particolare
interfaccia. Un redirect consiste ``in un suggerimento'' per un percorso ``migliore''
per raggiungere un determinato punto (RFC792, pagina 12). Il problema &egrave; che &egrave; facile
dare questi ``suggerimenti'' deviando il traffico a proprio piacimento (o comunque
in modo da poter fare cose poco piacevoli). Un tempo i redirect erano molto pericolosi,
adesso vengono accettati solo se determinate condizioni vengono verificate. Per un firewall,
&egrave; comunque bene disabilitare questi redirects, o se necessario affidarsi
a demoni come zebra o bird  e a protocolli pi&ugrave; evoluti per aggiornare dinamicamente 
le tabelle di routing.</LI>
<LI><I>secure_redirects e send_redirects</I> consentono rispettivamente di accettare
i redirect che rispettino condizioni molto pi&ugrave; stringenti di quelle
normali e di generare i redirect per gli altri host. In pratica, viene verificato
che il redirect venga inviato da un gateway di default conosciuto 
(net/ipv4/fib_semantics.c:ip_fib_check_default chiamato da route.c:ip_rt_redirect).</LI>
<LI><I>accept_source_route</I> fa in modo che vengano accettati ``source route'', ovvero
pacchetti che chiedono che la risposta passi da determinati routers. Sebbene questo
non sia un problema in se stesso, &egrave; meglio disabilitare questa opzione 
per rendere la vita pi&ugrave; difficile a coloro che tentino la strada dello spoofing. Uno
dei problemi principali dello spoofing &egrave; infatti quello di mettersi
in grado di poter ricevere le risposte dei pacchetti falsificati, ed il 
source_route facilita notevolmente il raggiungimento di questo obiettivo. 
La maggior parte dei provider, infatti, bloccano pacchetti che utilizzano questa
opzione del protocollo ip.</LI>
<LI><I>forwarding e mc_forwarding</I> abilitano o disabilitano rispettivamente il 
forwarding ed il forwarding dei pacchetti di multicast per la singola interfaccia
(lo stesso forwarding di cui parlavamo prima). Attenzione per&ograve; che il
forwarding dei pacchetti di multicast ha bisogno di un demone di supporto.</LI>
<LI><I>rp_filter</I> abilita o disabilita il ``reversed path filter''. Con questo filtro
abilitato, viene verificata la coerenza dell'indirizzo ip del mittente di un pacchetto 
rispetto l'interfaccia su cui tale pacchetto &egrave; stato ricevuto e le informazioni
contenute nelle tabelle di routing. In caso le informazioni non risultino coerenti,
il pacchetto viene scartato. Quest'opzione pu&ograve; creare problemi con tabelle di 
routing particolarmente complesse (utilizzando ip rule, per esempio, e tabelle di routing
multiple) o quando si fa uso di link asimmetrici, ovvero dove le richieste escono
da un'interfaccia mentre le risposte ritornano su un'altra (con collegamenti satellitari,
per esempio, dove le richieste escono dal telefono e le risposte arrivano sulla
parabolica). Utilizzato principalmente in sys/net/ipv4/fib_frontend.c:fib_validate_source.</LI>
<LI><I>log_martians</I> fa in modo che pacchetti strani, improbabili o impossibili 
vengano registrati nei file di log. Il problema 
&egrave; che a volte, magari con particolari configurazioni, un po' troppi pacchetti
vengono loggati.</LI>
</UL>
</P>
</LI>
</UL>
</P>

<H2><A NAME="s8">8.</A> <A HREF="#toc8">Filtrare il traffico con iptables</A></H2>

<P>Di base, tutte le distribuzioni mettono a disposizione dei tool per configurare
la rete. Se avete molta fiducia nella vostra distribuzione o gli script sono 
particolarmente ben fatti, potete tranquillamente usare quelli... per quanto mi
riguarda, pur avendo molta fiducia negli script forniti con debian,
preferisco escludere completamente il supporto della distribuzione 
in maniera da non avere limiti e da poter usare con tranquillit&agrave; le patch
sopra installate ed in modo da evitare interazioni non volute con script o programmi
di cui spesso non si ha il pieno controllo. Nelle prossime sezioni configureremo
un firewall ``from scratch'', aggiungendo cio&egrave; i nostri script in /etc/init.d
in modo che vengano caricati automaticamente all'accensione della vostra
macchina. </P>

<H2><A NAME="ss8.1">8.1</A> <A HREF="#toc8.1">Preambolo</A>
</H2>

<P>Ok, il nostro primo script si chiamer&agrave; conffw. Ovviamente non dovrete scrivere i 
numeri di riga, usati soltanto per rendere la trattazione pi&ugrave; semplice.</P>
<P>Iniziamo allora con:
<BLOCKQUOTE><CODE>
<PRE>
0: #!/bin/bash
1: echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts 
2: for a in /proc/sys/net/ipv4/conf/*/rp_filter; do 
3:     echo 1 &gt; $a 
4: done
5: echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies
6: echo 0 &gt; /proc/sys/net/ipv4/tcp_ecn
</PRE>
</CODE></BLOCKQUOTE>

In queste prime righe, ci limitiamo a dire al kernel di ignorare 
i ping di broadcast e di abilitare l'rp_filter su tutte le interfacce.
Infine, abilitiamo i syn cookies e disabilitiamo l'ecn (vedi sezione
precedente per una spiegazione pi&ugrave; approfondita). In
maniera perfettamente equivalente avremmo potuto scrivere 
in /etc/sysctl.conf:
<BLOCKQUOTE><CODE>
<PRE>
net.ipv4.icmp_echo_ignore_broadcasts=1
net.ipv4.conf.all.rp_filter=1
net.ipv4.conf.default.rp_filter=1
net.ipv4.tcp_syncookies=1
net.ipv4.tcp_ecn=0
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss8.2">8.2</A> <A HREF="#toc8.2">Configurare le interfacce</A>
</H2>

<P>Da adesso in poi prover&ograve; ad andare avanti configurando un ipotetico
firewall collegato ad un'ipotetica rete e spiegando man mano i vari passi. Inizier&ograve; 
quindi ora descrivendo
l'ipotetica rete che verr&agrave; utilizzata nei prossimi esempi. Nel nostro
caso, quindi, il firewall sar&agrave; equipaggiato con:
<UL>
<LI>una interfaccia eth0 collegata alla rete interna, con indirizzo 192.168.200.254
e netmask 255.255.255.0.</LI>
<LI>una interfaccia eth1 collegata alla nostra DMZ, con indirizzo 123.45.67.9 con netmask
255.255.255.248, dove per DMZ si intende la rete dove verranno attaccati tutti quei
server disponibili sia dall'interno che dall'esterno della nostra rete.</LI>
<LI>ed infine una interfaccia eth2 collegata con il mondo esterno, con indirizzo
123.45.68.1, netmask 255.255.255.0 e con gateway su 123.45.68.254.</LI>
</UL>

Ok, una volta definito il comportamento di base del firewall e 
la configurazione hardware, possiamo andare avanti configurando le varie 
schede di rete tramite il comando ``ip'':
<BLOCKQUOTE><CODE>
<PRE>
8: ip addr add 192.168.200.254/24 dev eth0
9: ip addr add 123.45.67.9/29 dev eth1
10: ip addr add 123.45.68.1/24 dev eth2
</PRE>
</CODE></BLOCKQUOTE>

Vi rimando ad altra documentazione disponibile sul mio sito per una discussione sul comando
ip. Vi basti sapere che in questo modo abbiamo configurato le schede
di rete senza attivarle come indicato sopra.</P>
<P> A questo punto, possiamo
dedicarci ad iptables e ad impostare le regole di firewalling vere e proprie.</P>
<P>E' importante non abilitare le interfacce di rete in modo da evitare che i pacchetti
inizino a fluire prima che le regole di firewalling siano state aggiunte.</P>

<H2><A NAME="ss8.3">8.3</A> <A HREF="#toc8.3">Il comando iptables </A>
</H2>

<P>Sicuramente se avete sentito parlare di linux e di firewalling,
avete anche sentito parlare di ipchains e di ipfwadm. Questi comandi
consentivano l'impostazione delle regole di firewalling rispettivamente
nei kernel 2.2 e 2.0. Nei kernel dal 2.4 in poi &egrave; stato introdotto un nuovo 
comando: iptables, anche se il supporto sia per ipchains che ipfwadm &egrave; rimasto.</P>
<P>Dovendo parlare di iptables, &egrave; indispensabile una piccola introduzione. Il parente 
pi&ugrave; stretto di iptables &egrave; sicuramente ipchains. ipchains aveva introdotto il concetto
di ``catena''. iptables ha ripreso
il concetto di catena per estenderlo tramite l'introduzione di tabelle.</P>
<P>Prima di parlare di tabelle per&ograve;, ci conviene chiarire il
concetto di catena. L'idea di base &egrave; abbastanza semplice: un computer collegato 
in rete con una o pi&ugrave; interfacce ha a che vedere con tre tipi di pacchetti:
<UL>
<LI>Pacchetti destinati al firewall stesso</LI>
<LI>Pacchetti che devono transitare dal firewall ma destinati a qualcun'altro</LI>
<LI>Pacchetti originati dal firewall stesso</LI>
</UL>

Di default ipchains ed iptables mettono quindi a disposizioni rispettivamente 3 catene:
<UL>
<LI>La catena di input</LI>
<LI>La catena di forward</LI>
<LI>La catena di output</LI>
</UL>

In un computer normale (o in un server) verrebbero principalmente utilizzate
le catene di input e di output per filtrare il traffico ricevuto e generato
dalla macchina presa in considerazione.</P>
<P>In un firewall invece, i pacchetti transiterebbero da una scheda di rete 
all'altra, passando quindi attraverso la catena di forward.</P>
<P>Ogni catena &egrave; poi costituita da un insieme di regole. Ad ogni regola, &egrave; 
associata un'azione (target). Ogni volta che un pacchetto transita per una catena, 
tutte le regole vengono controllate in ordine, dalla prima inserita fino all'ultima. 
Quando una regola risulta applicabile al pacchetto (viene trovato un match) viene applicata 
al pacchetto l'azione specificata e viene interrotto il processo di ricerca. </P>
<P>Se non viene trovata una regola applicabile al pacchetto, la sua sorte (l'azione 
d'applicare) viene scelta in base alla politica (policy) della catena stessa. In pratica,
la policy indica cosa fare di tutti i pacchetti che non rientrano in nessuna regola.</P>
<P>Sia ipchains che iptables poi, consentono di creare o rimuovere catene e di specificare
come azione quella di percorrere un'altra catena.</P>
<P>Detto cos&igrave; pu&ograve; sembrare tutto molto complesso, ma vedrete che poi nella pratica diventer&agrave; 
molto pi&ugrave; semplice.</P>


<H2><A NAME="ss8.4">8.4</A> <A HREF="#toc8.4">Definizione delle policy</A>
</H2>

<P>Iniziamo quindi a parlare di iptables, ed iniziamo proprio definendo la ``politica'' di default
delle catene di base, cio&egrave; l'azione che deve essere presa nel caso in cui nessuna regola
si possa applicare al particolare pacchetto. Per fare questo, basta dare:
<BLOCKQUOTE><CODE>
<PRE>
12: iptables -P INPUT DROP
13: iptables -P OUTPUT DROP
14: iptables -P FORWARD DROP
</PRE>
</CODE></BLOCKQUOTE>

Qui vediamo proprio che se un match non viene trovato, i pacchetti devono essere ``buttati via'' (DROP),
proprio come se non fossero mai stati ricevuti (o richiesto l'invio, a secondo della catena).</P>
<P>Oltre a DROP, esistono molte altre azioni che &egrave; possibile specificare, dove le principali sono:
<UL>
<LI>ACCEPT -- lascia passare il pacchetto</LI>
<LI>QUEUE -- passa il pacchetto ad un programma in userspace</LI>
</UL>
  
Di base, le due azioni che userete di pi&ugrave; sono ACCEPT e DROP. QUEUE difficilmente
lo userete. Spesso per&ograve; vi capiter&agrave; di usare delle ``target extensions'', ossia
dei particolari target che sono forniti tramite dei moduli esterni (vi ricordate
tutte le patch applicate col patch-o-matic? Molte hanno dato origine a dei nuovi
target). </P>
<P>E' buona abitudine mettere come politica di default quella di buttare via i pacchetti,
dopodich&egrave; consentire esplicitamente tutto ci&ograve; che vogliamo fare passare.
Questo principalmente per due motivi:
<UL>
<LI>&egrave; facile rendersi conto di cosa si &egrave; dimenticato chiuso (molti dei
vostri utenti vi telefoneranno fino alla saturazione delle linee telefoniche pur di vedere il
loro client preferito funzionare), mentre &egrave; molto pi&ugrave; difficile
vedere cosa si &egrave; dimenticato aperto.</LI>
<LI>non &egrave; facile riconoscere tutto ci&ograve; che c'&egrave; da bloccare. Per esempio,
Usando una politica
di ACCEPT, &egrave; estremamente difficile prevedere ci&ograve; che potr&agrave; essere
utilizzato per aggirare le restrizioni, contando che spesso non &egrave; obbligatorio
seguire gli standard e una persona un po' sveglia potrebbe modificare il kernel di 
due macchine linux per utilizzare un protocollo che nulla ha a che vedere col tcp
e che mai noi ci saremmo immaginati di dover bloccare (trattandosi, magari, di un
protocollo inventato di sana pianta)...</LI>
</UL>

Un comando che vi pu&ograve; essere utile nello scrivere le regole si chiama ``nstreams'':
questo stamper&agrave; a video l'elenco di tutte le connessioni in corso su una rete...</P>

<H2><A NAME="ss8.5">8.5</A> <A HREF="#toc8.5">La nostra configurazione</A>
</H2>

<P>Prima di andare avanti e definire le regole di firewalling, dobbiamo avere un'idea
chiara di cosa vogliamo fare con la nostra rete.
Prima di procedere, &egrave; quindi fondamentale un minimo di pianificazione. Nel nostro caso,
abbiamo una dmz, una lan ed un collegamento ad internet.</P>
<P>Abbiamo un firewall con tre interfacce di rete, ognuna collegata ad una rete diversa e 
abbiamo quindi una connessione ad internet relativamente lenta (rispetto
alle altre due reti).
L'idea di base &egrave; quella di mettere nella dmz i server e di fare in modo da risparmiare banda,
inserendo un proxy server.</P>
<P>Sulla nostra dmz, ci troveremo quindi:
<UL>
<LI>un web server, ad uso sia interno che esterno</LI>
<LI>un mail server (pop3 e smtp), ad uso sia interno che esterno</LI>
<LI>un proxy server, soltanto ad uso interno</LI>
<LI>un dns, ad uso sia interno che esterno</LI>
</UL>

Per quanto riguarda le altre restrizioni da imporre alle comunicazioni tra le 
varie reti (ad esempio, non vogliamo che gli utenti della lan controllino altre
caselle di posta elettronica oltre quelle fornite dal nostro mail server), ne 
parleremo in ogni specifica sezione.</P>


<H2><A NAME="ss8.6">8.6</A> <A HREF="#toc8.6">Prime catene</A>
</H2>

<P>Ok, due sezioni fa abbiamo detto al kernel di buttare via tutto quanto pu&ograve; avere a che fare
col nostro computer. Per andare avanti nella nostra configurazione, dobbiamo quindi
indicare cosa invece lasciare passare. Questo si fa aggiungendo delle regole. Una
soluzione potrebbe essere quella di aggiungere tutte le regole relative al traffico
che vogliamo lasciare passare nelle 3 catene di base. Funzionerebbe, ma vi posso garantire 
che sarebbe molto facile commettere degli errori e vi posso garantire che altrettanto 
facilmente diventerebbero cos&igrave; tante da non poter essere pi&ugrave; gestibili. </P>
<P>Uno degli approcci pi&ugrave; semplici nella gestione delle regole di firewalling &egrave; quindi quello
di dividere il traffico in ``flussi'' di dati dopodich&egrave; considerare indipendentemente ogni 
singolo flusso, evitando cos&igrave; di avere tutte le regole insieme e formalizzandosi in modo da 
evitare gli errori pi&ugrave; comuni.</P>
<P>Analizzando il nostro esempio, potremmo quindi dividere il nostro traffico in 6 grandi
flussi:
<UL>
<LI>tutto ci&ograve; che dalla lan va alla dmz</LI>
<LI>tutto ci&ograve; che dalla lan va su internet</LI>
<LI>tutto ci&ograve; che dalla dmz va su internet</LI>
<LI>tutto ci&ograve; che dalla dmz va sulla lan</LI>
<LI>tutto ci&ograve; che da internet va sulla nostra dmz</LI>
<LI>tutto ci&ograve; che da internet vuole andare sulla nostra lan</LI>
</UL>

Possiamo poi, per esempio, creare per ogni flusso una catena e ad ogni
catena associare un suo insieme di regole indipendenti da quello di 
tutte le altre catene.</P>
<P>Ma andiamo per gradi: iniziamo a creare delle nuove catene. Per 
fare questo dobbiamo eseguire iptables seguito da un ``-N'' e da un
nome per la catena:
<BLOCKQUOTE><CODE>
<PRE>
16: iptables -N landmz       #dalla scheda di rete eth0 alla scheda di rete eth1
17: iptables -N laninet      #dalla scheda di rete eth0 alla scheda di rete eth2
18: iptables -N dmzinet      #dalla scheda di rete eth1 alla scheda di rete eth2
19: iptables -N dmzlan       #dalla scheda di rete eth1 alla scheda di rete eth0
20: iptables -N inetdmz      #dalla scheda di rete eth2 alla scheda di rete eth1
21: iptables -N inetlan      #dalla scheda di rete eth2 alla scheda di rete eth0
</PRE>
</CODE></BLOCKQUOTE>

Per il kernel, per&ograve;, il nome che abbiamo dato ed il commento non hanno alcun
significato. Dobbiamo quindi trovare un modo per indicare quali catene devono essere
percorse in quali situazioni. Per fare questo, possiamo specificare 6 semplici
regole. Trattandosi di regole per traffico che non &egrave; n&eacute; originato
n&eacute; destinato al firewall, dovremo inserirle nella catena di FORWARD.
Per esempio, potremmo dare dei comandi come:
<BLOCKQUOTE><CODE>
<PRE>
23: iptables -A FORWARD -i eth0 -o eth1 -j landmz
24: iptables -A FORWARD -i eth0 -o eth2 -j laninet
25: iptables -A FORWARD -i eth1 -o eth2 -j dmzinet
26: iptables -A FORWARD -i eth1 -o eth0 -j dmzlan
27: iptables -A FORWARD -i eth2 -o eth1 -j inetdmz
28: iptables -A FORWARD -i eth2 -o eth0 -j inetlan
</PRE>
</CODE></BLOCKQUOTE>

Il significato di queste righe &egrave; molto semplice: aggiungi (-A, append) alla
catena FORWARD, una regola per cui se un pacchetto proviene dalla scheda
di rete eth0 (-i) ed &egrave; destinato ad uscire dalla scheda eth1 (-o), la sua
sorte deve essere decisa (-j) dalla catena landmz e cos&igrave; via. In pratica,
abbiamo diviso tutti i pacchetti in transito nella catena di forward in
6 categorie, dove ogni categoria ha associata una catena e quindi una 
serie di regole. Riassumendo:  
<UL>
<LI><I>-N</I> crea una nuova catena</LI>
<LI><I>-A</I> aggiunge una regola ad una catena</LI>
<LI><I>-i</I> consente, in una regola, di discriminare i pacchetti in
base all'interfaccia fisica da cui sono entrati</LI>
<LI><I>-o</I> in base all'interfaccia fisica da cui usciranno (scelta
in base alle tabelle di routing da noi impostate)</LI>
<LI><I>-j</I> di mandare i pacchetti ad un'altra catena</LI>
</UL>

Abbiamo visto quindi come una regola pu&ograve; identificare dei pacchetti in 
base alle schede di rete coinvolte. E' per&ograve; possibile utilizzare molti
altri criteri, per esempio:
<UL>
<LI>il protocollo (-p)</LI>
<LI>l'indirizzo ip sorgente (-s)</LI>
<LI>l'indirizzo ip destinazione (-d)</LI>
<LI>se si tratta di un frammento (-f)</LI>
<LI>o se non lo &egrave; (! -f)</LI>
</UL>

Dove ogni protocollo pu&ograve; aggiungere dei criteri di classificazione. Per esempio,
se specifichiamo ``-p tcp'' per indicare il protocollo tcp, possiamo poi dividere
i pacchetti in base anche 
<UL>
<LI>alla porta sorgente (--sport)</LI>
<LI>alla porta destinazione (--dport)</LI>
<LI>ai flag del tcp (--tcp-flags SYN, ACK, FIN...)</LI>
<LI>alle opzioni (--tcp-option)</LI>
</UL>

Anche in questo caso, oltre alle estensioni fornite dai protocolli, &egrave; possibile
utilizzare delle estensioni fornite da moduli.</P>
<P>A questo punto per&ograve;, vi sar&agrave; venuto spontaneo chiedervi perch&eacute; effettuare una
prima classificazione in base all'hardware e non, ad esempio, in base all'indirizzo
ip sorgente o all'indirizzo ip destinazione. Ancora una volta, la risposta &egrave; molto semplice:
il contenuto di un pacchetto si pu&ograve; falsificare. Il fatto che arrivi su un'interfaccia
piuttosto che un'altra, no. Utilizzando almeno per le prime regole le interfacce
di input e quelle di output, avremo quindi la certezza che i pacchetti saranno valutati
dalle regole contenute nella catena corretta e che nessuno potr&agrave; imbrogliarci utilizzando
ip fasulli (ancora, cosa succederebbe se basassimo le nostre regole solo sugli indirizzi ip
e qualcuno ci mandasse dei pacchetti provenienti da 127.0.0.1 con l'rp_filter disabilitato?).</P>



<H3>Dalla LAN alla DMZ</H3>

<P>Ricordandoci della configurazione della nostra ipotetica rete, abbiamo deciso
che dalla nostra lan vogliamo che tutte le richieste per
pagine web vengano deviate sul nostro server proxy (transparent proxy) in maniera trasparente,
che i nostri utenti non controllino altre caselle di posta elettronica
se non quelle da noi fornite, che possano collegarsi al nostro server
web direttamente e che siano in grado di scaricare file con ftp direttamente
da internet. Dall'esterno, vogliamo soltanto rendere accessibile
il nostro dns, il server di posta elettronica, il nostro server web
ed il server ftp. Ma lavoriamo anche qua per flussi, in modo da semplificare
un po' le cose.</P>
<P>Iniziamo allora a creare le regole per la nostra
lan, lasciando indietro (per ora) ci&ograve; che riguarda il ``deviare''. Dalla lan
alla dmz, vogliamo quindi consentire:</P>
<P>
<UL>
<LI> le connessioni al nostro server web (www)</LI>
<LI> le connessioni per spedire la posta (smtp)</LI>
<LI> le connessioni per ricevere la posta (pop3)</LI>
<LI> le connessioni verso il server proxy (webcache)</LI>
<LI> nonch&eacute; le connessioni necessarie per utilizzare il nostro dns
(domain)</LI>
</UL>

Aggiungiamo quindi le regole corrette, esattamente come indicato
qua sopra:
<BLOCKQUOTE><CODE>
<PRE>
30: iptables -A landmz -s ! 192.168.200.0/24 -j DROP
31: iptables -A landmz -p tcp -d nostro.server.web --dport www -j ACCEPT
32: iptables -A landmz -p tcp -d nostro.server.smtp --dport smtp -j ACCEPT
33: iptables -A landmz -p tcp -d nostro.server.pop3 --dport pop3 -j ACCEPT
34: iptables -A landmz -p tcp -d nostro.server.proxy --dport webcache -j ACCEPT
35: iptables -A landmz -p tcp -d nostro.dns --dport domain -j ACCEPT
36: iptables -A landmz -p udp -d nostro.dns --dport domain -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

Prima di tutto, qua dentro sarebbe molto meglio indicare direttamente
degli indirizzi ip al posto dei nomi dei computer. Come abbiamo gi&agrave; detto,
infatti, il protocollo dei DNS deve essere considerato insicuro. Se proprio
volessimo usare i nomi dei computer, potremmo utilizzare il vecchio file
degli hosts, in /etc/hosts, dove ogni linea &egrave; formata dall'indirizzo
ip di un computer seguito dal suo nome (e separati da spazi).</P>
<P>Come potete vedere, questa volta le regole le ``appendiamo'' (-A) non pi&ugrave; alla
catena di FORWARD bens&igrave; alla catena landmz, trattandosi di regole
che andranno a discriminare il traffico tra la nostra lan e la nostra
dmz.</P>
<P>Ora, la prima regola indica che non vogliamo
che passi niente che non abbia un indirizzo ip proveniente dalla
nostra rete interna. Questa regola eviter&agrave; quindi che qualcuno
dei nostri utenti possa fare spoofing verso la nostra dmz o che comunque
tenti di imbrogliarci con dei giochi strani sull'indirizzo ip. E' una
regola un po' superflua, avendo gi&agrave; abilitato la protezione del
kernel, ma a volte &egrave; meglio aggiungere qualche regola in pi&ugrave;
piuttosto che avere qualche regola in meno (e poi, siete sicuri che nelle
prossime versioni del kernel il filtro sar&agrave; ancora disponibile o
che si comporter&agrave; sempre nello stesso modo?).</P>
<P>Le altre sono ancora regole molto semplici. Le uniche novit&agrave; introdotte 
rispetto prima sono la negazione (il !), che indica che perch&eacute; una regola venga 
applicata una certa condizione <B>non</B> deve essere soddisfatta, ed il fatto 
che finalmente potete vedere diversi criteri messi in pratica. -s, specifica 
un ip sorgente e pu&ograve; essere seguito da un indirizzo ip o da un indirizzo di rete (indicato 
come x.x.x.x/y) o dal nome di un host. -p pu&ograve; essere seguito dal nome o dal numero 
di un protocollo (file /etc/protocols conserva le associazioni). 
-d, ancora, indica la destinazione di un pacchettino e pu&ograve; essere 
seguito sempre da un indirizzo ip, da un nome di host o da un indirizzo di rete (con lo stesso 
formato indicato prima). --dport, invece, indica una porta di destinazione e pu&ograve; essere seguito 
da un numero o dal nome di una porta (il file /etc/services conserva le associazioni). 
In tutti i casi, &egrave; possibile usare la negazione 
dopo l'indicazione del criterio.</P>
<P> Infine, ACCEPT dice ad iptables di accettare tali 
pacchetti nel caso in cui la regola risulti applicabile. Per configurare un firewall, &egrave; 
necessaria una buona conoscenza dei vari
protocolli di rete: l'ultima riga &egrave; stata aggiunta in quanto il protocollo
per la comunicazione con i dns utilizza il pi&ugrave; delle volte connessioni
udp, mentre utilizza connessioni tcp solo in condizioni particolari. Senza questa
regola, il dns avrebbe funzionato sempre tranne qualche volta, e sarebbe stato estremamente
difficile trovare il problema (se mai ce ne fossimo resi conto).</P>
<P>Per chi di voi si fosse invece chiesto come si fa a specificare una rete o
che senso ha il /24, basti sapere che si tratta di un sistema estremamente
comodo per indicare le netmask. Per esempio, una netmask 255.255.255.0 indica che se i
primi 24 bit di due indirizzi ip sono uguali, allora i due si
trovano sulla stessa rete (255.255.255.0 scritto in notazione binaria sarebbe
11111111.11111111.11111111.00000000, con 24 uno). 255.255.255.0 &egrave; quindi equivalente a /24 (ogni
ottetto - 255 - sono 8 bit).</P>
<P>Visto per&ograve; che si tratta delle prime regole ``serie'' della nostra trattazione,
vediamo comunque di descriverle a parole, un po' come abbiamo fatto prima:
<UL>
<LI>30: Butta via ogni pacchetto in transito nella catena landmz che <B>non</B> venga
da un indirizzo ip facente parte la nostra lan. </LI>
<LI>31: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 80 (www) del nostro.server.web</LI>
<LI>32: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 25 (smtp) del nostro.server.smtp</LI>
<LI>33: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 110 (pop3) del nostro.server.pop3</LI>
<LI>34: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 8080 (webcache) del nostro.server.proxy</LI>
<LI>35: Accetta ogni pacchetto udp in transito dalla catena landmz destinato alla porta 53 (dns) del nostro.dns</LI>
<LI>36: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 53 (dns) del nostro.dns</LI>
<LI>(Butta via tutto il resto, come definito dalla policy)</LI>
</UL>

Ad alcuni di voi sar&agrave; venuto spontaneo chiedersi come mai &egrave; stata messa come
prima regola un ``butta via'' con una negazione, anzich&egrave; una pi&ugrave; semplice accetta 
(qualcosa del tipo: accetta ogni pacchetto in transito nella
catena landmz che viene da un indirizzo ip facente parte della nostra lan). 
Il problema &egrave; che il controllo delle regole si ferma alla prima regola soddisfatta. Se fosse stata quindi
un'accept, la regola sarebbe stata soddisfatta per ogni pacchetto proveniente dalla lan, e la scansione
delle regole non sarebbe andata avanti a quelle successive, vanificando buona parte del nostro lavoro. 
Un'altra possibilit&agrave; sarebbe stata quella di omettere la prima regola e di specificare ogni 
volta esplicitamente l'indirizzo ip, aggiungendo alle righe dalla 31 alla 36 qualcosa come ``-s 192.168.200.0/24''.
Siccome per&ograve; sono una persona molto pigra, ho scelto il metodo pi&ugrave; veloce da scrivere.</P>
<P>L'ultima regola indicata tra parentesi, poi, non &egrave; stata da noi scritta: &egrave; implicitamente aggiunta
dalla policy (DROP) che abbiamo deciso di utilizzare.</P>
<P>L'esperienza per&ograve; mi insegna che a questo punto potrebbe essere conveniente inserire come regola 38 qualcosa
di simile a:
<BLOCKQUOTE><CODE>
<PRE>
38: iptables -A landmz -p tcp -j REJECT --reject-with tcp-reset
</PRE>
</CODE></BLOCKQUOTE>

Questo ha a che vedere con i meandri del tcp. Ma vediamo di spiegarla in poche parole: quando
avviene una connessione TCP/IP, ha luogo il solito ``three way handshake''. In pratica, per
avere la certezza che i pacchetti arrivino a destinazione, il computer A manda un messaggio
del tipo ``questo &egrave; il mio numero, e se ci sei, mandami il tuo'', dopodich&egrave; il computer B 
risponde con un messaggio del
tipo ``ho ricevuto il tuo numero, questo &egrave; il mio'', infine il computer A risponde dicendo ``ho ricevuto
il tuo numero'' e la comunicazione ha inizio. Normalmente per&ograve;, rispettando il protocollo TCP/IP, 
se il computer A dovesse tentare di collegarsi ad una porta chiusa (ad un servizio non disponibile) su
B, allora B dovrebbe rispondere con ``la porta &egrave; chiusa''.</P>
<P> Ma vediamo cosa succede nel nostro caso:
<UL>
<LI>Tra <I>A</I> e <I>B</I> c'&egrave; il nostro firewall <I>F</I>.</LI>
<LI><I>A</I> manda il messaggio a <I>B</I> ad una porta non consentita.</LI>
<LI>senza regola 38, <I>F</I> riceve il messaggio e lo butta via.</LI>
<LI><I>A</I> rimane in attesa di una risposta per parecchi secondi e ci riprova, sempre con
lo stesso risultato.</LI>
<LI>A questo punto, <I>A</I> &egrave; rimasto in attesa di un tempo valutabile in minuti, mentre <I>B</I>
&egrave; rimasto inconsapevole di tutto. </LI>
</UL>

Bene, la regola 38 dice che per ogni connessione tcp arrivata in fondo alla catena (essendo stata aggiunta
per ultima), invece di essere buttato via il pacchetto, deve essere utilizzata l'estensione (modulo
esterno) REJECT per mandare un ``tcp-reset'', il messaggio che indica il fatto che la porta &egrave; chiusa.</P>
<P>Vediamo per&ograve; che il target REJECT &egrave; stato specificato semplicemente con un -j, come per tutti gli 
altri target. Quando si parla di target, infatti, non c'&egrave; alcuna differenza tra ``estensioni'' esterne
e target forniti direttamente da iptables, se non la pagina di manuale.</P>
<P>Alcuni di voi si potranno chiedere a questo punto ``ma che diavolo, cosa mi interessa se l'altro tentando di accedere
ad una porta non consentita rimane in attesa?? Cos&igrave; impara per la prossima volta...''. 
Beh, ci sono almeno tre buoni motivi per non lasciarlo in attesa:
<UL>
<LI>A volte, quando vi collegate per esempio ad un server di posta elettronica, alcuni sistemi
fanno quello che viene definito un ``ident lookup'', cercano cio&egrave; di capire chi siete 
collegandosi alla porta 113 della vostra macchina, dove teoricamente ci dovrebbe essere un
demone in ascolto che fornisce questo tipo di informazioni.
<P>Il problema &egrave; che questi sistemi non vi fanno accedere al servizio fino a quando
non scoprono la vostra identit&agrave; o non appurano che il vostro sistema non offre questo
servizio (rispondendo che la porta &egrave; chiusa). In entrambi i casi, il sistema remoto
rimane in attesa di una risposta, e se questa non arriva, pu&ograve; ipotizzare due cose:
<OL>
<LI>che la richiesta sia andata persa</LI>
<LI>che il vostro computer sia improvvisamente morto</LI>
</OL>

Proveranno quindi a rimandare il pacchetto per diverse volte prima di arrendersi e farvi entrare
(ma come, il vostro computer non era morto? Non ha risposto quando abbiamo tentato di contattarlo...), 
introducendo spesso dei delay valutabili nell'ordine 
delle decine di secondi o addirittura dei minuti.</P>
<P>L'esempio pi&ugrave; classico &egrave; questo, ma altri protocolli usano un approccio simile, 
e vi posso garantire che una regola come la 38 pu&ograve; evitarvi diversi delay nell'utilizzo della rete 
altrimenti difficilmente spiegabili.</P>
</LI>
<LI>Molti ``scanner'' sono tratti in inganno da questa regola che fa credere loro che la porta sia
effettivamente chiusa rendendo quindi pi&ugrave; difficile l'identificazione del firewall (vi siete 
mai chiesti come nmap faccia ad indicare che una porta &egrave; ``filtered'' piuttosto che
``closed''?). Attenzione per&ograve; che
scanner pi&ugrave; intelligenti potrebbero rilevare le differenze di TTL (il firewall si trova un passo
prima del vero client), rendendo vano tale tentativo (se volete divertirvi, date un'occhiata al 
target TTL, che vi consente di evitare persino quest'effetto).</LI>
</UL>

Questa regola la vedrete apparire molto spesso nelle catene seguenti, sempre per lo stesso motivo...
Dovremmo quindi aver finito con il traffico dalla LAN alla nostra DMZ.</P>


<H3>Dalla DMZ alla LAN</H3>

<P>Ok, qua (a dirsi) le cose sono molto pi&ugrave; semplici: dobbiamo consentire
soltanto quei pacchettini in risposta alle richieste partite dalla LAN (i
server non si devono connettere di loro spontanea volont&agrave; ai nostri client -- teoricamente,
nessuno dovrebbe usarli).</P>
<P>Fare questo in ipchains era una cosa abbastanza complessa: 
bisognava specificare delle regole per consentire ogni tipo di pacchetto
che ci sarebbe potuto tornare in risposta (giocando con l'opzione --syn, che 
seleziona i pacchetti che stabiliscono nuove connessioni) e si doveva quindi avere una buona
conoscenza (se non ottima) dei vari protocolli. iptables facilita molto le cose
tramite l'introduzione di ``moduli per il tracciamento delle connessioni''
(conntrack -- uno dei molti vantaggi dei firewall statefull rispetto quelli stateless).</P>
<P>Vediamo quindi una delle soluzioni che potremmo adottare:
<BLOCKQUOTE><CODE>
<PRE>
40: iptables -A dmzlan -s ! 123.45.67.9/29 -j DROP
41: iptables -A dmzlan -m state --state ESTABLISHED,RELATED -j ACCEPT
42: iptables -A dmzlan -p tcp -j REJECT --reject-with tcp-reset
</PRE>
</CODE></BLOCKQUOTE>

Bene, il primo comando &egrave; la solita regola per evitare lo spoofing.
Il secondo invece, &egrave; diverso da ogni altro comando finora incontrato:
-m chiede ad iptables di caricare un modulo esterno, in questo caso il modulo
state (si ricorda lo stato delle connessioni), per il tracciamento delle connessioni. 
L'opzione --state relativa
al modulo state &egrave; quello che ci permette di identificare i pacchetti: in pratica,
la regola ha come significato quello di consentire tutti i pacchetti
facenti parte connessioni gi&agrave; stabilite (ESTABLISHED, e se sono gi&agrave; stabilite vuol dire
che sono state consentite) e tutte quelle connessioni relative a connessioni gi&agrave; esistenti (RELATED).</P>
<P>In questo caso, la parolina magica &egrave; proprio RELATED. Ci consente cio&egrave; di scaricare
sul modulo state la responsabilit&agrave; di identificare i pacchettini che non soltanto
sono risposte a pacchetti gi&agrave; inviati, ma anche quelli che fanno parte dello stesso protocollo.</P>
<P>Vediamo per&ograve; qualche esempio:
<UL>
<LI>Quando volete scaricare un file tramite ftp il vostro browser (o qualsivoglia programma stiate
utilizzando) apre prima una connessione di controllo sul server remoto, sulla classica
porta 21. Dopodich&eacute; si mette d'accordo con il computer remoto su una porta da utilizzare
per creare una nuova connessione per l'invio dei dati. Ma proprio qui sorge il problema:
per passare dal nostro firewall (che ha una politica di DROP), questa connessione dovrebbe
essere esplicitamente consentita a priori con una regola che termina con un -j ACCEPT. 
A priori, per&ograve;, non possiamo creare questa regola in quanto non sappiamo le porte che verranno utilizzate
(possono essere liberamente negoziate sia dal client che dal server). La soluzione normalmente adottata
prima dell'introduzione dei moduli di tracciamento
era molto semplice: consentire tutte le connessioni salvo quelle a porte problematiche. Il modulo
state, invece, ci viene in aiuto aggiungendo e rimuovendo regole dinamicamente secondo quanto necessario.</LI>
<LI>Il protocollo ip lavora in collaborazione con il  
protocollo ICMP che viene utilizzato per la segnalazione e la gestione degli errori. 
Ebbene, senza utilizzare il modulo state con l'opzione
RELATED, avremmo dovuto impostare per ogni connessione consentita una regola del tipo ``consenti tutti i messaggi
di errore relativi a questa connessione'', oppure consentire l'entrata di tutti i pacchetti ICMP di 
alcuni tipi. Bene, il modulo state si prende in carico anche di questo aggiungendo e togliendo regole
dinamicamente ed in maniera trasparente.</LI>
</UL>

La differenza &egrave; quindi questa: ESTABLISHED, fa passare tutti i pacchetti che fanno parte
di una connessione gi&agrave; stabilita, mentre RELATED fa passare tutti i pacchetti di controllo (errori,
piuttosto che...) o connessioni relative alle connessioni conosciute.</P>
<P>Se state configurando un firewall, per&ograve;, e la vostra preoccupazione principale &egrave; la sicurezza, vi
sar&agrave; sorta spontanea una domanda: ``e se qualcuno imbrogliasse il modulo di state, facendo aprire
connessioni non volute?''. Bene, in passato qualche problema di questo tipo &egrave; stato sollevato,
ma il codice del netfilter dovrebbe essere attualmente abbastanza maturo per evitare questo tipo di
problemi. </P>
<P> Vi consiglio per&ograve; di seguire le mailing list dedicate, per essere eventualmente
prontamente avvisati di possibili problemi, e di leggere qualche documento in pi&ugrave; sul funzionamento
del protocollo ftp.</P>
<P>Attenzione per&ograve; che perch&eacute; le regole sopra elencate funzionino, potrebbe essere necessario caricare
dei moduli nel kernel, con comandi del tipo ``modprobe ip_conntrack'',
``modprobe ip_conntrack_ftp'', ``modprobe ip_conntrack_altri_moduli_di_protocolli_che_volete_utilizzare''.</P>
<P>Per quanto riguarda le prestazioni, il modulo state utilizza un po' pi&ugrave; di risorse rispetto 
alle regole manuali, ma comunque nulla di rilevante se rapportato ai vantaggi che offre (alcune cose,
non &egrave; proprio possibile farle con firewall stateless, a meno di non aprire migliaia di porte).</P>
<P>Un'altra cosa da dire &egrave; che prima, nella definizione della catena dalla LAN alla DMZ, ho volutamente
dimenticato la regola 37:
<BLOCKQUOTE><CODE>
<PRE>
37: iptables -A landmz -m state ESTABLISHED,RELATED -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

che sarebbe stata troppo prematura da discutere. In pratica, anche dalla 
lan alla dmz &egrave; importante far passare tutti quei dati relativi a connessioni
gi&agrave; stabilite o comunque i messaggi di errore.
Probabilmente non molto importante per reti di piccole dimensioni,
ma rilevante in reti pi&ugrave; grosse o con regole pi&ugrave; complicate. Anche questa regola la
vedrete apparire molto spesso.</P>

<H3>Dalla LAN ad Internet</H3>

<P>Dalla nostra lan ad internet vogliamo invece essenzialmente
che passi traffico ftp (che non pu&ograve; essere deviato sul proxy), in modo che gli utenti 
possano scaricare
direttamente il loro materiale. Per fare questo, basta aggiungere
le regole:
<BLOCKQUOTE><CODE>
<PRE>
44: iptables -A laninet -s ! 192.168.200.0/24 -j DROP
45: iptables -A laninet -p tcp --dport ftp -j ACCEPT
48: iptables -A laninet -m state ESTABLISHED,RELATED -j ACCEPT
49: iptables -A laninet -p tcp -j REJECT --reject-with tcp-reset
</PRE>
</CODE></BLOCKQUOTE>

Dove per&ograve; non c'&egrave; nulla di nuovo di cui parlare...</P>

<H3>Da Internet alla LAN</H3>

<P>Infine, per terminare con la nostra lan:
<BLOCKQUOTE><CODE>
<PRE>
50: iptables -A inetlan -s 192.168.200.0/24 -j DROP
51: iptables -A inetlan -s 123.15.67.9/29 -j DROP
52: iptables -A inetlan -m state --state ESTABLISHED,RELATED -j ACCEPT
53: iptables -A inetlan -p tcp -j REJECT --reject-with tcp-reset
</PRE>
</CODE></BLOCKQUOTE>

In questo caso, le prime due regole bloccano tutti quei pacchetti
che hanno come mittente l'indirizzo di una delle nostre due reti.</P>
<P>La terza regola, invece, consente a tutte le connessioni create
dall'interno di poter ricevere una risposta, senza dover scrivere
troppe regole.</P>
<P>All'epoca di ipchains invece, non c'era un modo di ``tenere traccia'' 
delle connessioni ed era quindi necessario aprire molte pi&ugrave; porte per consentire a
ftp di funzionare, cosa che diminuiva notevolmente l'efficacia
del firewall.</P>

<H3>Da Internet alla DMZ</H3>

<P>Andiamo avanti ora con la configurazione della nostra
dmz. Abbiamo detto che da internet saranno accessibili i seguenti
servizi:
<UL>
<LI>server web</LI>
<LI>server smtp</LI>
<LI>server dns</LI>
<LI>server ftp</LI>
</UL>

Che si traduce linearmente in qualcosa del tipo:
<BLOCKQUOTE><CODE>
<PRE>
54: iptables -A inetdmz -s 192.168.200.0/24 -j DROP
55: iptables -A inetdmz -s 123.15.67.9/29 -j DROP
56: iptables -A inetdmz -p tcp -d nostro.server.web --dport www -j ACCEPT
57: iptables -A inetdmz -p tcp -d nostro.server.smtp --dport smtp -j ACCEPT
58: iptables -A inetdmz -p tcp -d nostro.dns --dport domain -j ACCEPT
59: iptables -A inetdmz -p udp -d nostro.dns --dport domain -j ACCEPT
60: iptables -A inetdmz -p tcp -d nostro.ftpserver --dport ftp -j ACCEPT 
61: iptables -A inetdmz -m state --state ESTABLISHED,RELATED
62: iptables -A inetdmz -p tcp -j REJECT --reject-with tcp-reset
</PRE>
</CODE></BLOCKQUOTE>

In questo caso, la prima regola &egrave; un po' superflua ma estremamente
importante. I nostri server, infatti, potrebbero essere configurati per essere un 
po' meno restrittivi nei confronti dei nostri utenti. Se qualcun altro
riuscisse da internet ad usare i nostri indirizzi ip, sarebbe in 
grado di usufruire di questi benefici.</P>

<H3>Dalla DMZ ad Internet</H3>

<P>Dalla DMZ ad Internet, invece
<BLOCKQUOTE><CODE>
<PRE>
63: iptables -A dmsinet -s ! 123.15.67.9/29 -j DROP
64: iptables -A dmzinet -p tcp -s nostro.server.smtp --dport smtp -j ACCEPT
65: iptables -A dmzinet -p udp -s nostro.server.dns --dport domain -j ACCEPT
66: iptables -A dmzinet -p tcp -s nostro.server.dns --dport domain -j ACCEPT
67: iptables -A dmzinet -p tcp -s nostro.server.proxy --dport www -j ACCEPT
68: iptables -A dmzinet -m state --state ESTABLISHED,RELATED -j ACCEPT
69: iptables -A dmzinet -p tcp -j REJECT --reject-with tcp-reset
</PRE>
</CODE></BLOCKQUOTE>

Qui qualche commento &egrave; doveroso farlo... </P>
<P>La prima regola consente al server smtp di inviare la 
posta elettronica dei nostri utenti.</P>
<P>Dello stesso tipo sono la seconda e terza regola, che consentono
invece al dns server di effettuare delle query ricorsive ed eventualmente
degli zone transfer. </P>
<P>La quarta regola, infine, &egrave; quella che consente al proxy server di uscire
all'esterno a procurarsi le pagine non in cache. Attenzione, per&ograve;, che 
a secondo delle configurazioni del vostro proxy server, potrebbe essere
necessario aprire pi&ugrave; porte (per fare comunicare pi&ugrave; proxy tra di loro,
per consentire l'utilizzo al proxy del protocollo ftp...).</P>
<P>Le ultime due sono le solite regole:
consenti le risposte alle richieste effettuate, chiudi le connessioni
tcp vietate.</P>


<H3>Traffico da e per il firewall</H3>

<P>Come ultima cosa, ci rimane da filtrare il traffico originato o destinato
al firewall direttamente.
Giusto a titolo esemplificativo, ecco alcune regole:
<BLOCKQUOTE><CODE>
<PRE>
71: iptables -A INPUT -m limit --limit 10/min -p tcp --syn --dport ssh -j ACCEPT
72: iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
73: iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
74: iptables -A INPUT -p tcp -j REJECT --reject-with tcp-reset

75: iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

Buona norma sarebbe quello di consentire il meno possibile verso il 
firewall, e di bloccare tutto ci&ograve; che pu&ograve; da lui essere originato.
In questo caso, viene accettato il traffico ssh ed i ping (non sempre una buona
idea) e tutto il traffico relativo, mentre in uscita vengono consentite solo le risposte ai
pacchettini ricevuti. Se utilizzate demoni come zebra o simili, potrebbe essere
necessario aprire pi&ugrave; porte ed allentare un po' la cintura soprattutto per quanto
riguarda icmp. Ricordatevi inoltre che se non viene specificata esplicitamente
una interfaccia, la catena di INPUT e di OUTPUT determineranno il comportamento
di <B>input e output</B> da tutte le interfacce (compreso il loopback!!!). State
quindi molto attenti a quello che fate.</P>
<P>Potete vedere anche l'utilizzo di un nuovo
modulo: il limit, che consente di impostare dei limiti di frequenza,
e per la prima volta dell'opzione (tcp) --syn, che seleziona soltanto
le nuove connessioni (i famosi pacchettini ``mandami il tuo numero'').
Questo per evitare un problema con ssh segnalato diverso tempo fa (e probabilmente
gi&agrave; corretto) per cui in determinate condizioni e con reti molto veloci
era possibile fare hijacking di una connessione tentando di indovinare
alcuni parametri. </P>
<P>Ultima cosa importante da dire prima di passare ad altro: a differenza
da ipchains, in iptables ci&ograve; che non &egrave; esplicitamente consentito non passa (o
vice versa, a secondo della policy). Per esempio, nel nostro caso un client
interno alla rete non potrebbe ``pingare'' alcun server all'esterno n&eacute; sarebbe
in grado di utilizzare altri messaggi ICMP che non siano imparentati (related)
con connessioni esistenti.</P>
<P>Con questo paragrafo viene chiuso l'argomento filtraggio. Nel prossimo paragrafo
si parler&agrave; infatti del NAT e di come fare quelle ``deviazioni'' di cui 
ci siamo temporaneamente dimenticati.</P>
<P> 
Lo scopo era quello di introdurre l'utente all'uso di
iptables e di metterlo nelle condizioni di poter leggere facilmente le pagine
del manuale, dove pu&ograve; trovare un elenco di tutti i possibili match
che si possono effettuare (divisi per protocollo e modulo) e di tutti
i target che si possono utilizzare. Per le target extension installate
con il patch-o-matic, riferitevi alla documentazione fornita.</P>
<P> </P>

<H2><A NAME="s9">9.</A> <A HREF="#toc9">NAT con iptables</A></H2>

<P>Col paragrafo precedente abbiamo completato la configurazione di una
piccola rete per quanto riguarda il filtraggio. </P>
<P>Argomento di questa sezione &egrave; il NAT, ovvero ``Network Address Translation''.</P>
<P>Il NAT consente ad un firewall o router linux di non limitarsi 
a bloccare o consentire i pacchetti in transito, bens&igrave; anche di
modficarli secondo delle regole ben definite. </P>
<P>Il codice che in linux gestisce il NAT &egrave; stato completamente 
ridisegnato per iptables ed il risultato &egrave; stato un sistema molto pi&ugrave;
pulito e flessibile rispetto quello utilizzato da ipchains. ipchains,
per effettuare modifiche ai pacchetti, utilizzava semplicemente dei 
target diversi come MASQ (per mascherare i pacchetti). Questo per&ograve; creava
molta confusione sul meccanismo di scansione delle regole ed andava ad interferire
con le regole di filtraggio. In iptables, invece, la parte di filtraggio 
dei pacchetti &egrave; completamente indipendente da quella di modifica 
e di gestione delle regole di nat. Per raggiungere questa indipendenza
&egrave; stato infatti introdotto il concetto di ``tabella'' di cui fin'ora
non avevamo parlato. Ebbene, le 3 catene principali di cui abbiamo
parlato fin'ora (INPUT, OUTPUT, FORWARD) si trovano nella tabella ``filter''.
La tabella di filter &egrave; quella che viene scelta in automatico se non
viene specificata un'altra tabella (per questioni di compatibilit&agrave;). </P>
<P>Esistono quindi altre tabelle in iptables, ognuna delle quali mette
a disposizione diverse catene di base:
<UL>
<LI>la tabella <I>filter</I>, le cui catene principali sono <B>INPUT, OUTPUT, FORWARD</B></LI>
<LI>la tabella <I>nat</I>, le cui catene principali sono <B>PREROUTING, OUTPUT, POSTROUTING</B></LI>
<LI>la tabella <I>mangle</I>, le cui catene principali sono <B>PREROUTING, OUTPUT</B></LI>
</UL>

Beh, ci sono 3 tabelle in totale. La prima, che normalmente non viene mai 
indicata esplicitamente, che serve per filtrare i pacchetti. La seconda, quella di
nat, che serve normalmente per modificare ci&ograve; che ha a che vedere col mittente o il
destinatario di un pacchetto, ed infine la tabella di mangle che consente di modificare 
tutte le altre caratteristiche dei pacchetti. </P>
<P>La distinzione tra mangle e nat non &egrave; cos&igrave; netta, si tratta soltanto di un
criterio di base, ed il manuale vi sapr&agrave; sicuramente indicare la tabella migliore 
da utilizzare a secondo delle vostre necessit&agrave;.</P>
<P>Ma guardiamo meglio i nomi delle catene: nella tabella filter, ci troviamo
le solite INPUT, OUTPUT, FORWARD, col significato che ormai conosciamo.
Nella tabella di nat abbiamo invece 3 nuove catene: la catena di PREROUTING,
la catena di OUTPUT e la catena di POSTROUTING. La catena di OUTPUT mantiene
lo stesso significato che aveva nella tabella di filter. La catena di PREROUTING
e quella di POSTROUTING classificano invece i pacchetti diversamente: non pi&ugrave; in
base alla direzione dei pacchetti, bens&igrave; al fatto che sia gi&agrave; stata presa
una decisione di routing su questi pacchetti. Vediamo di spiegare meglio l'idea:
quando un pacchetto di qualsiasi protocollo deve uscire da una macchina connessa ad una rete (poco
importa la provenienza del pacchetto) deve essere presa una decisione di routing. Deve cio&egrave; essere
stabilito da che interfaccia dovr&agrave; uscire questo pacchetto e con quali caratteristiche dovr&agrave; 
essere mandato (es, il TTL dovrebbe essere decrementato, l'MTU potrebbe essere diverso
e necessitare una frammentazione, l'indirizzo hardware specificato potrebbe essere quello
di un gateway...). Dal punto 
di vista logico, quindi, ogni pacchetto che deve uscire da un'interfaccia di 
rete passa prima dalla catena di PREROUTING, viene presa una decisione sull'interfaccia
da cui fare uscire il pacchetto, dopodich&egrave; passa dalla catena di POSTROUTING. </P>
<P>PREROUTING e POSTROUTING sono state introdotte proprio per consentire di realizzare diversi
comportamenti: ad esempio, se si vuole cambiare l'indirizzo di destinazione di un pacchetto
sar&agrave; importante farlo prima che venga deciso da dove fare uscire il pacchetto (se cos&igrave; non 
fosse, il pacchetto uscirebbe dall'interfaccia sbagliata, a meno che questo non sia
l'effetto desiderato). Mentre, al
contrario, quando si cambia il mittente di un pacchetto potrebbe essere importante farlo dopo
che una decisione di routing &egrave; stata presa (in questo caso per&ograve; l'errore non sarebbe cos&igrave; palese).</P>
<P>Comunque sia, in ognuna di queste tabelle &egrave; possibile specificare dei target differenti utilizzando
per&ograve; le stesse opzioni e gli stessi moduli per creare delle regole. Di base, i target pi&ugrave; conosciuti
per la tabella di NAT sono proprio:
<UL>
<LI> <B>SNAT</B> consente di cambiare l'indirizzo ip sorgente di un pacchetto (POSTROUTING)</LI>
<LI> <B>DNAT</B> consente di cambiare l'indirizzo ip destinazione di un pacchetto (PREROUTING)</LI>
<LI> <B>MASQUERADE</B> consente di cambiare l'indirizzo ip sorgente di un pacchetto (verr&agrave; spiegata in 
seguito la differenza - POSTROUTING).</LI>
<LI> <B>REDIRECT</B> consente di cambiare la porta di destinazione di un pacchetto (PREROUTING)</LI>
</UL>

Torniamo ora al nostro esempio: la nostra lan utilizza degli indirizzi ip del tipo 192.168, e 
come tali non possono viaggiare su internet (192.168 &egrave;  una classe di indirizzi ip riservati per reti private). 
Per consentire 
quindi ai computer della nostra rete di navigare, sarebbe necessario o un proxy (che per&ograve; gestisca
tutti i protocolli) o fare in modo che l'indirizzo ip sorgente dei pacchetti originati dalla nostra
rete venga cambiato con un indirizzo ip valido per viaggiare in internet (come quello del nostro firewall,
per esempio).</P>
<P>Realizzare questo a livello di regole di iptables &egrave; estremamente facile. Bisogna per&ograve; fare una piccola introduzione
e dare un minimo di spiegazioni. A molti di voi, ad esempio, sar&agrave; sorto spontaneo chiedersi come 
diavolo pu&ograve; fare un firewall a nascondere 20 computer (per esempio) dietro un unico indirizzo ip. Voglio dire,
in uscita funziona bene: il client FOO dietro il firewall manda un pacchettino al gateway (il nostro firewall),
il nostro firewall cambia l'indirizzo ip sorgente col suo (valido su internet) e manda avanti il pacchettino, 
il server remoto risponde, il pacchettino torna indietro, e... il pacchettino che gli torna indietro ha come 
mittente il server remoto, come destinatario il firewall... non sembra funzionare tanto... come fa il firewall 
a capire a quale dei nostri client deve rimandare il pacchetto, se l'indirizzo di destinazione &egrave; il suo 
indirizzo esterno? E anche ipotizzando di avere un indirizzo ip solo per i client, come farebbe a mandare la
risposta al client corretto? Se guardasse l'indirizzo ip del server remoto, solo un client per volta potrebbe
navigare su un determinato sito... non proprio funzionale. Una soluzione potrebbe essere quella di avere
tanti ip esterni quanti client. Ma allora perch&eacute; usare il nat? La sicurezza potrebbe essere un
buon motivo, ma normalmente il nat si usa quando ci sono meno (o molti meno) indirizzi esterni a disposizione
rispetto ai client della propria rete (attualmente, gli indirizzi ip hanno un costo, e non indifferente).</P>
<P>Beh, la soluzione che &egrave; stata trovata per risolvere questo problema si basa sull'idea di porta. Quando stabilite
una connessione tcp verso un server, l'unica porta veramente importante &egrave; quella di destinazione, che identifica
univocamente un servizio. Quella mittente, invece, non viene quasi mai guardata e spesso viene scelta a caso.</P>
<P>Con il NAT, il nostro firewall linux cambier&agrave; (se necessario) la porta sorgente dei pacchetti in uscita
ed utilizzer&agrave; quella per identificare univocamente un client. Se la soluzione vi convince poco, provate
a pensare al flusso dei pacchetti... il client A manda un pacchetto proveniente da A porta <I>x</I> al server
B porta 80. Il firewall riceve il pacchetto, cambia x in y (dove x pu&ograve; essere uguale a y, se tale
porta non &egrave; utilizzata da nessuno), si segna che y &egrave; associata solo ad A e cambia l'indirizzo
ip sorgente con il suo, il pacchetto arriva al server remoto R porta 80 come proveniente da F:y, e risponde creando un pacchetto
proveniente da R:80 e destinato al firewall F porta y. Firewall riceve il pacchetto, vede che la connessione
non &egrave; stata creata direttamente da lui (ogni sistema operativo sa quali connessioni ha iniziato)
cerca nella tabella e vede che la porta y era in origine x ed era associata al client A. Prende il pacchetto,
modifica il destinatario in modo che indichi A porta x e rimanda il pacchetto ad A. Sembra funzionare, no?
L'idea &egrave; abbastanza furba e permette di identificare univocamente un client utilizzando qualche bit
in pi&ugrave; di informazioni. Il problema &egrave; che a volte questa tecnica non funziona:
<UL>
<LI>ad esempio, quando la trasmissione non fa uso del concetto di porta (solo le trasmissioni tcp e udp
hanno delle porte associate). Fortunatamente per&ograve;, oltre all'icmp, non esistono protocolli
realmente utilizzati che non usino il concetto di porta, e gli errori sono facilmente associabili
(non sono specifici al client: se un server non &egrave; raggiungibile, questo non sar&agrave;
raggiungibile per <EM>tutti</EM> i client dietro al NAT box). Cio&egrave;, questi protocolli esistono ma vengono comunque
normalmente gestiti non dal kernel ma da demoni dedicati per cui il problema non si pone.</LI>
<LI>ad esempio, quando c'&egrave; bisogno che i pacchettini provengano da una porta specifica: un client, nascosto
dal firewall, non sapr&agrave; mai in realt&agrave; che porta sorgente utilizzer&agrave; il firewall per rispedire i suoi
pacchetti.</LI>
<LI>ad esempio, quando il protocollo si basa su connessioni effettuate da un server
esterno verso un client interno. 
<P> Per vedere dove sta il problema, proviamo a vedere un esempio.
Ipotizziamo che il solito client FOO si colleghi a uno strano server con uno strano protocollo. 
Per via di questo strano protocollo, il server deve aprire una connessione verso
la porta 789 del client e tenta quindi di collegarsi. Quello che per&ograve; per lui 
&egrave; l'indirizzo del client &egrave; in realt&agrave; l'indirizzo del firewall, per via
del NAT che ha cambiato l'indirizzo del mittente. </P>
<P>Cos&igrave; facendo, il server tenter&agrave; di collegarsi al firewall, che per&ograve; questa volta
non avr&agrave; nessuna associazione nella sua tabella (l'associazione si crea solo per le  
connessioni che escono, e non &egrave; possibile indovinarle per quelle che entrano, a meno
che non vengano stabilite a priori dall'amministratore) e sar&agrave; quindi costretto a
buttare via il pacchetto rispondendo al server con un messaggio icmp con scritto qualcosa del 
tipo ``la porta &egrave; chiusa e io non so chi tu sia''. </P>
</LI>
</UL>

Fortunatamente per&ograve; il primo caso &egrave; estremamente raro (non credo sia stato mai nemmeno preso in considerazione
il problema), il secondo capita ancora molto raramente, mentre per il terzo esistono delle soluzioni: il
tracciamento delle connessioni.</P>
<P> 
Infatti, i moduli del kernel prima caricati che si occupavano di aprire o chiudere dinamicamente le 
porte sono anche in grado di aggiungere o rimuovere associazioni dalla famosa tabella, o di fare
delle piccole modifiche al protocollo in modo che questo possa funzionare. Per fare questo per&ograve;,
se non avete compilato staticamente il kernel, dovete caricare anche i moduli ``ip_nat_ftp'', ``ip_nat_irc''
o ``ip_nat_protocollo_strano_che volete usare'' con il solito ``modprobe''.</P>
<P>Il problema che a volte si incontra, per&ograve;, &egrave; che questi moduli non sono proprio facili
da scrivere, per cui &egrave; relativamente facile trovarne per i protocolli standard, mentre non 
esistono per quei protocolli inventati dalla fantasia dei venditori di software di turno,
che non sentono il dovere morale di rispettare degli standard.</P>
<P> Normalmente i problemi si incontrano
solo per parti dei vari ``protocolli'' (ad esempio, dietro un firewall linux di questo tipo, col messanger
sarebbe difficile farsi mandare dei file da altri utenti, pur funzionando per tutte le altre cose).
E se per ftp e IRC (anche netmeeting, ma sperimentale) sono stati scritti dei moduli, per altri protocolli
meno utilizzati credo che sar&agrave; difficile che qualcuno si occupi di realizzarli.</P>
<P>In questi casi, un ``socks server'' vi consentir&agrave; il pi&ugrave; delle volte di rendere felici i 
vostri utenti. Il prezzo da pagare &egrave; che un socks server di base &egrave; molto aperto ed una 
configurazione errata o superficiale di questo potrebbe vanificare completamente i vostri sforzi. In
pi&ugrave;, preparatevi a ricevere chiamate a tutte le ore del tipo ``come si fa ad impostare il socks
server su fuffolo 3.0 piuttosto che kazzat 2.8''...</P>

<H2><A NAME="ss9.1">9.1</A> <A HREF="#toc9.1">Dalla teoria alla pratica</A>
</H2>

<P>Passando dalla teoria alla pratica, occorre prima di tutto parlare in maniera un pochettino pi&ugrave; approfondita
dei target di default messi a disposizione dalla tabella di NAT.</P>
<P>
<UL>
<LI>SNAT: serve per modificare il mittente di un pacchetto (l'indirizzo ip sorgente). Viene utilizzato nella
catena di POSTROUTING proprio perch&eacute; il cambiare il mittente non interferisce sulla scelta dell'interfaccia
da utilizzare per raggiungere il destinatario. Consente anche di modificare manualmente la porta sorgente
di un pacchetto. Attenzione! Funziona solo con indirizzi ip statici!</LI>
<LI>DNAT: serve per modificare il destinatario di un pacchetto (l'indirizzo ip destinatario). Viene utilizzato
nella catena di PREROUTING in quanto la modifica deve essere effettuata prima di decidere da che parte
fare uscire il pacchettino. E' possibile inoltre specificare una diversa porta di destinazione.</LI>
<LI>MASQUERADE: &egrave; un tipo particolare di SNAT: fa in modo che i pacchettini abbiano come mittente l'indirizzo
IP della interfaccia di rete dalla quale usciranno. Si utilizza nella tabella di POSTROUTING (modifica il
mittente) e viene utilizzato al posto dello SNAT su interfacce con IP assegnato dinamicamente, ad esempio
tramite dhcp o bootp.</LI>
<LI>REDIRECT: &egrave; una versione semplificata del DNAT mantenuta pi&ugrave; che altro per motivi di compatibilit&agrave; e fa in
modo che il pacchettino venga rediretto sulla macchina locale (127.0.0.1) ad una porta specifica. 
Equivale a qualcosa
del tipo: -j DNAT --to 127.0.0.1:porta &lt;--&gt; -j REDIRECT --to-ports porta.</LI>
</UL>

Esistono molti altri target che possono essere aggiunti tramite il patch-o-matic adatti a tutte
le esigenze. Date un'occhiata al manuale di iptables ed alle informazioni mostrate sullo schermo
durante l'aggiornamento di iptables per maggiori informazioni.</P>
<P>Tornando invece al nostro esempio (presentato nei paragrafi sul filtraggio), &egrave; per noi indispensabile 
utilizzare il NAT in quanto:
<UL>
<LI> dobbiamo ``deviare'' tutti le connessioni web verso internet sul nostro proxy server che si 
trova nella dmz (transparent proxy).  </LI>
<LI> dobbiamo fare in modo che la nostra rete interna che utilizza indirizzi ip di classe 192.168.200.x 
(indirizzi per reti private) possa navigare su internet.</LI>
</UL>
</P>
<P>Avendo per&ograve; spesso a che fare con reti di discrete dimensioni dove il
dhcp &egrave; raramente utilizzato, mi piace aggiungere alcune regole per rendere
le macchine ``indipendenti'' dalle modifiche del provider di turno 
o eventuali riconfigurazioni della rete (vi &egrave; mai capitato di dover 
cambiare l'ip del dns su n macchine diverse, dove n tende ad infinito?).</P>
<P>Per fare questo normalmente si possono utilizzare diversi approcci:
<UL>
<LI>Se la rete &egrave; divisa in diverse sottoreti (subnet), si possono
``inventare'' due indirizzi ip che non risiedano su nessuna delle
nostre reti ed impostare tutti i client per utilizzare quegli indirizzi
ip come dns primario e secondario.</LI>
<LI>Si possono semplicemente deviare <B>tutti</B> i pacchetti destinati
ad un dns verso il dns reale (c'&egrave; il problema del dns secondario,
per&ograve;).</LI>
<LI>Semplicemente ignorare il problema inizialmente ed in caso di 
cambio di ISP aggiungere due regole per deviare il traffico
sui nuovi dns.</LI>
</UL>

Trattandosi comunque di regole abbastanza semplici ed interessanti dal 
punto di vista didattico, verranno presentate tutte e tre le soluzioni
(la prima &egrave; quasi perfettamente equivalente alla terza).  </P>
<P>Vediamo quindi le nostre prime regole di NAT:        
<BLOCKQUOTE><CODE>
<PRE>
77: iptables -t nat -A PREROUTING -p tcp -i eth0 --dport www -j DNAT --to nostro.proxy.server:8080
78: iptables -t nat -A POSTROUTING -o eth2 -s 192.168.200.0/24 -j SNAT --to 123.45.68.1
</PRE>
</CODE></BLOCKQUOTE>

Ok, la prima regola dice, a parole, di inserire una regola nella tabella di nat per intercettare tutti 
i pacchetti provenienti da eth0 e destinati ad un server www (porta 80 -- prima che venga deciso
da che interfaccia farli uscire) e di deviarli sul nostro.proxy.server porta 8080. </P>
<P>Attenzione per&ograve; che proxy server come squid devono essere configurati per poter accettare
connessioni deviate in questo modo, in quanto non seguono perfettamente lo standard utilizzato
dai proxy (leggete la documentazione di squid!).</P>
<P>Tornando a parlare delle regole, la seconda dice di modificare il mittente (l'indirizzo ip sorgente) dei
pacchetti uscenti da eth2 e provenienti dalla nostra LAN (192.168.200.0/24) con l'indirizzo
ip esterno del nostro firewall. </P>
<P>A proposito di queste due regole ci sono alcune cose importanti da dire:
<UL>
<LI>Prima di tutto, nella prima regola si &egrave; reso necessario indicare
la scheda di rete sorgente in modo da non deviare le richieste del 
nostro proxy server. Per la cronaca: quando facciamo una richiesta 
al nostro proxy server, questo se non ha le pagine richieste in cache
dovr&agrave; collegarsi al server web richiesto, e dobbiamo quindi stare 
attenti a non deviare anche le richieste provenienti dal proxy (si creerebbe una
sorta di circolo vizioso (loop) n&eacute; molto bello n&eacute; molto positivo per
la salute della nostra rete).</LI>
<LI>Nella seconda regola, invece, &egrave; importante fare in modo che soltanto
i pacchetti provenienti dalla nostra rete interna (e non dalla DMZ!)
vengano modificati e soltanto quelli uscenti verso internet (quelli
destinati al nostro proxy non devono essere toccati: saremo cos&igrave; in
grado di fare un minimo di statistiche sui siti pi&ugrave; interessanti per
i nostri utenti).</LI>
<LI>Nella seconda regola, &egrave; fondamentale fare in modo che i pacchetti abbiano
come mittente uno degli indirizzi ip esterni del firewall. Per chi si
accontenta di poche parole, basti dire che in caso contrario non funzionerebbe.
Per tutti gli altri, invece, il motivo sta nell'arp, address resolution protocol.
Ovvero, se l'indirizzo ip non fosse uno di quelli del firewall (aggiunti con
ip o ifconfig, per intenderci), il firewall
non risponderebbe alle query ARP, ed i pacchetti uscirebbero felici dalla
rete ma il gateway di default del nostro firewall non sarebbe in grado
di rimandare i pacchetti indietro. Come sempre, linux lascia la massima 
libert&agrave;: sta all'amministratore evitare di farsi male con errori di questo
tipo.</LI>
<LI>Riferendosi al funzionamento del SNAT come prima descritto, a volte (in 
reti particolarmente affollate) potrebbe essere indispensabile utilizzare
pi&ugrave; indirizzi ip per effettuare lo SNAT (il numero di porte disponibili
ed utilizzabili su un host per fare il giochettino descritto &egrave; abbastanza limitato).
Il target fortunatamente consente di indicare pi&ugrave; indirizzi ip (date un'occhiata
al manuale di iptables).
<P> L'esperienza per&ograve; mi insegna che in tali reti si
supererebbe molto prima il numero massimo di connessioni tracciabili rispetto alle porte
disponibili. Per aumentare questo numero, basta dare un:
<BLOCKQUOTE><CODE>
<PRE>
  echo 16384 &gt; /proc/sys/net/ipv4/ip_conntrack_max
</PRE>
</CODE></BLOCKQUOTE>

o, in maniera del tutto equivalente, scrivere qualcosa come
<BLOCKQUOTE><CODE>
<PRE>
net.ipv4.ip_conntrack_max=16384
</PRE>
</CODE></BLOCKQUOTE>

nel file /etc/sysctl.conf.
Comunque sia, tenete presente che gi&agrave; una rete di 100-200 computer potrebbe
aver bisogno di essere in grado di tracciare pi&ugrave; connessioni, mentre non 
mi &egrave; ancora capitato di dover utilizzare pi&ugrave; di un indirizzo ip in uscita.</P>
<P>Il kernel comunque, vi avviser&agrave; in caso fosse necessario aumentare questi
limiti, con un messaggio nei log per ogni connessione scartata.</P>
</LI>
<LI>Nell'ultima regola, infine, se avessimo avuto a disposizione una connessione
dial-up (come isdn) o tramite adsl con indirizzi ip assegnati dinamicamente,
si sarebbe dovuto usare come target ``MASQUERADE'', senza per&ograve; specificare
alcun indirizzo ip sorgente. Attenzione! Lo SNAT proprio non funziona su
interfacce con ip dinamici assegnati! Potete vedere un esempio di come utilizzare
il target MASQUERADE in uno dei paragrafi introduttivi...</LI>
<LI>Per quanto riguarda le regole di NAT e filtraggio, &egrave; fondamentale notare
(per poter ottenere un firewall funzionante) che le <B>regole di firewalling, inserite 
nella tabella di filter, vedranno i pacchetti con i loro indirizzi reali</B>. Nel
caso di DNAT, per esempio, il filtro vedr&agrave; pacchetti con la destinazione
modificata (in questo caso, il proxy server). In caso invece di SNAT, il filtro
vedr&agrave; come mittente l'indirizzo reale del mittente (non quello modificato),
come se il codice di filtraggio fosse inserito dopo la catena di PREROUTING ma
prima della catena di POSTROUTING.</LI>
</UL>

Volendo fare il giochettino con il DNS, le due possibilit&agrave; sono realizzabili
utilizzando o queste regole:
<BLOCKQUOTE><CODE>
<PRE>
80: iptables -t nat -A PREROUTING -p tcp --dport domain -j DNAT --to nostro.dns
81: iptables -t nat -A PREROUTING -p udp --dport domain -j DNAT --to nostro.dns
</PRE>
</CODE></BLOCKQUOTE>

che deviano tutto il traffico verso un qualsiasi dns su nostro.dns,
o queste altre, che similmente intercettano il traffico verso un dns 
da noi specificato e deviano il traffico verso il nostro dns reale:
<BLOCKQUOTE><CODE>
<PRE>
83: iptables -t nat -A PREROUTING -p tcp -d un.dns --dport domain -j DNAT --to nostro.dns
84: iptables -t nat -A PREROUTING -p udp -d un.dns --dport domain -j DNAT --to nostro.dns
</PRE>
</CODE></BLOCKQUOTE>

A questo punto, non vi rimane che divertirvi con i pacchetti che fluiscono dalle
vostre reti...</P>

<H2><A NAME="s10">10.</A> <A HREF="#toc10">Mettere tutto insieme</A></H2>

<P>Ok, abbiamo visto come configurare dei filtri ed il NAT. Mancano per&ograve; ancora
un paio di cosettine di cui sarebbe il caso di parlare.</P>
<P>Prima di tutto, soprattutto quando staremo correggendo gli errori nelle nostre regole,
caricheremo e ricaricheremo il nostro script finch&eacute; non vedremo queste regole
funzionare (molte volte). Il fatto &egrave; che creando delle catene, non chiediamo
di svuotarle nel caso queste esistano gi&agrave;, per cui continueremmo ad aggiungere
regole su regole, non semplificandoci affatto la correzione degli errori.</P>
<P>Potreste quindi voler aggiungere qualcosa come:
<BLOCKQUOTE><CODE>
<PRE>
for table in nat mangle filter
do
   iptables -t $table -F
   iptables -t $table -X
done
</PRE>
</CODE></BLOCKQUOTE>

all'inizio del vostro script... che elimina tutte le catene e tutte le regole inserite
in ogni tabella. Allo stesso modo, potreste voler aggiungere qualcosa come 
<BLOCKQUOTE><CODE>
<PRE>
(
for interface in eth0 eth1 eth2 eth3
do
  ip route flush dev $interface
  ip addr flush dev $interface
  ip link set down dev $interface
done;
) &amp;>/dev/null
</PRE>
</CODE></BLOCKQUOTE>

Sempre all'inizio del nostro script, per riportare tutte le interfacce e le impostazioni
ad uno stato conosciuto, in modo che non si vadano in continuazione ad aggiungere route
o indirizzi, che, aggiunti per ultimi, verrebbero ignorati in favore di vecchie configurazioni
che si combinerebbero e mischierebbero in maniera poco prevedibile. Comunque, ``ip route flush dev ethx''
elimina tutti i route relativi ad ethx, ``ip addr flush'' elimina tutti gli indirizzi dell'interfaccia
ed infine ``ip link set down'' spegnere la scheda di rete.</P>
<P>Infine, dobbiamo attivare le nostre interfacce di rete, configurare la tabella di routing ed abilitare
il ``forwarding'', dicendo al kernel di iniziare a trasmettere i pacchetti da una scheda di rete all'altra:
<BLOCKQUOTE><CODE>
<PRE>
86: ip link set up dev eth0
87: ip link set up dev eth1
88: ip link set up dev eth2

89: ip route add default via 123.45.68.254

90: echo 1 > /proc/sys/net/ipv4/ip_forward
</PRE>
</CODE></BLOCKQUOTE>

In questo caso, ip_forward non pu&ograve; essere aggiunto al file
sysctl.conf, in quanto vogliamo che il forwarding venga attivato
solo dopo che abbiamo impostato correttamente le regole di firewalling.</P>

<P>Non ci resta quindi che creare in /etc/rcS.d/ o rc2.d (a secondo della
distribuzione) un link al file appena completato, in modo che questo venga 
eseguito ad ogni reboot, con qualcosa come ``ln -s ../init.d/ifconffw ./S40ifconffw''
oppure ``update-rc.d ifconffw start 40 S'' in Debian. </P>


<H2><A NAME="ss10.1">10.1</A> <A HREF="#toc10.1">Configurazione dei client</A>
</H2>

<P>Se il firewall ha un indirizzo ip diverso per ogni interfaccia ed utilizza
come gateway il gateway fornito dal vostro provider, i vostri client
dovranno utilizzare come gateway, come cancello che gli permetta di 
connettersi ad altre reti, l'indirizzo ip del vostro firewall relativo
alla rete cui il vostro client &egrave; collegato.</P>
<P>Un server collegato alla dmz dovr&agrave; quindi utilizzare come 
gateway l'indirizzo ip della vostra interfaccia collegata alla DMZ. Allo
stesso modo un client collegato alla LAN dovr&agrave; utilizzare come
gateway l'indirizzo ip dell'interfaccia collegata alla lan. Per
il resto, la configurazione dei client dipender&agrave; principalmente
dai server presenti (proxy, socks...) e dai giochini che avrete deciso
di fare col NAT.</P>

<H2><A NAME="s11">11.</A> <A HREF="#toc11">Modifiche on the fly - iptables da riga di comando</A></H2>

<P>Sebbene sia veramente poco piacevole, &egrave; possibile utilizzare 
iptables direttamente da riga di comando. </P>
<P>Nonostante questo, alcune di queste funzioni possono  risultare molto utili 
in fase di testing. Ad esempio, dovendo
fare delle misure di banda pu&ograve; essere utile consentire temporaneamente
solo il traffico tra determinate macchine, e non  &egrave; il caso di 
perdere tempo a modificare file di configurazione o script dalla
provata affidabilit&agrave;. Ok, iniziamo quindi col vedere le 
regole attive sul kernel da me correntemente utilizzate, col
comando ``iptables -nL'', dove ``n'' dice di non risolvere i nomi (passando
da indirizzi ip a nomi di domini) e ``L'' di ``listare'' o elencare (in italiano)
tutte le regole:
<BLOCKQUOTE><CODE>
<PRE>
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
</PRE>
</CODE></BLOCKQUOTE>

-n lo uso principalmente perch&eacute; altrimenti ci metterebbe molto tempo
a generare l'output (tentando di connettersi al database), per il resto,
credo che l'output in se stesso credo che risulti abbastanza autoesplicativo...
un problema di ``iptables -nL'' (rispetto ad usare un file di configurazione) 
&egrave; che molti dettagli non vengono mostrati e comunque la leggibilit&agrave;
&egrave; molto minore.</P>
<P>Per avere pi&ugrave; dettagli, comunque, &egrave; possibile utilizzare l'opzione ``-v'' o ``-vv'',
con un comando simile a ``iptables -v -nL'':
<BLOCKQUOTE><CODE>
<PRE>
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
41512   83M ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0          
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
    0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 41513 packets, 83M bytes)
 pkts bytes target     prot opt in     out     source               destination         
</PRE>
</CODE></BLOCKQUOTE>

ancora, l'output &egrave; abbastanza autoesplicativo. Se state leggendo
il pdf notate per&ograve; come le righe vengono troncate. Immaginate su
un terminale con le classiche 80 colonne cosa verrebbe fuori.</P>
<P>Se siete interessati ad un'unica catena, potete specificarne il 
nome dopo il ``-nL''. Con qualcosa di simile a ``iptables -vv -nL INPUT''
vedreste solo la catena di ``INPUT'' ed un dump delle informazioni del kernel. 
Come altre
opzioni generiche, potete utilizzare ``-x'', che mostrer&agrave;
i valori esatti dei contatori, mentre ``-Z'' li azzerer&agrave;, oppure ``-t nometabella''
per visualizzare altre tabelle.</P>

<H2><A NAME="ss11.1">11.1</A> <A HREF="#toc11.1">Manipolare le catene</A>
</H2>

<P>Gi&agrave; conosciamo i parametri:
<UL>
<LI><I>-N</I> -- per creare nuove catene</LI>
<LI><I>-X</I> -- per eliminare una catena (tutte, se non viene specificato un argomento)</LI>
<LI><I>-F</I> -- per eliminare tutte le regole di una catena (tutte, se non viene specificato
un argomento)</LI>
<LI><I>-A</I> -- per aggiungere regole alle catene</LI>
<LI><I>-P</I> -- per impostare le politiche</LI>
</UL>

In pi&ugrave;, vi possono tornare utili i comandi
<UL>
<LI><I>-I</I> -- per inserire una nuova regola
in una determinata posizione di una catena</LI>
<LI><I>-R</I> -- per sostituire una regola con un'altra</LI>
<LI><I>-D</I> -- per rimuovere una regola</LI>
</UL>

Cerchiamo per&ograve; di vedere questi parametri nella pratica. Ipotizzando
di avere una situazione come quella mostrata sopra con 
``iptables -nL'', immaginiamo di voler inserire una regola 
dopo quella relativa ad ssh (catena di INPUT, porta 22, riga 2) per consentire
l'accesso ad un web server installato sul mio portatile.
In questo caso, potremmo dare un comando come
<BLOCKQUOTE><CODE>
<PRE>
iptables -I INPUT 3 -p tcp --dport 80 -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

Il 3 indica che questa regola deve essere inserita nella
terza riga, spostando tutte le altre righe pi&ugrave; in basso.
Dopo questo comando, ``iptables -nL INPUT'' mostrerebbe qualcosa come
<BLOCKQUOTE><CODE>
<PRE>
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:80 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 
</PRE>
</CODE></BLOCKQUOTE>

proprio come volevamo. Immaginiamo ora di spostare il web server sulla porta 443,
e di voler rimpiazzare la regola appena inserita con qualcosa come ``-p tcp --dport 443
-j ACCEPT''. In questo caso sarebbe sufficiente utilizzare
<BLOCKQUOTE><CODE>
<PRE>
iptables -R INPUT 3 -p tcp --dport 443 -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

per ottenere qualcosa come
<BLOCKQUOTE><CODE>
<PRE>
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:443 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 
</PRE>
</CODE></BLOCKQUOTE>

Infine, per rimuovere la regola, basterebbe qualcosa come 
<BLOCKQUOTE><CODE>
<PRE>
iptables -D INPUT 3
</PRE>
</CODE></BLOCKQUOTE>

Se siete meno pigri di me, potete utilizzare anche
<BLOCKQUOTE><CODE>
<PRE>
iptables -D INPUT -p tcp --dport 443 -j ACCEPT
</PRE>
</CODE></BLOCKQUOTE>

che porterebbe esattamente allo stesso risultato.</P>

<H2><A NAME="ss11.2">11.2</A> <A HREF="#toc11.2">Salvare le modifiche</A>
</H2>

<P>Versioni relativamente recenti di iptables mettono anche a disposizione due
tools: iptables-save ed iptables-restore. Il primo, stampa a video in un
formato standard tutte le regole di firewalling, mentre il secondo &egrave;
in grado di leggere delle regole in questo formato standard da standard 
input e di impostarle nel kernel. Ad esempio, per salvare delle regole
correntemente utilizzate dal kernel, &egrave; possibile utilizzare il
comando:
<BLOCKQUOTE><CODE>
<PRE>
  # iptables-save &gt; nomefile
</PRE>
</CODE></BLOCKQUOTE>

mentre per ripristinarle il comando
<BLOCKQUOTE><CODE>
<PRE>
  # iptables-restore &lt; nomefile
</PRE>
</CODE></BLOCKQUOTE>

In Debian, &egrave; possibile utilizzare ``/etc/init.d/iptables save nomefile''
oppure ``/etc/init.d/iptables load nomefile''. Utilizzando come nomefile ``active'',
le regole verranno automaticamente caricate ad ogni accensione della macchina.
In quest'ultimo caso, potreste voler dare un'occhiata a /etc/default/iptables.</P>




<H2><A NAME="s12">12.</A> <A HREF="#toc12">Conclusioni</A></H2>

<P>Le funzioni viste qua sopra non costituiscono probabilmente neanche
il 25% di tutto ci&ograve; che il kernel 2.4 pu&ograve; fare. Mi basti
ricordarvi che delle tre tabelle a disposizione ne abbiamo utilizzate
soltanto 2 e che molte delle nuove funzionalit&agrave; sono state soltanto
accennate, senza dimenticare poi che nulla &egrave; stato visto in proposito
del QoS e del fair queuing. Giusto per stuzzicare la vostra curiosit&agrave;,
la tabella di mangle serve per ``maneggiare'' i pacchetti in maniera
pi&ugrave; sottile, in modo che comandi come ip e tc possano interagire
tra di loro distinguendo pacchetti scelti da iptables o per modificare
i parametri del pacchetto (modulo ttl &amp; co.).  </P>
<P>Giusto per fare un accenno, il fair queuing si gestisce attraverso
il comando tc, e consente di suddividere tutti i pacchetti in transito
in classi, dove ogni classe pu&ograve; avere una certa larghezza di banda
riservata o una certa priorit&agrave;. Si potrebbe poi parlare di funzioni
come il proxy_arp, che in combinazione con il modulo ttl consentono
di creare dei firewall (praticamente) invisibili.</P>
</BODY>
</HTML>
