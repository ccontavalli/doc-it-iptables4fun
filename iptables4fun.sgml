<!doctype linuxdoc system>

<article>
<title>
IPtables for Fun -- Implementare un firewall in linux
</title>
<author>
Carlo Contavalli -- Copyright &copy; 2000-2003
</author>

<date>
$Revision: 1.12 $ -- $Date: 2003/07/29 3:12:46 $
</date>

<abstract>
Col passare del tempo, Linux sta diventando una piattaforma
sempre pi&ugrave; utilizzata nel mondo di internet. 
Con il maggior numero di utenti e con l&apos;interesse
suscitato ultimamente, le sue potenzialit&agrave; come 
server di rete sono cresciute in maniera esponenziale. 
In particolare, il kernel Linux 2.4.x offre strumenti
 estremamente potenti e flessibili per la realizzazione di 
 firewall avanzati. Questo documento si propone come scopo 
 quello di introdurre gli utenti alla configurazione di linux 
 come firewall utilizzando tutti gli strumenti più recenti 
 messi a disposizione. L'ultima versione di questo documento può essere reperita
 in vari formati su <url url="https://github.com/ccontavalli/doc-it-iptables4fun">
</abstract>

<toc>

<sect>Copyright e note legali...<p>
Copyright &copy; 2000-2003 Carlo Contavalli.<p>

è garantito il permesso di copiare, distribuire e/o modificare
questo documento seguendo i termini indicati dalla Licenza per
Documentazione Libera GNU (GNU Free Documentation License -- FDL) 
in lingua originale, Versione 1.1 o ogni versione
successiva come pubblicata dalla Free Software Foundation; senza 
Sezioni Non Modificabili (Invariant Sections), senza Testi
Copertina (Front-Cover Texts), e senza Testi di Retro Copertina (Back-Cover Texts).  Una
copia della licenza in lingua originale pu&ograve; essere reperita all'indirizzo
<url url="http://www.gnu.org/copyleft/fdl.html"> oppure
contattando l'autore tramite email.<p>
Ogni esempio di codice fornito in questo documento deve essere considerato
protetto secondo i termini indicati dalla GNU General Public License 
in lingua originale. Una copia di questa licenza pu&ograve; essere
reperita all'indirizzo <url url="http://www.gnu.org/copyleft/gpl.html">
oppure ottenuta tramite posta ordinaria scrivendo a:
Free Software Foundation, Inc., 59 Temple Place, Suite 330,
MA 02111-1307, USA. <p>Per ogni eventuale chiarimento o per maggiori
dettagli potete contattare l'autore all'indirizzo di posta elettronica
&lt;ccontavalli at gmail.com&gt;.<p>
Una versione aggiornata e completa di questo documento potrà essere reperita su
<url url="https://github.com/ccontavalli/doc-it-iptables4fun"> in diversi formati.
<p><p>

Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.1 or any later version 
published by the Free Software Foundation; with no Invariant Sections, with no
Front-Cover Texts, and with no Back-Cover Texts. A copy of the license
can be found at <url url="http://www.gnu.org/copyleft/fdl.html"> or
contacting the author by email. <p>
Any example of code provided in this document should be considered
protected under the terms of the GNU General Public License. A copy
of this license can be found at <url url="http://www.gnu.org/copyleft/gpl.html">
or writing
to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,
MA 02111-1307, USA.<p>
You can contact the author of this document by email at 
&lt;ccontavalli at gmail.com&gt; to obtain more details or
information about this document and its license.<p>
An updated version of this document can be found on
<url url="https://github.com/ccontavalli/doc-it-iptables4fun"> in
different formats.

<sect>Prima di cominciare<p>
Questa che state leggendo è la seconda versione (precisamente, $Revision: 1.12 $) di un 
documento che scrissi parecchio tempo fa, agli albori del kernel 2.4. 
Da allora, diverse versioni del kernel sono state rilasciate e nuove funzionalit&agrave;
sono state lentamente introdotte. Troverete quindi notevoli differenze tra questa
versione e le versioni precedenti, sia in termini di contenuto tecnico sia in termini
di linguaggio utilizzato. <p>
Nelle versioni dalla 1.9 in poi, inoltre, il nome di questo tutorial &egrave; 
stato cambiato da ``Iptables for Dummies'' a ``Iptables for Fun'', al fine di sottolineare
l'estraneit&agrave; dello stesso dalla serie ``for dummies'' pubblicata in libreria
e di evitare problemi che si sarebbero potuti venire a creare in relazione a 
marchi, trademark o diritti della ``Hungry Minds'', diritti che non intendo in 
alcun modo violare.<p>
A questo proposito, vorrei ringraziare alcuni lettori per aver segnalato 
il problema.<p>
Spero che questo documento possa esservi utile e sarei felice di
ricevere commenti, domande o richieste di chiarimenti (nonch&egrave;
qualche invito a bere una birra in compagnia :-) al mio indirizzo 
di posta elettronica &lt;ccontavalli at gmail.com&gt;...<p>
Devo inoltre ringraziare tutti coloro che mi hanno scritto
aiutandomi a capire quali parti potevano essere di maggiore 
interesse, quali potevano essere migliorate o segnalando errori
che spero ora aver corretto, o semplicemente incoraggiandomi 
nell'andare avanti, contribuendo a migliorare il documento
che anche voi state leggendo.<p>
Mi scuso se qualche volta non ho avuto il tempo di 
rispondere alle vostre email o se non sono sempre stato in grado 
di esservi di aiuto.<p>
Purtroppo (pi&ugrave; che altro per me), non riesco a dedicare a 
questo tutorial il tempo di cui avrebbe bisogno e le nuove sezioni 
su cui (ormai da mesi) sto lavorando verranno introdotte sempre
pi&ugrave; lentamente, quasi tanto quanto le correzioni che
gentilmente mi avente inviato.<p>
<!--
Per questo ed altri motivi, e per aiutare voi ad aiutare me,
ho aperto una mailing list, disponbile all'indirizzo: 
<url url="http://ml.masobit.net/ccontavalli/docs-it/">.<p>
-->
Comunque sia, versioni aggiornate di questo documento potranno 
essere reperite su <url url="https://github.com/ccontavalli/doc-it-iptables4fun">.<p>
Inoltre, nel corso di questo tutorial, quando si parlerà di IP e di protocolli di 
rete (se non esplicitamente indicato) mi riferirò alla versione 4 del 
protocollo IP (aka, IPv4).<p>
Infine, se non vi interessa nulla di iptables, iproute, del kernel 2.4 e di tutte le funzioni
avanzate messe a disposizione e volete proteggere semplicemente il vostro computer
o la vostra piccola lan, potete limitarvi a digitare da riga di comando, come utente ``root'',
qualcosa di simle a:
<tscreen><verb>
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</verb></tscreen>
ed eventualmente:
<tscreen><verb>
iptables -A FORWARD -s ip_rete_interna/24 -j ACCEPT
iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -t nat -A POSTROUTING -s nostrareteinterna/24 -j MASQUERADE
echo 1 > /proc/sys/net/ipv4/ip_forward
</verb></tscreen>
dove <it/ip_rete_interna/ pu&ograve;, per esempio, essere sostituito con 10.0.0.0 
o 192.168.0.0. Con queste ultime regole, consentirete ai computer della vostra 
rete che avranno impostato come gateway l'indirizzo ip del vostro firewall di
condividere la connessione ADSL, ISDN o il vostro modem 56k (se siete
abbastanza coraggiosi) ad esso collegati.

<!--
<sect1>Versioni future di questo documento<p>
Molte nuove sezioni sono attualmente ``under construction'' e spero che a 
poco a poco verranno rese disponibili. Vi do qui una piccola anteprima, in modo
che se voleste contribuire o dare qualche sbirciatina prima del rilascio ufficiale
possiate farlo mandandomi semplicemente una mail:
<itemize>
  <item>Nozioni di base sui protocolli di rete<p>
        Solita introduzione al TCP/IP. Questo soprattutto perch&eacute; non ha senso parlare di
	regole di firewalling senza avere per lo meno una minima idea sul funzionamento
	delle reti a commutazione di pacchetto (85% completa).
  <item>Debugging delle regole di firewalling, ovvero come individuare l'origine di problemi di rete<p>
  	Questa sezione mi sta particolarmente a cuore, e mi piacerebbe dare una procedura abbastanza
	generica stile flowchart per l'individuazione e correzione dei problemi, con una o due
	sezioni su come decifrare l'output di tcpdump (40% completa).
  <item>Regole di firewalling per eliminare i pi&uacute; comuni tipi di attacchi in rete<p> 
  	Dove parlare, tra l'altro, dell'efficacia di alcuni tipi di regole di firewalling
	e su come riconoscere (in automatico) e bloccare alcuni tipi di attacco (33% completa).
  <item>Creare firewall trasparenti con il proxy arp (20% completa).
  <item>Una piccola introduzione al traffic shaping e all'utilizzo di tc (5% completa).
</itemize>
-->

<sect1>Ringraziamenti<p>
Non c'&egrave; dubbio che per il tempo che mi hanno dedicato o per l'aiuto
che mi &egrave; stato dato (anche solo inviandomi commenti o incoraggiandomi
nell'andare avanti), debba
ringraziare:<p>
Andrea Ciancone, Guido Caruso, Gianluca D'inc&agrave;, Giovanni Bassetto, 
Gabriele Biarese, Matteo Nastasi, Gianluca, Tony Arcucci, BlueRaven
<p>
e tutti gli amici del linux_var <url url="http://www.linuxvar.it">,
nonch&eacute; coloro che ho dimenticato di citare in questa lista
(mandatemi una mail!).<p>

<sect>Nozioni di base sui firewall<p>
Prima di entrare nel cuore della trattazione, conviene fare una 
piccola introduzione. Se gi&agrave; sapete cos'&egrave; un firewall
e avete una discreta idea di come funzioni una rete, potete saltare
senza troppi rimpianti questa sezione. Se invece non avete le 
idee tanto chiare o se per la prima volta vi trovate ad affrontare
problematiche di questo tipo, vi consiglio di continuare...<p>
Comunque sia, partendo da zero, un firewall linux non &egrave; 
altro che un semplice personal computer normalmente collegato 
fisicamente (con dei cavi) a pi&ugrave; di una rete. <p>
Un firewall avr&agrave; quindi installata una scheda di rete (interfaccia)
per ogni rete cui sar&agrave; collegato. Inoltre, dovr&agrave;
costituire l'unico punto di contatto tra le reti cui &egrave; connesso.<p>
Per spiegarmi meglio, un firewall dovr&agrave; costituire l'unico punto 
di collegamento tra due o pi&ugrave; reti. Un po' come un ponte che 
collega due o pi&ugrave; isole. 
Senza entrare nei dettagli del protocollo ip, tutte le comunicazioni 
tra queste reti saranno quindi costrette a passare da questo computer.<p>
Questo computer, una volta configurato come firewall, sar&agrave; in
grado di decidere cosa far passare, cosa scartare o come reagire a 
determinati eventi. Tornando all'esempio del nostro ponte, configurare
il computer come firewall pu&ograve; essere considerato equivalente
a mettere una stanga e 2 finanzieri che controllano tutti i veicoli
e le persone in transito. Questi 2 finanzieri saranno quindi in grado
di agire secondo le istruzioni che gli verranno date dal ministero, 
bloccando veicoli, arrestando i contrabbandieri o sparando a vista
ai ricercati.<p>
In linux, la stanga e i finanzieri sono messi a disposizione direttamente
dal kernel. Per controllare il kernel, per dare cio&egrave; le direttive
ai finanzieri, vengono messi a disposizione diversi comandi: con il
kernel 2.4, i principali e pi&ugrave; avanzati sono comunque il 
comando ``ip'', ``tc'' e ``iptables'', i primi due inclusi nel
pacchetto ``iproute'' mentre il terzo distribuito indipendentemente.<p>
Procedendo con ordine, in linea di principio il comando ``ip'' vi consente di creare nuove isole
e nuovi ponti, di gestire quindi le tabelle di routing e le interfacce di
rete, il comando iptables di istruire i finanzieri dicendo
cosa far passare e cosa non far passare o come reagire a determinate
condizioni, consente cio&egrave; di creare dei filtri. Infine, il 
comando tc, vi consente di stabilire delle priorit&agrave; e dei
limiti sul traffico in ingresso ed in uscita. Ad esempio, un compito
che esula dal filtraggio e che quindi riguarda tc potrebbe essere quello
di riservare alcune corsie al passaggio di veicoli di emergenza o
di servizio, limitando magari il traffico automobilistico, di 
riservare cio&egrave; determinate quantit&agrave; di banda a
determinate tipologie di traffico. <p>
Riassumendo, quindi, si parler&agrave; del comando 
<itemize>
  <item>ip -- per configurare, attivare, disattivare o creare
  	      interfacce di rete, nonch&eacute; per gestire
	      le tabelle di routing (da solo rimpiazza
	      i comandi ifconfig, route e arp).
  <item>iptables -- per bloccare, consentire o registrare
  		il traffico, per effettuare cio&egrave; 
		firewalling, ovvero per modificare
		alcune caratteristiche dei pacchetti in transito,
		per effettuare cio&egrave; NAT (Network Address
		Translation).
  <item>tc -- per assegnare delle priorit&agrave;, imporre
  		delle precedenze o dei limiti di banda (tc
		sta per ``traffic classifier''), in poche
		parole, per effettuare dello shaping.
</itemize>
In questo documento si parler&agrave; prevalentemente del comando iptables.

<sect1>Tipologie di firewall<p>
Adesso che abbiamo detto cos'&egrave; e a cosa serve un firewall, &egrave;
importante parlare un pochettino delle tipologie di firewall che esistono
sul mercato.<p>
Questa non vuole essere n&eacute; una trattazione completa n&eacute; ``esatta''
dal punto di vista tecnico. Lo scopo &egrave; semplicemente quello di introdurre
il lettore alla terminologia utilizzata normalmente parlando di firewall e di 
dare una breve panoramica sulle soluzioni disponibile per la configurazione, gestione
e amministrazione delle reti.<p>

<sect2>Firewall stateless e firewall statefull<p>
Prima di tutto, esistono firewall che vengono classificati come ``stateless''
ed altri che vengono chiamati ``statefull''. La differenza &egrave; abbastanza
importante: firewall stateless prendono la decisione di bloccare o consentire
una comunicazione soltanto sulla base delle caratteristiche della comunicazione
stessa. Al contrario, firewall statefull sono in grado di riconoscere le connessioni
e le trasmissioni, e, tenendone traccia, sono in grado di prendere decisioni in
base ad altri parametri. Rifacendomi sempre all'esempio dei finanzieri, un finanziere
``stateless'' potr&agrave; bloccare o consentire un autoveicolo soltanto in base
a caratteristiche come il numero di targa, il tipo di veicolo o il numero di passeggeri.
Al contrario, un finanziere ``statefull'' sar&agrave; in grado di valutare caratteristiche
come il numero di volte che un veicolo &egrave; passato, se fa parte di una comitiva
di altri veicoli, piuttosto che se il veicolo dovr&agrave; fare altri viaggi per svolgere
le sue mansioni. Non &egrave; proprio l'esempio migliore, ma credo che possa rendere 
bene l'idea. Parlando invece con un linguaggio pi&ugrave; ``tecnico'', un firewall stateless
conosce solo il concetto di pacchetto singolo, mentre un firewall statefull &egrave; in
grado di riconoscere le connessioni e perfino alcuni protocolli. Firewall creati con
il vecchio comando ``ipchains'' vengono considerati stateless, mentre quelli creati con 
``iptables'' possono essere statefull.<p>

<sect2>Firewall e protocolli<p>
I firewall possono essere poi classificati a secondo del ``livello'' (termine non strettamente 
corretto) a cui lavorano:
<itemize>
  <item>Quelli che si intendono normalmente per firewall, lavorano solitamente al livello del protocollo
        ip o del protocollo tcp, filtrando il traffico in base al contenuto di queste intestazioni.
	Per esempio, sono in grado di filtrare il traffico in base all'indirizzo ip del mittente di un 
	pacchetto, di destinazione o in base al protocollo utilizzato (dove per protocollo si intende
	la porta tcp o udp). Normalmente, un firewall di questo tipo &egrave; impostato
	come gateway delle reti cui &egrave; collegato.
  <item>Firewall ``trasparenti'' lavorano invece ad un livello pi&ugrave; basso
  	del protocollo ip, molto vicino all'hardware, per cui vengono normalmente
	inseriti tra una rete e l'altra ma non devono essere impostati come gateway, non
 	essendo visibili al livello del protocollo ip	(&egrave; questo il motivo per cui 
	vengono detti trasparenti - non sono visibili,
	e i client non devono essere configurati per usare il gateway).<p>
	In linux, &egrave; possibile ottenere un firewall quasi trasparente 
	utilizzando funzioni come il ``proxy arp'' in combinazione con qualche 
	regola di iptables per modificare i pacchetti, oppure utilizzando il 
	codice di ``bridging'' sempre in combinazione
	con ``iptables''. Attenzione per&ograve; che attualmente il codice di 
	bridging non &egrave; in grado di lavorare in coppia con iptables, a
	meno che non usiate un kernel sperimentale versione dal 2.5.45 in su 
	o alcune patch disponibili su internet.
  <item>Esistono poi firewall che lavorano a livelli pi&ugrave; alti dell'ip, in 
  	grado ad esempio di censurare informazioni fornite con i vari protocolli o
	di consentire l'accesso solo a quegli url raggiungibili tramite link nelle
	pagine visitate.
</itemize>
Parlando poi di reti e di filtraggio, capita spesso che il discorso cada su proxy server 
e socks server. 

<sect2>Proxy server<p>
Quando utilizzate un proxy server in
rete (avete presente i parametri di configurazione di Internet Explorer o Mozilla?)
il vostro browser non si collegher&agrave; direttamente al sito relativo alla pagina da voi richiesta, 
bens&igrave; si collegher&agrave; al proxy richiedendo tale pagina. Il proxy, in vece dei client,
si prodigher&agrave; per fornire questa pagina scaricandola da internet o leggendola
dalla sua cache. In pratica, un proxy server non &egrave; altro che un software che tiene
una memoria (cache) delle pagine visitate di recente, mettendo tale memoria a disposizione
di tutti gli utenti collegati ad una rete il cui browser &egrave; configurato per utilizzare
tale cache. Questo pu&ograve; portare ad un risparmio di banda 
davvero notevole, soprattutto in quegli ambienti dove molte persone si collegano pi&ugrave; 
o meno agli stessi siti (e se lo spazio a disposizione per la cache &egrave; molto, 
sar&agrave; molto probabile che molti siti si trovino in cache).<p>
Oltre a consentirvi di risparmiare banda (una percentuale spesso rilevante di banda),
il vantaggio di utilizzare un proxy server &egrave; che vi consentono di creare
delle regole molto avanzate e di interagire facilmente con gli utenti. <p>
Con poche righe di configurazione per esempio, installando <it/squid/ e 
<it/squidGuard/ su una macchina linux &egrave; possibile filtrare le pagine 
web in base al contenuto, applicare delle espressioni regolari agli URL e redirigere 
gli utenti su particolari pagine in caso le politiche impostate vengano violate 
(cose estremamente difficili ed inefficienti da fare con un normale firewall). 
In pi&ugrave;, i delay pools di squid consentono una distribuzione abbastanza equa 
della banda e con l'appoggio di un semplice firewall, un proxy server pu&ograve; essere reso 
trasparente (transparent proxy): in questo caso non ci sar&agrave; bisogno di configurare 
tutti i computer connessi alla rete (client) per utilizzare il proxy e tutte le connessioni verranno
automaticamente deviate (redirette) sul proxy dal firewall. 

<sect2>Socks server<p>
Esiste poi un fratello povero dei proxy server, di cui vi ho accennato prima: il 
socks server. Questo, invece di fare da cache, &egrave; un software che si occupa
soltanto di applicare restrizioni imponendo dei limiti o dando privilegi
in base a regole stabilite dall'amministratore.<p>
Lo svantaggio principale di un socks server &egrave; che le applicazioni utilizzate
devono essere fatte apposta per parlare la ``lingua'' di quest'ultimo e che non 
pu&ograve; essere automaticamente imposto a tutti i computer di una rete (non si pu&ograve;
impostare un ``transparent socks server'').
Fortunatamente per&ograve;, la maggior parte delle applicazioni attualmente 
disponibili sono a conoscenza di questa lingua.<p>
Un buon motivo per utilizzare un socks server &egrave; che firewall statefull classici 
sono in grado di riconoscere e gestire soltanto i protocolli standard. 
Spesso capita quindi che protocolli inventati dai produttori di turno senza 
rispettare alcuno standard (o modificando gli standard a proprio piacimento) incontrino 
problemi non indifferenti. Configurando le applicazioni che fanno uso di questi protocolli
in modo da collegarsi tramite un socks server li si costringer&agrave; a parlare una ``lingua'' 
standard che consentir&agrave; al socks server di far funzionare anche i protocolli
pi&ugrave; strani.<p>
Normalmente quindi, utilizzando un firewall linux, a secondo delle esigenze degli utenti
della rete che andr&agrave; a proteggere, si potr&agrave; installere e configurare
anche un socks server per consentire a questi protocolli di funzionare. <p>
E' importante notare per&ograve; che i ``socks server'' in generale godono di una brutta 
fama per quanto concerne la sicurezza, non tanto perch&egrave; tutti i socks server
siano pericolosi, quanto perch&egrave; c'&egrave; stato un periodo storico nel quale
venivano preinstallati su determinati sistemi operativi senza 
imporre restrizione alcuna, consentendo ad utenti maliziosi di entrare nella vostra
rete o di fare cose non proprio piacevoli. <p>
Installando un socks server &egrave; quindi importante fare attenzione alle configurazioni
imponendo delle regole il pi&ugrave; possibile restrittive e cercando di evitare software 
notoriamente bacati. Ricordatevi infine che un socks server costituisce spesso l'unica 
alternativa per poter utilizzare alcuni programmi in rete, a meno di sviluppare un apposito 
modulo per il kernel.<p>

<!--
<sect>Introduzione ai protocolli di rete<p>
In questa sezione parlerò brevemente dei vari protocolli che popolano il mondo di internet,
delle tipologie di firewall e degli strumenti messi a disposizione per essere in grado di gestire 
in maniera efficiente il traffico di una rete. Se avete già configurato un firewall o se 
avete una discreta conoscenza di come funziona una rete TCP/IP, potete allegramente saltare
questa sezione e passare alla successiva senza alcun rimpianto. In caso contrario, questa sezione
vi darà le nozioni di base per poter per lo meno comprendere i paragrafi successivi.<p>

<sect1>Gli albori di Internet<p>
Come tutti voi saprete, lo studio di Internet iniziò nelle grandi università americane
con dei finanziamenti dell'ARPA, ovvero la Ad%TODO%.<p>
Scopo dell'ARPA era quello di riuscire ad ottenere una rete per la trasmissione dati che 
fosse affidabile, flessibile e che consentisse ad ogni tipo di computer di comunicare.<p>
Ovviamente, questo non fu un facile obiettivo da raggiungere e diverse persone lavorarono per
questo progetto. Alla fine per&oacute;, i loro sforzi furono premiati e riuscirono a raggiungere
dei risultati concreti:
<itemize>
  <item>la flessibilit&aacute; riuscirono ad ottenerla utilizzando la tecnica di trasmissione che all'epoca
  	venne battezzata a ``commutazione di pacchetto'' e strutturando l'architettura delle reti 
	in modo da poter delegare la gestione di parti di essa a terzi.
  <item>l'affidabilità riuscirono ad ottenerla sempre grazie alla commutazione di pacchetto che consent&iacute;
  	l'utilizzo di collegamenti ridondanti o alternativi per collegare le varie reti tra di loro.
  <item>l'interoperabilit&aacute; l'ottennero invece definendo degli standard più o meno aperti che 
  	fossero indipendenti sia dall'architettura dei sistemi utilizzati sia dall'hardware di 
	rete impiegato per connettere i computer.<p> 
</itemize>

<sect2>Commutazione di pacchetto<p>
Per prima cosa, nel paragrafo precedente, ho parlato di commutazione di pacchetto.<p>
L'idea di base anche in questo caso era molto semplice: per comunicare da un punto ad un
altro di una rete, invece di creare un circuito dedicato che collegasse i due punti (come avviene
con la rete telefonica), si pens&oacute; che era possibile inviare i dati ``impacchettandoli'' 
in tante piccole confezioni ognuna recante le informazioni indispensabili perch&eacute; questi
potessero essere correttamente consegnati, pur trasmettendoli su un canale potenzialmente utilizzato
da pi&uacute; utenti.<p>
In pratica, tutte le volte che si devono spedire dei dati su di una rete, questi vengono presi,
viene aggiunta una intestazione (o ``header''), e vengono tramutati in segnali elettrici piuttosto
che ottici ed inviati nel canale trasmissivo.<p>
Questa intestazione &egrave; essa stessa costituita da dati scritti in un formato standard che
devono essere interpretati in un determinato modo affinch&eacute; una comunicazione abbia luogo.<p>
L'insieme di questi standard viene quindi definito ``protocollo''.<p>
Dovendo fare un paragone, tutte le volte che dovete mandare una lettera a qualcuno, dovete prendere
una busta, chiuderci dentro il messaggio, e scrivere sulla busta stessa l'indirizzo del destinatario
e del mittente. In questo caso la busta costituisce l'header mentre lo standard utilizzato per scrivere
l'indirizzo e le regole che costituiscono le modalit&aacute; di consegna della lettera fanno parte del protocollo
di trasmissione dei dati.<p>

<sect2>Protocolli<p>
Il protocollo &egrave; quindi legato da una parte alle modalit&agrave; di trasmissione dei dati
e dall'altro allo standard utilizzato per scrivere gli indirizzi.<p>
Dovrebbe quindi essere abbastanza naturale pensare che ogni tipologia di hardware utilizzi un protocollo
diverso per la trasmissione dei dati. In effetti &egrave; proprio cos&igrave;.<p>
In ogni rete infatti, ogni computer &egrave; identificato da un indirizzo hardware
detto anche MAC address, dove, per esempio nelle reti ethernet, il MAC address &egrave; costituito da 
un numero a 48 bit che teoricamente identifica univocamente una macchina.<p>
Tutti i dati trasmessi su una rete ethernet sono quindi prefissati da un header contenente
il MAC address del mittente (detto anche sorgente) e il MAC address del destinatario (destinazione).<p>
Il problema che sorge a questo punto &egrave; come fare comunicare due reti che utilizzano
hardware differenti tra di loro. L'idea di base, ancora una volta, &egrave; estremamente semplice:
quelli che l'hardware di rete vede come dati, in realt&agrave; sono costituiti a loro volta
da un header seguito da altri dati, un po' come il gioco delle scatole cinesi, e se il primo
header dipende dalla tipologia di hardware utilizzato, il secondo header pu&ograve; dipendere
da un qualsiasi altro protocollo. Nelle reti TCP/IP, il secondo header &egrave; normalmente
un header del protocollo IP.

<sect1>Il protocollo IP<p>
Il protocollo IP è il protocollo principale alla base di internet. Per consentire che comunicazioni
avvengano tra tipologie di reti differenti, ad ogni macchina
connessa ad una rete IP viene assegnato un INDIRIZZO IP, un numero cioè a 32 bit che identifichi univocamente
la macchina e che non abbia nulla a che fare né con l'hardware utilizzato né con il sistema operativo utilizzato.
<p>Il protocollo IP divide poi tutte le macchine in reti e sottoreti, dove ogni rete, considerata
come unità atomica ed inscindibile, utilizza una qualche tecnologia per fare comunicare i computer tra di loro (ethernet,
piuttosto che token ring, piuttosto che ...). <p>
Prima però di scendere nel dettaglio del contenuto degli headers IP, è necessario parlare brevemente
di come gli indirizzi IP devono essere gestiti. Se infatti i MAC address vegono assegnati per caso 
(quando comprate in un negozio la schede di rete il MAC address &egrave; preassegnato), gli indirizzi 
IP sono assegnati con una certa logica proprio per semplificare quelle che definiremo le problematiche di routing, 
ovvero di instradamento dei pacchetti.<p>

<sect2>Indirizzi e netmask<p>
Come già detto prima, un indirizzo IP è un numero di 32 bit. Questo viene normalmente indicato come 
un insieme di 4 numeri separati da punti. Ognuno di questi 4 numeri rappresenta 8 bit (un ottetto) e 
può quindi avere un valore variabile tra 0 e 255 (2^8). Esempi di indirizzi ip possono essere 127.0.0.1, 
10.30.0.254 o 212.110.16.2. Un indirizzo ip non potrà quindi <bf/mai/ avere un valore come 10.30.0.312.<p>
Una rete viene invece identificata univocamente da un indirizzo ip 
ed una netmask. Una netmask indica qual'è la parte di un indirizzo ip che rimane ``uguale'' per tutte le macchine che 
si trovano su di una stessa rete. In pratica quindi, tutti i computer che si trovano su di una stessa rete
avranno una parte di indirizzo IP uguale, ed una parte variabile in grado di identificare ogni 
singolo host.<p>
La netmask o ``maschera del network'' tradotto in italiano, non è altro che un indirizzo IP che convertito
in cifre binarie ha un 1 per ogni cifra binaria che deve rimanere costante ed uno 0 per ogni cifra che può variare.
Tornando all'esempio di prima, se avessimo una rete costituita da tutti i computer con indirizzo IP 
da 10.30.0.0 a 10.30.0.255 (10.30.0.1, 10.30.0.2...), avremmo una netmask espressa in binario come 
11111111.11111111.11111111.00000000 (ricordatevi: ogni numero separato da punto rappresenta 8 bit, nel 
nostro esempio solo l'ultimo numero cambia, quindi solo gli ultimi 8 bit sono settati a 0 nella netmask)
ovvero come 255.255.255.0 (se non vi fidate, prendete una calcolatrice).<p>
Per sapere quanti computer possono essere collegati ad una determinata rete IP, è sufficiente quindi 
conoscere la netmask e contare quanti bit sono a 0. Nel nostro caso, abbiamo 8 bit a 0, quindi possiamo
utilizzare tutte le combinazioni di 8 bit che si calcolano con 2^8, ovvero 256 computer. In realtà, però,
per ragioni più o meno storiche, due indirizzi IP sono sempre riservati: il primo e l'ultimo di ogni
rete (nel nostro caso: 10.30.0.0 e 10.30.0.255). Il primo viene normalmente utilizzato per indicare
una rete nella sua globalità, mentre l'ultimo viene definito indirizzo di broadcast e serve per 
mandare dei dati a tutti i computer di una rete.<p>
Una netmask non deve però necessariamente avere sempre multipli di 8 bit a 0, per esempio, una 
valida netmask potrebbe essere 11111111.11111111.11111111.11110000 ed identificherebbe una rete
di 2^4 (16) computer e verrebbe indicata come 255.255.255.240, dividendo tutti i nostri indirizzi 
IP in blocchi di 16. Per esempio, sempre se avessimo il nostro computer con indirizzo 10.30.0.1 
ed una netmask di 255.255.255.240, questo sarebbe inserito in una rete con altri computer
con indirizzi che vanno da 10.30.0.0 a 10.30.0.15, dove sia 0 che 15 sono riservati. Notate però
che così facendo potremmo avere un'altra rete con indirizzi IP da 16 a 31 o con indirizzi IP 
da 32 a 47. In questo caso quindi, l'indirizzo di rete (il primo indirizzo di ogni rete) diventa
fondamentale per distinguere una rete dall'altra. Notate poi che più una rete diventa piccola 
più indirizzi vengono sprecati: ad una rete di 2 computer, per esempio (con solo l'ultimo
bit della netmask a 0) non si potrebbe attaccare alcun computer, essendo gli unici due IP a disposizione
quello di rete e quello di broadcast, mentre in una rete di 4 computer solo due indirizzi ip verrebbero
utilizzati. Se divideste quindi la vostra rete in tante piccole sottoreti di 4 computer, sprechereste
il 50% degli indirizzi IP tra indirizzi di broadcast ed indirizzi di rete.<p>
Esiste poi un'altra convenzione per indicare le netmask: invece di scriverle come un indirizzo IP, si
possono indicare con una ``/'' seguita dal numero di bit settati a 1. Tornando a prima, una netmask di
255.255.255.0 potrebbe essere indicata con un /24, mentre una netmask di 255.255.255.240 con un /28,
portandoci ad indicare gli indirizzi delle macchine prese ad esempio come 10.30.0.1/24 o 10.30.0.1/28.<p>

<sect2>Routing<p>
Ok, adesso che abbiamo parlato di come indicare una macchina e come identificare tutte le macchine
presenti su di una rete, vediamo come fisicamente avviene il processo di consegna dei pacchetti.<p>
Ogni macchina connessa ad una rete IP dovrà essere a conoscenza come minimo del suo indirizzo IP e
della sua netmask. Una volta al corrente di queste informazioni, sarà in grado di individuare tutti
gli altri computer presenti sulla sua stessa rete semplicemente guardando il suo indirizzo IP e quello
del destinatario.<p>
Se la macchina destinataria del pacchetto è sulla stessa rete, un processo che descriverò nella prossima
sezione prende luogo e la macchina avrà cura di consegnare direttamente il pacchetto al destinatario. 
Se la macchina, invece, non si trova sulla stessa rete, è necessario guardare (effettuare il ``lookup'') 
in quella che viene definita la tabella di routing (o di instradamento).<p>
Per quanto magica possa essere internet, infatti, perché due reti possano comunicare tra di loro è necessario
che ci sia quello che viene definito un router (quando si parla di apparecchio) o gateway (quando lo 
si descrive dal punto di vista logico e funzionale), ovvero una macchina connessa ad entrambe le reti (fisicamente
con due interfacce di rete)
in grado di consegnare i pacchetti sia su di una rete sia sull'altra (ossia, che abbia la conoscenza
dei protocolli hardware utilizzati su entrambe le reti).<p>
In pratica, quindi, la tabella di routing non è altro che un insieme di indirizzi di reti e di netmask 
seguite eventualmente dall'indirizzo IP di un gateway o dall'identificativo di una scheda di rete locale.<p>
In pratica, quindi, tutte le volte che deve essere spedito un pacchetto viene controllata ogni riga 
della tabella di routing alla ricerca di un entry (di una riga, ovvero di un route) che rappresenti la rete del destinatario.
Una volta trovata la riga corrispondente (semplicemente confrontando ip della rete e netmask) verrà o 
inviato il pacchetto direttamente, o inviato il pacchetto al gateway in grado di consegnare il pacchetto
sulla rete di destinazione. Fin qui non credo che ci siano grossi problemi...<p>
Il problema sta nel fatto che fisicamente non sarebbe possibile memorizzare tutti i route possibili in 
un computer normale (richiederebbe troppe risorse). La soluzione sta nell'inserire un route di default,
ovvero una riga nella tabella di routing che dica qualcosa del tipo ``tutte le volte che non sai a chi
mandare un pacchetto, mandalo al gateway x''. Coerentemente allo standard IP, il gateway di default lo
si indica come quel gateway che mette in comunicazione la rete locale con la rete 0.0.0.0/0, che rappresenta
tutti i computer facenti parte di internet (una netmask di 0 indica infatti che <bf/tutte/ le cifre possono
cambiare).<p>
Ovviamente, finché la rete è abbastanza semplice non sorgono problemi, quando invece è soggetta a frequenti
modifiche o i route iniziano a diventare tanti, la tabella di routing viene gestita automaticamente attraverso
altri protocolli come il RIP, il BGP o l'OSPF controllati normalmente da demoni (programmi
dedicati che di nascosto fanno quello che si dovrebbe fare a mano) di cui non parleremo in questo documento.<p>
Il gateway di default, poi, a sua volta sarà collegato ad alcune reti direttamente e a sua volta avrà un
gateway di default a cui verranno mandati i pacchettini destinati a delle reti non conosciute. Il processo 
di lookup nella tabella di routing andrà quindi avanti di gateway in gateway fintanto che non verrà scoperto
un path (percorso) conosciuto per raggiungere la rete di destinazione.<p>
Tornando al discorso del ``best effort'', ogni gateway tenterà di fare del suo meglio nel consegnare il
pacchettino, tenendo presente però che quello che fisicamente è un gateway spesso sarà costituito da una
qualche apparecchiatura appartenente a qualcun altro (non voi) che dovrà pagare sia per la 
manutenzione sia per la banda utilizzata. <p>
Questo processo, pur facendo ogni router del suo meglio, non è esente da errori e nei prossimi paragrafi 
vi descriverò come quelli più comuni vengano evitati.

<sect2>Header IP<p>
Ogni pacchettino spedito su di una rete,  come già detto, conterrà le informazioni necessarie per
l'hardware della determinata rete per consegnare quelle informazioni. Nelle reti IP, in aggiunta 
alle informazioni necessarie per l'hardware, dovranno essere scritte le informazioni necessarie 
per il protocollo IP. In particolare, l'header ip deve contenere (potete dare un occhiata a /usr/include/linux/ip.h per
maggiori dettagli e all'RFC 0791):
<itemize>
  <item>l'indirizzo ip del mittente (sorgente)
  <item>l'indirizzo ip del destinatario (destinazione)
  <item>alcune informazioni di base sul pacchetto (lunghezza effettiva dei
        dati trasmessi, lunghezza effettiva dell'header)
  <item>un checksum per verificare che non siano avvenuti errori di trasmissione
  <item>le informazioni sulla frammentazione
  <item>un TTL (Time To Live)
  <item>la tipologia del pacchetto (il TOS, o Type of Service)
  <item>alcune informazioni opzionali
</itemize>
Per quanto riguarda l'indirizzo sorgente e destinazione non credo ci siano problemi. Stessa
cosa credo per il checksum e per le informazioni di base contenute nel pacchetto. Per quanto
riguarda il TTL e le informazioni relative alla frammentazione, bisogna fare un passo indietro
e tornare a parlare di routing. Come già detto, in ogni rete locale viene utilizzato di base
per comunicare il protocollo definito dall'hardware utilizzato. Quando però un pacchetto raggiunge
un gateway ed il gateway si rende conto che il pacchetto deve uscire verso un'altra rete, le informazioni 
relative all'hardware della rete locale vengono <it/tolte e buttate via/ ed i dati (compreso l'header
IP e tutti gli altri header) vengono presi ed inseriti in un nuovo pacchetto conforme alle specifiche
dell'hardware della nuova rete dalla quale dovrà transitare il pacchetto. Succede a volte, però, che 
per differenze di hardware le nuove reti non siano in grado di trasportare i pacchetti per intero.
Per esempio, una rete ethernet può trasmettere pacchetti di al massimo 1546 byte. Se un gateway si
trovasse quindi a dovere spedire un pacchetto di 4000 byte su di una rete ethernet dovrebbe spezzettarlo
(frammentarlo) e trasmetter ogni pezzettino indipendentemente. L'header IP contiene quindi ``degli 
spazi'' a disposizione in caso si debba frammentare il pacchetto per contenere le informazioni
necessarie all'effettivo destinatario perché possa essere in grado di riunire tutte le informazioni
inviate (un po' come se il vostro postino tagliasse con le forbici le buste troppo grosse per
essere trasportate, prendendosi cura però di numerare i pezzettini in maniera da rendere più facile
l'operazione di riassemblaggio :). Il processo
di frammentazione però è abbastanza dispendioso in termini sia di banda che di cpu. In termini di banda
soprattutto perché se un solo frammento dovesse essere smarrito l'intero pacchetto andrebbe ritrasmesso 
e poi perché la somma della dimensione dei frammenti è comunque maggiore del pacchetto intero (ogni frammento
deve contenere a sua volta un header IP per poter essere consegnato) e causa tra l'altro parecchi
problemi al momento del riassemblaggio (esiste almeno un DoS basato su frammenti).<p>
Una caratteristica fondamentale di ogni scheda di rete è quindi l'MTU, ovvero Max Transfer Unit, ovvero
la massima dimensione di un pacchetto spedibile su quell'interfaccia. Spesso viene poi utilizzato un 
protocollo di cui credo avrete sentito parlare chiamato ``path MTU discovery protocol'', ovvero un 
protocollo per scoprire la dimensione massima di un pacchetto perché questo non venga frammentato
su nessuna delle reti da cui dovrà transitare.<p>
Indipendentemente dai frammenti e dai problemi di frammentazione, a volte può capitare però che si crei
un circolo vizioso tra gateway (per errori di configurazione, per esempio) e che quindi un pacchettino
continui a transitare per gli stessi gateway formando un vero e proprio cerchio, cosa che capita normalmente
quando un gateway rispedisce per esempio un pacchetto ad un gateway da cui è già transitato. Onde evitare
quindi che pacchetti IP continuino a girare per la rete senza mai raggiungere il destinatario, è stato 
introdotto il TTL, ovvero Time To Live. Il ``tempo di vita'' di un pacchetto viene decrementato almeno 
di una unità per ogni gateway da cui transita, e deve essere buttato via non appena questo raggiunge il 
valore di 0, evitando così che possa continuare ad utilizzare banda girando inutilmente per la rete. Il valore
massimo di TTL è 255 e sembra più che adeguato contando che normalmente si deve passare per una decina 
di gateway per raggiungere una determinata destinazione. <p>
Infine, ci rimane da parlare del TOS e delle informazioni opzionali. Per quanto riguarda il TOS, questo
campo contiene informazioni che possono aiutare i gateway a fare del loro meglio. Ad esempio, quando
si utilizzano software per la videoconferenza, il tos viene settato in modo che i gateway sappiano
che il pacchettino deve arrivare a destinaione il più in fretta possibile, anche se 
magari qualcuno dei pacchetti debba in questo modo essere scartato (per problemi di banda). Al contrario, 
quando si scarica  un file da ftp è importante che nessun pacchetto vada perso anche se questo 
dovesse richiedere più tempo.<p>
Le informazioni opzionali vengono invece utilizzate per rilevare problemi sulla rete o per 
fare giochettini strani con i pacchetti. In particolare, si può richiedere che tutti i gateway 
registrino il tempo di transito del pacchetto, o che ogni gateway registri il suo indirizzo nel 
pacchetto, o ancora che il pacchetto passi da determinati gateway. Spesso però, molti provider
non sono contenti di rilasciare queste informazioni (ed alcune di queste opzioni possono essere
pericolose per la sicurezza) cosicchè è diventata prassi comune che i gateway buttino via
i pacchettini utilizzanti queste determinate opzioni.<p>
Come abbiamo visto il protocollo IP non è molto affidabile: spesso i pacchettini vegono buttati
via e la politica del best effort non può dare alcun tipo di garanzia.

<sect1>Il protocollo ICMP<p>
Quando qualcosa va storto, quindi, viene utilizzato il protocollo ICMP. In pratica, il protocollo
IP è in grado di trasportare qualsiasi tipo di dati. Nel caso quindi si verifichi un errore, viene
spesso generato un pacchetto IP indirizzato al mittente del pacchetto che ha causato l'errore che 
invece di trasportare i dati trasporta un'intestazione ICMP. L'header del protocollo ICMP contiene
informazioni come il tipo di errore verificato, la macchina che ha generato l'errore ed una parte
del pacchetto IP originale che ha causato l'errore (RFC 792 e /usr/include/linux/icmp.h per maggiori 
dettagli).<p>
I pacchettini ICMP, però, non vengono sempre generati. Per esempio, non vengono generati:
<itemize>
  <item>quando c'è un errore nell'indirizzo sorgente o nell'indirizzo destinazione oppure l'indirizzo
        sorgente è un indirizzo di multicast (probabilmente ne accenerò più avanti) o di broadcast.
  <item>quando è un altro pacchettino ICMP a generare un errore. Se per esempio il TTL di un pacchetto 
        IP trasportante dati ICMP scendesse a 0 e il pacchettino venisse buttato via, non sarebbe 
	generato alcun errore. Questo per evitare che si creeino acnora una volta cicli infiniti
	di pacchetti che segnalano errori di altri pacchetti che a loro volta generano un errore.
  <item>per i frammenti diversi dal primo. Se un frammento centrale di un pacchetto IP venisse smarrito,
        non verrebbe quindi generato alcun errore.
  <item>quando la frequenza di invio dei messaggi ICMP è troppo alta, per evitare che utilizzino 
        troppa banda o che vengano utilizzati particolari attacchi (DoS) basati su ICMP.
</itemize>
Se poi vi dovesse capitare di leggere l'RFC1122, vi rendereste conto che c'è un gran numero di ``should''
relativi al protocollo ICMP. Ciò vuol dire che i vostri sviluppatori preferiti del codice di networking del
vostro kernel non sono obbligati a fare in modo che un determinato pacchettino ICMP venga generato, 
dovrebbero farlo, ma non è obbligatorio.<p>
Di base, l'ICMP è in grado di segnalare i seguenti errori:
<itemize>
  <item><bf/destination-unreachable/ ovvero, il computer remoto non sembra essere raggiungibile.
  	I motivi potrebbero essere diversi e normalmente viene incluso un codice che aiuti ad 
	identificare esattamente cosa non è raggiungibile (l'intera rete? solo l'host di destinazione?).
  <item><bf/source-quench/ ovvero, un gateway ha dovuto buttare via uno dei pacchettini in quanto
        non era in grado di processarlo per via di troppo carico o per altri motivi interni.
  <item><bf/redirect/ viene mandato per indicare che c'è un percorso migliore che dovrebbe essere utilizzato
        al posto di quello indicato.
  <item><bf/time-exceeded (ttl-exceeded)/ quando un pacchettino viene buttato via perché il suo
        TTL è sceso a 0.
  <item><bf/parameter-problem/ quando c'è un errore nell'header IP (dati incoerenti, errori nel checksum
        e così via...).
</itemize>
L'ICMP può essere utilizzato però anche per capire dove gli errori stanno o per capire
cosa c'è che non sta funzionando. In particolare esistono pacchettini ICMP:
<itemize>
  <item><bf/router-advertisement/ per pubblicizzare la presenza di un router.
  <item><bf/router-solicitation/ per richiedere quali sono i router di una determinata rete.
  <item><bf/timestamp-request/ per richiedere l'ora di un sistema (può essere utile
        per trovare alcuni tipi di colli di bottiglia, o semplicemente per sapere
	che ore sono dall'altra parte del mondo).
  <item><bf/timestamp-reply/ per inviare l'ora del sistema (risposta alla richiesta).
  <item><bf/address-mask-request/ per richiedere la netmask di una particolare rete.
  <item><bf/address-mask-reply/ per inviare la netmask della rete corrente.
  <item><bf/echo-request (ping)/ per richiedere che alcuni dati (il contenuto del ping)
        vengano rimandati al mittente.
  <item><bf/echo-reply (pong)/ per mandare indietro le informazioni ricevute.
</itemize>
Il pacchetto ICMP più famoso è senz'altro il ping: chiede ad un host di rimandare 
indietro i dati trasmessi. Alcune altri tipi di pacchetti vengono spesso tagliati via (buttati)
per rendere alcune informazioni più difficili da reperire, ed altri ancora vengono
spesso ignorati per evitare molti tipi di attacchi (come i redirect).

<sect1>Il protocollo UDP<p> 
Ok, una volta che abbiamo stabilito come mandare pacchettini da una 
parte all'altra della rete in maniera più o meno affidabile, rimangono aperte
diverse questioni.<p>
Per esempio, i dati inviati su di una rete non sono fini a loro stessi
e servono spesso per accedere a determinati servizi. Una singola macchina poi,
deve essere in grado di offrire diversi servizi a più utenti in contemporanea.<p>
La soluzione proposta dall'UDP, o User Datagram Protocol, descritto nell'RFC
768, consiste nel consentire di specificare anche una porta sorgente ed una
porta destinazione aggiungendo un header UDP subito prima dei dati (e subito
dopo l'header IP).<p>
Una ``porta'' non è altro che un numero intero compreso tra 0 e 655535 (2^16),
dove 0 è però riservato. Ad ogni servizio che può essere offerto su internet
deve essere quindi associata una porta e tutti gli utenti che vogliano fare
uso di tali servizi debbono inviare pacchetti ad un determinato host ad una
determinata porta. Per la prima volta dall'inizio di questo documento ho 
parlato di host: un host non è altro che una macchina che è in grado di parlare
determinati protocolli e che si attiene a determinate regole (definite sull'RFC
1122 e 1123) in riferimento soprattutto al comportamento in rete.<p>
Una volta inviati i pacchettini per richiedere un determinato servizio, però, l'host
remoto deve essere in grado di inviare una risposta, e la risposta viene normalmente
inviata invertendo mittente e destinatario nell'header IP ed invertendo porta 
sorgente con porta destinazione nell'header UDP. La nuova porta destinazione non rappresenterà
quindi un servizio, bensì verrà utilizzata per identificare in maniera univoca il 
mittente di un pacchetto. Per fare un esempio, immaginiamo di avere due macchine, una 
FOO ed una BAR, connesse entrambe ad una rete basata su protocollo IP. Immaginiamo quindi
che un utente su FOO debba sapere qualcosa da BAR. Per prima cosa, questo utente su
FOO caricherebbe un programmino per effettuare la richiesta. Questo programmino (o meglio, 
il sistema operativo per lui) fabbricherebbe quindi un pacchettino destinato a BAR con 
una porta sorgente scelta a caso e con la porta destinazione relativa al servizio richiesto.
Se tutto andasse bene, BAR riceverebbe questa richiesta e fabbricherebbe una risposta con
porta sorgente uguale a quella del servizio e porta destinazione uguale a quella scelta
casualmente in precedenza. FOO, una volta ricevuto il pacchetto di risposta, sarebbe in
grado di inviare i dati ricevuti al programma corretto semplicemente ricordandosi quale
porta aveva scelto di utilizzare per originariamente inviare i pacchetti di richiesta (ricordatevi, poi,
che la maggior parte dei sistemi oltre ad essere multitasking è attualmente anche multiutente (o per 
lo meno dice di esserlo <it/ndr/)).<p>
Di base, quindi, l'unica cosa che aggiunge l'UDP a dei pacchetti è il concetto di porta, e viene
normalmente considerato un protocollo molto leggero. Nella maggior parte dei sistemi unix viene mantenuto un
elenco di associazioni standard tra porta e servizio nel file /etc/services (le associazioni
``ufficiali'' sono indicate però nell'RFC 1700).<p>
Altra cosa importante da dire è che tutte le porte &lt; di 1024 vengono utilizzate per offrire
servizi standard e non possono quindi essere utilizzate da altri utenti se non dall'amministratore
della macchina (almeno su sistemi operativi degni di tale nome).<p>

<sect1>Il protocollo TCP<p> 
Una discussione approfondita sul protocollo TCP andrebbe ben oltre lo scopo
del documento che state leggendo e richiederebbe probabilmente una trattazione
a parte. Tutto ciò che descriverò fra poco farà riferimento solamente alle 
proprietà fondamentali del protocollo e ai meccanismi che utilizza utili
alla comprensione dei paragrafi successivi ed alle tematiche di firewalling.<p>
Comunque sia, il protocollo TCP è quello che dà il nome all'intero 
standard: il TCP/IP. <p>
Col protocollo UDP avevamo introdotto il concetto di porta ma non eravamo
riusciti a rimediare ai deficit fondamentali del protocollo ip: non avevamo
infatti ancora alcuna garanzia sull'effettiva ricezione dei pacchetti inviati,
eravamo comunque in grado solo di mandare pacchetti e l'unica identificazione
(di servizio e di utente o software locale) si poteva fare in base al numero 
di porta. <p>
Il protocollo TCP è il primo (e l'ultimo) protocollo ``connection oriented'' di
cui parleremo. Il TCP, infatti, consente di stabilire delle connessioni affidabili
da una macchina ad un'altra dove una quantità indefinita di dati può essere 
inviata e ricevuta proprio come se si trattasse di un normale ``stream'' (come lo stdin
o lo stdout) di I/O.
In pratica, il TCP ci consente di dimenticare che tutte le comunicazioni avvengono
per pacchetti dandoci l'impressione che in realtà tutte le comunicazioni avvengano
come se ci fosse un canale aperto tra il mittente ed il destinatario da cui i dati
possono fluire.<p> Ma vediamo di iniziare...

<sect2>Three way Handshake<p>
Ok, la trasmissione TCP inizia
quindi con quello che viene definita ``stretta di mano a tre vie'', ossia
three way handshake. Come ormai siamo soliti parlare, l'host che deve comunicare
con un altro host invia un pacchettino nel solito formato (header hardware, header
ip) con in più un header TCP. In questo primo pacchetto, l'header TCP contiene
2 informazioni fondamentali: un bit con valore ad 1 (un flag denominato SYN flag) ed 
un numero di 32 bit, il SYN vero e proprio, ossia il numero di sincronismo.<p>
In risposta a questo primo pacchetto, il computer remoto deve a sua volta inviare
il suo SYN ed un ACK, ovvero Acknowledge o conferma della ricezione del primo pacchetto.<p>
Per dare garanzia del ricevimento del primo pacchetto, l'host remoto calcola questo ACK in
base al SYN iniziale ricevuto ed alla dimensione dei pacchetti inviati.<p>
Una caratteristica del SYN &eacute; infatti che sia un numero casuale, difficilmente indovinabile,
che si incrementi col passare del tempo.<p>
Una volta che anche l'host che ha iniziato la trasmissione ha ricevuto il SYN della macchina
con cui si voleva collegare, la trasmissione pu&oacute; iniziare, e normalmente inizia con 
un ACK dell'avvenuta ricezione del SYN.<p>
In pratica, &eacute; come se i due computer comunicassero tramite raccomandate con ricevuta
di ritorno: se la ricevuta non torna indietro, c'&eacute; stato qualche errore e l'host remoto
pu&oacute; provvedere al rinvio dei dati, fintanto che non torna indietro una ricevuta con
il corretto ACK.<p>
Ovviamente, un ACK non va sempre mandato indietro (esistono delle regole per questo), in modo
da evitare di spedire l'ACK dell'ACK dell'ACK... e spesso viene accompagnato da dei dati di risposta, 
in maniera da ottimizzare l'utilizzo della banda (piggyback).<p>
Il tempo entro cui aspettare il ritorno dell'ACK viene invece calcolato in base al Round Trip Time,
detto anche RTT, ovvero il tempo di andata e ritorno di un pacchetto.<p>
Per evitare problemi di congestione di rete, viene utilizzato un algoritmo 

Una volta che i due computer si sono scambiati il SYN iniziale, &eacute; possibile iniziare
quindi la connessione vera e propria.



<sect1>L'ARP<p>

<sect1>I protocolli applicativi<p>
<sect2>Il DNS<p>
<sect2>L'HTTP<p>
<sect2>FTP<p>
<sect2>SMTP<p>
-->

<sect>Preparare il proprio sistema<p>
Per poter usufruire delle nuove funzionalit&agrave; messe a disposizione 
dal kernel di linux, &egrave; indispensabile che il vostro sistema 
soddisfi alcuni prerequisiti.<p>
In particolare, dovrete avere a disposizione:
<itemize>
  <item>Un kernel compilato con supporto per iptables, per il tracking (tracciamento)
  	delle connessioni e per tutti i tipi di NAT (i kernel delle maggiori
	distribuzioni vengono distribuiti con i moduli necessari).
  <item>Una versione di iptables compilata per il vostro kernel.
  <item>Eventualmente, una versione del pacchetto ``iproute'', sempre compilato
  	per essere usato con il vostro kernel.
</itemize>
Tutti questi strumenti sono solitamente preimpacchettati e disponibili nella maggior
parte delle distribuzioni, per cui, probabilmente, non avrete nulla da fare 
se non qualche ``apt-get install iproute iptables'' o ``rpm -i''. Per verificare
la loro presenza, potreste provare ad eseguire come ``root'' da riga di
comando i comandi ``iptables'', ``tc'', ip. Se linux non vi restituisce un
errore del tipo ``commando not found'' o ``comando non trovato'', allora sono
gi&agrave; installati e probabilmente il kernel supporta tutte le funzionalit&agrave;
di cui avrete bisogno.<p>
Se però volete dilettarvi con funzionalit&agrave; particolarmente avanzate ed
avere il massimo di flessibilit&agrave; possibile, vi consiglio di ricompilare
indipendentemente sia il kernel che iptables ed iproute. Come avrete capito,
questa non &egrave; proprio una strada semplice da seguire, soprattutto se siete utenti
linux alle prime armi. Non vi potrei biasimare quindi se decideste di usufruire
degli strumenti messi a disposizione dalla vostra distribuzione e se decideste di 
saltare completamente questa sezione. In caso contrario, i prossimi paragrafi 
cercheranno di esservi di aiuto nel processo di ricompilare e nel capire 
alcuni meccanismi che stanno alla base del sistema di ricompilazione del codice di 
networking di linux.<p>
Comunque sia, se avete deciso di andare avanti per la strada del ``ricompilare'' vi consiglio di fare
tutto su una macchina che non sia il firewall: avrete la certezza di non dimenticare in
giro tools come gcc, make, o le binutils. Attenzione però che senza usare i tool di impacchettamento
messi a disposizione dalla vostra distribuzione, potrebbe diventare alquanto complesso e tedioso
spostare i programmi appena compilati da una macchina all'altra... in questo documento verranno
dati spunti per utilizzare i tool di Debian a questo proposito.<p>
Infine, vi consiglio di eseguire le operazioni nell'ordine in cui sono presentate, onde
evitare problemi di dipendenze.


<sect1>Procurarsi i sorgenti<p>
Prima di iniziare a ricompilare, potrebbe essere utile procurarsi
i sorgenti dei vari programmi. Come prima cosa quindi, potreste voler scaricare:
<itemize>
  <item>Gli ultimi sorgenti del kernel <url url="http://www.kernel.org"> di 
  	linux, oppure gli ultimi forniti con la vostra distribuzione (apt-cache search kernel-source;
	apt-get install kernel-source-2.4.x).
  <item>L'ultima versione di iptables disponibile su <url url="http://www.iptables.org">.
  <item>L'ultima versione del patch-o-matic, disponibile su <url url="ftp://ftp.netfilter.org/pub/patch-o-matic/">.
  <item>L'ultima versione del pacchetto iproute, disponibile su <url url="ftp://ftp.inr.ac.ru/ip-routing/">.
</itemize>
Ok, verificate quindi di avere tutto il necessario a disposizione per ricompilare 
(gcc, make, binutils, libncurses, ncurses-dev, modutils...) e date un'occhiata ai vari 
README, Changes o INSTALL per evitare di incappare in qualche incompatibilità e per verificare 
di avere eventuali librerie (o tools necessari) installati.<p>
Spostatevi quindi in /usr/src o in una directory che vi fa comodo e decomprimete
tutti i vari .tar.gz o .tar.bz2, con i soliti 
<tscreen><verb>
  &num; tar -xjf file.tar.bz2
</verb></tscreen>
oppure
<tscreen><verb>
  &num; tar -xzf file.tar.gz
</verb></tscreen>
supponendo che stiate utilizzando una versione di GNU tar relativamente recente.
Ricordatevi, inoltre, che per ricompilare il kernel vi servir&agrave; per lo meno 
gcc, make, le binutils e gli header delle libncurses (nonch&eacute; qualche
tool che sicuramente ho dimenticato).

<sect2>Se usate debian...<p>
Andate in /usr/src e date:
<tscreen><verb>
	&num; apt-get install gcc make binutils libncurses5-dev
	&num; apt-get install kernel-source-2.4.x
	&num; apt-get build-dep kernel-source-2.4.x
	&num; apt-get install kernel-package
	&num; tar -xjf ./kernel-source-2.4.x.tar.bz2 &

	&num; apt-get source iptables
	&num; apt-get build-dep iptables

	&num; apt-get source iproute
	&num; apt-get build-dep iproute
</verb></tscreen>

<sect1>Patchare e prepararsi a ricompilare...<p>
Prima di ricompilare, è bene fare una precisazione. Il ``netfilter'' code del
kernel di linux, ovvero la parte di kernel che si occupa di fare da firewall,
è realizzato e rilasciato da un gruppo indipendente da quello
che prettamente si occupa del kernel di linux. Capita quindi spesso che persino
l'ultimissima release del kernel di linux sia rimasta
indietro rispetto all'ultima versione del codice di filtraggio (il netfilter).<p>
Considerando poi che molto velocemente vengono rilasciati bug fix e nuove funzioni
vengono introdotte, una delle cose più importanti da fare è aggiornare iptables
ed il kernel all'ultimissima versione, stando attenti però a mantenerli in
sincronia. Per fare questo, il gruppo di sviluppo del netfilter ha messo a disposizione
uno strumento estremamente potente quanto facile da usare: il patch-o-matic.<p>
Col passare del tempo, per&ograve;, questo strumento si &egrave; evoluto e modificato. 
Per cui, a secondo della versione di iptables che vorrete installare, dovrete seguire
due percorsi diversi. In particolare, se i sorgenti di iptables che avete scaricato
sono della versione 1.2.6 o minore, seguite le istruzioni indicate nella sezione 
``iptables 1.2.6'', altrimenti seguite quelle indicate nella sezione ``iptables 1.2.7a''.

<sect2>iptables 1.2.6 - Usare il patch-o-matic<p>
Entrate quindi nella directory dei sorgenti di iptables, collegatevi ad internet ed iniziate dando
un comando come:
<tscreen><verb>
	&num; make pending-patches KERNEL-DIR=path_assoluto/delvostrokernel
</verb></tscreen>
A questo punto, un'interfaccia a menù vi guiderà nell'aggiornamento del
vostro kernel. Attenzione che è meglio (a volte indispensabile) specificare un path assoluto per 
il proprio kernel. In pratica, usate qualcosa come <file>/usr/src/linux</file> anziché
<file>../linux</file> o <file>~/src/linux</file>. <p>
Questo comando applicher&agrave; sia al kernel che ai vostri sorgenti di 
iptables tutte quelle patch che sarebbero dovute essere applicate prima
del rilascio del kernel ufficiale, ma che per motivi vari non hanno fatto
in tempo ad essere inserite (normalmente,
si tratta di correzione di bug o piccole modifiche realizzate dopo
il rilascio del kernel). Se state utilizzando i sorgenti del kernel della
vostra distribuzione preferita, non dovreste preoccuparvi pi&ugrave;
di tanto. Il patch-o-matic &egrave; infatti in grado di capire da solo 
quali aggiornamenti sono già stati applicati e di evitare la maggior
parte dei problemi.<p>
Dopo questo primo passo, nel caso vi sentiste particolarmente coraggiosi 
ed inebriati dal successo appena ottenuto, potreste voler proseguire
con un 
<tscreen><verb>
	&num; make most-of-pom KERNEL-DIR=path_assoluto/delvostrokernel
</verb></tscreen>
Come prima, apparir&agrave; un'interfaccia a men&ugrave; che vi guider&agrave;
nell'aggiornamento dei vari sorgenti. A differenza di prima, per&ograve;,
questo comando tenter&agrave; di installare anche le estensioni che ancora non
sono parte del kernel o classificate sperimentali. Tra queste, ce ne
sono parecchie che la maggior parte delle distribuzioni includono
perché ormai abbastanza testate, o che comunque saranno incluse nelle 
prossime versioni del kernel... c'è sempre un sacco di materiale interessante
che spesso vale la pena di installare. Alcune funzioni poi, vi
torneranno utili dopo, magari se vorrete dilettarvi con firewall
trasparenti o imponendo limiti per orari o 
sul numero di connessioni parallele o ancora buttando via casualmente
i pacchetti delle persone che più vi stanno antipatiche.<p>
Non preoccupatevi poi se avete paura di applicare patch incompatibili
o troppo instabili: most-of-pom è fatto in modo da evitarvi 
simili errori. In pratica, cercher&agrave; di evitere che vi facciate male da soli.<p>
Se invece vi sentite ancor più coraggiosi e tutte le ultime feature
del netfilter vi piacciono veramente tanto, potete provare un
<tscreen><verb>
	&num; make patch-o-matic KERNEL-DIR=path_assoluto/delvostrokernel
</verb></tscreen>
che invece vi metterà a disposizione tutte le nuove feature, dalle
più inoffensive a quelle più pericolose, dalle più testate a quelle
più instabili, comprese quelle incompatibili tra di loro. In questo
caso, star&agrave; alla vostra abilit&agrave; ottenere qualcosa di funzionante.

<sect2>iptables 1.2.7 - Usare il patch-o-matic<p>
Ok, in questo caso, dovrete avere a disposizione sia i sorgenti di iptables, sia
i sorgenti del patch-o-matic. Dall'1.2.7 in poi, infatti, i sorgenti del patch-o-matic
vengono distribuiti indipendentemente dal codice di iptables. <p>
Ipotizzando di aver decompresso tutto in <file>/usr/src</file>, dovrete iniziare
entrando nella directory del patch o matic, ovvero
<tscreen><verb>
  # cd patch-o-matic-xxxxxxxx
</verb></tscreen>
dove le 8 x non sono altro che la data di rilascio del patch-o-matic.
Da qui, vi dovrebbe bastare eseguire:
<tscreen><verb>
  # ./runme pending KERNEL_DIR=/path/assoluto/del/kernel
</verb></tscreen>
dove ``/path/assoluto/del/kernel'' &egrave; il path dove avete decompresso
il kernel, per esempio ``/usr/src/kernel-source-2.4.19''. In questo caso,
il ``pending'' sta ad indicare che volete installare tutte quelle patch
che sarebbero dovute essere state inserite  prima del rilascio del kernel
ma che per un motivo o per l'altro non sono state applicate.<p>
Come per iptlables 1.2.6, i coraggiosi potrebbero voler riprovare ad
eseguire il comando di prima sostituendo a ``pending'' un ``base'' e poi un ``extra''.<p>
Il ``base'' vi proporr&agrave; l'installazione di quelle patch addizionali che 
dovrebbero lavorare bene insieme e che comunque si sono dimostrate abbastanza stabili. 
Al contrario, un ``extra'' vi proporr&agrave; l'installazione
di <it/tutte/ le patch disponibili, anche di quelle che potrebbero causare
problemi. Fra queste, alcune possono essere particolarmente utili, come il
supporto per l'h323 o per protocolli o filtri un po' esotici, come lo ``string''
o l'``iplimit''. In ogni caso, vi verr&agrave; presentata una simpatica e
semplice da utilizzare interfaccia a men&ugrave;.<p>

<sect3>iptables 1.2.7 - in Debian<p>
Il pacchetto Debian per iptables 1.2.7 &egrave; strutturato in
modo che nella directory upstream vi siano alcuni file di documentazione ed i
sorgenti originali di iptables (in formato tar.bz2), mentre nella directory debian vi
siano i file necessari per ricompilare iptables.<p>
Automaticamente quindi, il processo di compilazione (avviato utilizzando
il solito ``debuild'' o ``dpkg-buildpackage'')si occuper&agrave; di prendere
i sorgenti del kernel indicati nel file <file>debian/control</file> (campo
Depends, che dovranno gi&agrave; essere installati sul sistema), decomprimerli 
e patcharli con il patch-o-matic contenuto nella directory ``upstream'' ed 
utilizzando tutte le patch elencate nel file ``patch-o-matic.accepted.list''.<p>
Alla fine del processo di compilazione, dovreste quindi trovarvi con i nuovi pacchetti
.deb per iptables ed un nuovo .tar.bz2 contenente i sorgenti del kernel patchati in automatico
da ``debuild''. A questo punto, dovrete rimuovere i sorgenti precedentemente decompressi in 
<file>/usr/src</file> ed utilizzare quelli appena generati dal processo di compilazione di 
iptables, proseguendo poi con il processo di compilazione standard del kernel.<p>
Se invece volete personalizzare il processo di compilazione, dovrete:
<itemize>
  <item>Per utilizzare un kernel diverso da quello per cui &egrave; stato
    	creato il pacchettino, vi consiglio di dare un comando, dalla directory
	dove avete decompresso i sorgenti (per esempio, <file>/usr/src/iptables-1.2.7a</file>)
	simile a:
<tscreen><verb>
  # perl -pi -e s/kernel-source-2.4.19/kernel-source-2.4.20/g `find ./ -type -f`
</verb></tscreen>
	per utilizzare i sorgenti del 2.4.20 anzich&eacute; quelli del 2.4.19. 
	Questo comando, semplicemente, sostituisce in ogni file della directory
	la stringa ``kernel-source-2.4.19'' con la stringa ``kernel-source-2.4.20''.
	Abbiate fiducia, la stringa ``kernel-source-2.4.19'' appare solo dove
	viene utilizzata per decomprimere i sorgenti del kernel.
  <item>Per utilizzare una versione diversa del patch-o-matic, scaricate tale
  	versione in formato .tar.bz2 nella directory upstream, dopodich&egrave; date:
<tscreen><verb>
  # perl -pi -e s/patch-o-matic-20020825/patch-o-matic-20030220/g `find ./ -type -f`
</verb></tscreen>
	per utilizzare la versione 20030220 al posto della versione 20020825.
  <item>Infine, per elencare delle patch aggiuntive da applicare, potreste voler
  	aggiungere delle nuove righe nel file ``patch-o-matic.accepted.list'' nello
	stesso formato in cui le altre righe sono indicate (in poche parole, non
	cambiate la directory, fate un copia & incolla cambiando solo il nome della
	patch).
</itemize>
Questa probabilmente non &egrave; la procedura pi&ugrave; facile o pi&ugrave; semplice
da utilizzare, ma il pacchettino debian non &egrave; stato progettato per essere 
facilmente <!-- XXX --> modificato dagli utenti.<p>
In questi casi, la soluzione migliore potrebbe essere quella di aspettare la nuova 
versione del pacchetto.<p>
Comunqe, per compilare i sorgenti, dovrete ancora una volta utilizzare ``debuild'' o
``dpkg-buildpackage'', ricordandovi di utilizzare la nuova versione del kernel 
che verr&agrave; generata sotto forma di .tar.bz2 dal processo di compilazione di
iptables.

<sect2>Altre patch<p>
Ok, adesso avete l'ultimissima versione del netfilter e di iptables. Se 
state però configurando un firewall ad uso provider, reti di grosse/medie
dimensioni o se avete intenzione di installarlo in posti particolarmente
selvaggi con un minimo di banda a disposizione (non vale la pena se avete
solo una ADSL o poco di pi&ugrave;...), potreste voler essere in grado di
effettuare dello shaping. Alcune tra le patch più famose per lo shaping 
sono:
<itemize>
  <item>L'HTB, ovvero Hicerical Token Bucket filter, un class based queue
  	molto più facile da usare e più preciso (nonché altrettanto potente)
	dell'equivalente CBQ (tra l'altro, molto ben documentato). E' incluso
	nei kernel dal 2.4.20 in su.
  <item>Il wrr, o Weighted Round Robin, utile soprattutto se avete tanti utenti
  	dove alcuni si divertono con flashget o equivalenti a saturare completamente
	la banda bloccando a tutti gli altri persino la navigazione. 
	Disponibile su <url url="http://wipl-wrr.sourceforge.net">, distribuisce equamente la banda
	in base alle persone collegate.
  <item>Se invece non avete una connessione dedicata ma tante ADSL, potreste volere
        patchare il kernel in modo che possa essere in grado di fare il bilanciamento
	non solo per pacchetto (non funzionerebbe per via del NAT, probabilmente) ma 
	per connessione. Non ricordo per&ograve; l'URL della patch.
</itemize>
In questo documento, comunque, non tratteremo l'uso di queste patch, bensì solo
la loro installazione.<p>
Comunque sia, per queste e tutte le altre patch che vorrete applicare sul codice
di filtraggio o di shaping, la procedura generica è questa:
<enum>
  <item>Se la patch riguarda nuove capacit&agrave; di filtraggio, probabilmente
    	riguarda iptables, mentre se introduce nuovi metodi per gestire il traffico
	dei pacchetti o le tabelle di routing, probabilmente riguarda iproute.
  <item>Decomprimete la patch da qualche parte sul vostro disco. Dovrebbero venir
  	fuori due file .diff: uno per iproute o iptables, l'altro per il vostro kernel.
  <item>Entrate nella directory del vostro kernel (per esempio, ~/src/linux/) e
        date un 
<tscreen><verb>
	&num; patch -p1 &lt; path/file_del_kernel_patch.diff
</verb></tscreen>
  <item>Entrate nella directory di iptables o di iproute (per quanto riguarda il 
        netfilter ed il codice di shaping, il 99% delle volte ad ogni patch
	del kernel corrisponde una di iptables o iproute) e date:
<tscreen><verb>
	&num; patch -p1 &lt; path/file_di_iptables_o_iproute_patch.diff
</verb></tscreen>
</enum>

<sect1>Preparare il kernel<p>
Esistono centinaia di howto (se non migliaia) in giro per internet su come ricompilare
il kernel e per questo mi limiterò a dare le istruzioni fondamentali per avere un buon 
kernel adatto per un firewall.<p>
Ricordatevi però sempre di configurare il kernel <bf/dopo/ :-) aver applicato tutte
le patch, onde evitare di faticare ad applicare delle patch che non verranno mai utilizzate per 
via dei parametri scelti con ``menuconfig'' (o ``xconfig'' o ...).
<p>

<sect2>Configurarlo<p>
Ok, a questo punto dovreste avere il vostro kernel decompresso in giro da qualche
parte su una delle vostre partizioni. Entrate dunque nella directory dove è stato decompresso
e preparatevi per compilarlo con il solito:
<tscreen><verb>
	&num; make menuconfig
</verb></tscreen>
Se vi si presenta un errore qui, la maggior parte delle volte &egrave; perch&eacute;
vi mancano gli header delle ncurses o dei tool fondamentali. Rileggete la sezione
sul <it/prepararsi a ricompilare/ e su come <it/procurarsi i sorgenti/.
Abilitate quindi tutto ciò che vi serve, con particolare attenzione però al menù
delle ``networking options''. Abilitate dunque, tenendo le feature sperimentali 
disabilitate:
<tscreen><verb>
Packet socket
  Packet socket: mmapped IO
Netlink device emulation
Network Packet filtering
Socket Filtering
Unix Domain Sockets
TCP/IP networking
  IP: multicasting
  IP: advanced router 
       e tutte le voci che appariranno
  IP: Tunnelling
  IP: GRE tunnels over IP
    IP: Broadcast GRE over IP
  IP: multicast routing
       e tutte le voci che appariranno
  
  IP: TCP syncookie support 
       (solo se avete un kernel relativamente recente, non ricordo 
       la versione corretta, ma ogni &gt; 2.4.10 dovrebbe andare)
  IP: Netifilter configuration
    Connection Tracking 
       e tutte le voci che appariranno
    IP Tables support
       e tutte le voci che appariranno
802.1d Ethernet Bridging
E tutte le voci sotto 'QoS' and fair queuing
</verb></tscreen>
Attenzione che la maggior parte di queste opzioni non sono indispensabili (anzi, probabilmente
non le userete mai). Quando però mi capita di ricompilare un kernel per un firewall, mi piace 
pensare che abbia tutto ciò che al momento è disponibile, e spesso torno indietro abilitando
anche le feature sperimentali, in modo da poter selezionare:
<itemize>
  <item>Tutte quelle feature aggiunte tramite patch
  <item>Il supporto per le VLAN
  <item>Molti altri componenti già forniti col kernel, parte di iptables, ma considerati
  	sperimentali.
</itemize>
Attenzione che il vostro kernel non influenzerà soltanto il comportamento del firewall in 
rete, ma sarà un componente indispensabile per la sicurezza e la stabilità del vostro sistema.
Assicuratevi quindi di comprendere pienamente tutto ciò che selezionate (comprese le cose
che vi ho indicato), e fatte le dovute considerazioni, non sentitevi in colpa a fare diversamente
da quanto suggerito. Nella peggiore delle ipotesi, dovrete ricompilare il kernel...<p>
Ci sono quindi diverse cose che potreste considerare configurando il kernel del vostro firewall:
<itemize>
  <item>Aggiungere delle patch per ``rinforzare'' il sistema (la openwall, www.openwall.com 
        non appena sarà disponibile, oppure la LIDS, che però è molto
	invasiva).
  <item>Disabilitare il supporto per i moduli (esiste almeno un rootkit basato su moduli del kernel, ed
  	un kernel senza supporto per i moduli potrebbe complicare non di poco il lavoro di un possibile intruso).
  <item>Abilitare file system come il reiser, l'ext3 o il devfs (per essere in grado di montare i dischi read-only
        e per avere una macchina che si comporti un po' come un videoregistratore: che si possa cioè 
	tranquillamente spegnere e accendere senza avere alcuna competenza di linux, o che comunque
	in caso di mancanza di corrente non abbia alcun problema a ripartire velocemente).
  <item>Abilitare il frame buffer, per riuscire a scrivere facilemente regole pi&uacute; lunghe.
</itemize>
Questi sono soltanto spunti o suggerimenti, sta al vostro estro produrre un kernel il più utile e 
funzionale possibile.<p>
Ricordatevi poi che in un firewall non esiste solo il networking, e non dimenticatevi quindi di
scegliere opportunamente il processore, le periferiche e... <p>
Infine, dopo aver ricompilato ed incluso tutte le funzioni che pi&ugrave; vi stanno a cuore, 
ricordatevi di verificare di aver ottenuto qualcosa di stabile ed utilizzabile, provando il
vostro firewall prima di metterlo in produzione.

<sect2>Ricompilarlo<p>
Per molti di voi sarà probabilmente superfluo dire di dare:
<tscreen><verb>
	&num; make dep bzImage modules modules_install
</verb></tscreen>
Seguite poi la procedura della vostra distribuzione (o prevista dal vostro boot loader) per installare
il nuovo kernel (lilo piuttosto che grub).<p>
Se ci dovessero essere errori, l'unica cosa che posso suggerirvi è di provare a correggere gli errori
o eventualmente disabilitare una patch per volta (via menuconfig) fino a riottenere qualcosa di 
ricompilabile...

<sect3>In Debian<p>
Date:
<tscreen><verb>
	&num; apt-get install kernel-package
	&num; make-kpkg binary modules
	&num; cd ..; dpkg -i kernel-image-2.4.x....deb; dpkg -i kernel-headers*.deb
</verb></tscreen>

<sect1>Compilare iptables<p>
Non dovreste avere grossi problemi... seguite le istruzioni indicate nel file INSTALL e tutto vi andrà 
bene, a meno che non abbiate abilitato qualche patch troppo sperimentale... comunque, se siete abbastanza
pigri da non voler leggere un file in inglese, vi dovrebbe bastare qualcosa come (dalla directory di iptables):
<tscreen><verb>
	&num; make install KERNEL_DIR=path_assoluto/delvostrokernel/
</verb></tscreen>
Se avete debian, dovreste gi&agrave; avere i pacchettini compilati nei precedenti passi. Questo &egrave;
il momento buono per utilizzare ``dpkg -i iptables_*.deb'' per installarli.

<sect1>Compilare iproute<p>
iproute normalmente è un pochettino più problematico. Questo soprattutto perché ha bisogno che
gli headers file del kernel installato sul sistema siano relativi al kernel che avete appena
patchato e ricompilato. Se avete già provato a fare questa procedura, avrete senz'altro visto 
diversi errori relativi a dei tipi non definiti o errori in pak_sched.h (a meno che non
abbiate applicato alcuna patch). Ma andiamo per gradi:
<itemize>
  <item>Andate in /usr/include e fate sparire momentaneamente la directory ``linux'' (ad esempio, con
  	un ``mv ./linux ~/''). Attenzione! Cos&iacute; facendo potreste creare problemi ad eventuali
	altri utenti del sistema, e non &egrave; certo il metodo pi&ugrave; corretto!
  <item>Date un ``ln -s /path_assoluto_sorgenti_nuovo_kernel/include/linux ./linux''
</itemize>
In questo modo avete messo a posto gli headers file per poter ricompilare iproute (esistono centinaia
di modi più furbi per farlo, ma credo che questo sia uno dei più semplici).<p>
Entrate quindi nella directory di iproute e provate a compilarlo seguendo le istruzioni fornite (dovrebbe 
bastare un semplice ``make install''). Non vi spaventate se non va liscio la prima
volta: alcune versioni di iproute citano in uno dei file .c una costante che non è più definita negli 
headers di linux.<p>
Per risolvere il problema, basterà semplicemente aprire con un editor il file nella directory
lib chiamato ll_proto.c (iproute/lib/ll_proto.c) e commentare via la riga (sul mio sistema la 36)  
<tscreen><verb>
__PF(ECHO,echo) 
</verb></tscreen>
sostituendola con la riga 
<tscreen><verb>
/* __PF(ECHO,echo) */
</verb></tscreen>
Non vi preoccupate, non è una mia idea ed è un problema abbastanza documentato dove è prassi
normale per risolverlo commentare via la riga indicata (tra l'altro, al momento del rilascio
di questo documento, potrebbe essere un problema gi&aacute; risolto).<p> Riprovate quindi a compilare... 
se ancora non vi va bene, controllate di aver sistemato correttamente
<file>/usr/include/linux</file> e di aver applicato a iproute tutte le patch che avete applicato 
al vostro kernel e viceversa.<p>
Se ancora non riuscite a compilare e non avete delle buone conoscenze del C, vi consiglio di riprovare a ricompilare
iproute senza nessuna patch, poi con una, poi con due... finché non smette di funzionare. Se già dall'inizio
non si ricompila, probabilmente vi manca qualche tool necessario per la compilazione o avete qualche
header un po' particolare. Provate a chiedere sulle mailing-lists delle vostre distribuzioni.<p>
Se invece non vi ha dato problemi, ed è
andato tutto liscio al primo colpo, probabilmente siete stati fortunati... non vi preoccupate :-)...<p>

<sect2>In Debian<p>
La procedura è la stessa di iptables: entrate nella directory di iproute e date
<tscreen><verb>
	&num; debuild 
 	&num; cd ..; dpkg -i *.deb	
</verb></tscreen>
oppure
<tscreen><verb>
	&num; dpkg-buildpackage 
 	&num; cd ..; dpkg -i *.deb	
</verb></tscreen>
per fabbricare i .deb contenenti la vostra versione personalizzata di iproute.<p>
Se la procedura si blocca durante la compilazione, leggete le raccomandazioni nella
sezione precedente, dove si descrive la procedura di installazione manuale, e verificate
di aver gi&agrave; installato il nuovo kernel con dpkg.

<sect>Hardening the system <p>
Con ``hardening the system'' si intende la procedura utilizzata
per rendere il sistema il più resistente possibile ai vari tentativi
di attacco. La procedura di per s&eacute; è abbastanza semplice, e si può riassumere
in quattro semplici passi: 
<itemize>
  <item>Eliminare tutto ciò che è inutile al funzionamento del firewall,
   	ovvero tutto ci&ograve; che potrebbe essere utilizzato contro di
	voi.
  <item>Rendere difficilmente identificabile il sistema in modo da rendere
  	pi&ugrave; difficile per un attaccante capire che strumenti utilizzare
	per potervici entrare.
  <item>Limitare le capacità del firewall in maniera da rendere la vita il
   	più difficile possibile per un intruso (dischi readonly, mancanza
	di tool basilari, strette regole di firewalling anche per la 
	catena in OUTPUT...).
  <item>Mettersi nella posizione di poter rilevare facilmente un'intrusione.
</itemize>
In questo documento vi vengono date delle indicazioni molto sbrigative
e sommarie in proposito, che dovrebbero essere interpretate pi&ugrave; che 
altro come spunti. Vi consiglio di riferirvi a documentazione specifica in 
proposito.

<sect1>Ridurre i punti di ingresso<p>
L'idea di base &egrave; quella di eliminare tutto ci&ograve; che in rete
potrebbe essere facilmente attaccato. Potreste quindi voler seguire
le indicazioni contenute nelle prossime sezioni.

<sect2>inetd.conf<p>
In questo file sono indicati alcuni servizi di rete che dovranno essere attivi
sulla vostra macchina. Alcune distribuzioni, invece dello standard inetd, utilizzano
xinetd che fa uso di una struttura a directory e di un diverso file di configurazione.
Se la vostra distribuzione utilizza inetd.conf, vi dovrebbe bastare commentare tutte le
	righe che servono per attivare servizi che non vi interessa offrire, inserendo un 
	``#'' all'inizio della riga stessa. Un
	tipico file inetd.conf al termine dell'installazione di debian (a secondo di quello
	che &Egrave; stato installato) potrebbe essere simile al seguente:
<tscreen><verb>
# [...]
#
#:INTERNAL: Internal services
echo		stream	tcp	nowait	root	internal
echo		dgram	udp	wait	root	internal
chargen		stream	tcp	nowait	root	internal
chargen		dgram	udp	wait	root	internal
discard		stream	tcp	nowait	root	internal
discard		dgram	udp	wait	root	internal
daytime		stream	tcp	nowait	root	internal
daytime		dgram	udp	wait	root	internal
time		stream	tcp	nowait	root	internal
time		dgram	udp	wait	root	internal

#:STANDARD: These are standard services.
ftp 		stream tcp nowait root /usr/sbin/tcpd /usr/sbin/proftpd

#:BOOT: Tftp service is provided primarily for booting.  Most sites
# run this only on machines acting as "boot servers."
#tftp		dgram	udp	wait	nobody	/usr/sbin/tcpd	/usr/sbin/in.tftpd /boot

# [...]
</verb></tscreen>
	La maggior parte di questi servizi (il nome indicato nella prima colonna), 
	sono servizi *nix standard, forniti per motivi di conformit&agrave; con altri
	sistemi *nix e per lo pi&ugrave; inutili.<p>
	Nel nostro caso, il firewall non offrir&agrave; alcun servizio, nel senso
	che non vi sar&agrave; installato alcun server, salvo, forse, per il server
	``ssh'' per l'amministrazione remota. Dovremmo quindi provvedere a commentare
	tutte le righe inserendo un cancelletto all'inizio della riga, come mostrato
	per il servizio ``tftp''.<p>
	Nel caso decidiate di lasciare alcuni servizi aperti, fate attenzione alla
	quinta colonna, che contiene i privilegi con cui il programma verr&agrave;
	eseguito, e alla sesta, che contiene il programma da eseguire. A parte 
	i programmi indicati come internal, la maggior parte delle volte vedrete
	in sesta colonna il comando ``/usr/sbin/tcpd''. Questo, in gergo,
	viene definito un ``wrapper''. Quello che fa questo comando, infatti,
	&egrave; semplicemente eseguire ci&ograve; che viene indicato nella
	colonna successiva. L'utilit&agrave; del wrapper &egrave; che prima di 
	eseguire il comando indicato, quando ricever&agrave; una connessione, questo 
	si occuper&agrave; di effettuare alcune verifiche
	decidendo se bloccare o consentire l'utilizzo del servizio.<p>
	Le decisioni di questo wrapper sono normalmente basate sul contenuto
	del file <file>/etc/hosts.allow</file> e <file>/etc/hosts.deny</file>.
	Maggiori informazioni sul formato di questo file possono essere
	reperite sulla pagina di manuale di ``hosts_access'' e ``hosts_options''.

<sect2>Directory /etc/init.d<p>
In questa directory sono normalmente contenute due categorie di script:
<itemize>
  <item>quelli necessari per effettuare alcune operazioni durante l'accensione
  	e lo spegnimento del computer.
  <item>quelli necessari per far partire o bloccare quei servizi che una volta
  	attivati dovrebbero continuare a funzionare finch&egrave; non esplicitamente
	bloccati (facendo il logout non si fermano -- demoni come apache, bind,
	sendmail o ...).
</itemize>
In Debian e in altre distribuzioni con un sistema di boot conforme a quello di System V,
in <file>/etc</file> (o <file>/etc/rc.d</file>) esistono altre directory chiamate <file>rc0.d</file>,
<file>rc1.d</file>, <file>rc2.d</file> e cos&igrave; via. Queste directory contengono dei link
simbolici agli script in ``init.d'' che dovranno essere eseguiti quando si passa rispettivamente
a runlevel 0, 1, 2 e cos&igrave; via.<p> Ogni runlevel, poi, pu&ograve; essere utilizzato in 
modo diverso e gli pu&ograve; venire assegnato un particolare significato. Ad esempio, l'operazione
di shutdown consiste nel passaggio dal runlevel corrente al runlevel 0 (per cui, tutti gli script
in rc0.d verranno utilizzati per bloccare i vari servizi e per eseguire le operazioni
di spegnimento), il runlevel 2 &egrave; quello standard
che viene eseguito quando si accende il computer, ed il 6 viene usato per il reboot.<p>
Per rendere pi&ugrave; sicuro il nostro firewall, dovremmo quindi prodigarci per evitare che
durante l'accensione vengano avviati dei servizi che potrebbero essere utilizzati contro di noi.<p>
Il metodo normalmente utilizzato &egrave; quello di eliminare i link simbolici (con un semplice rm)
relativi a servizi che non ci interessano dalla directory relativa al runlevel utilizzato per avviare 
il sistema (normalmente ``rc2.d'', almeno in Debian).
Alcune distribuzioni utilizzano metodi pi&ugrave; esotici per gestire questi link simbolici, per cui
vi conviene dare un'occhiata alla documentazione che vi &egrave; stata fornita.<p>
In Debian per esempio, &egrave; possibile utilizzare lo script ``update-rc.d'', con 
qualcosa di simile a:
<tscreen><verb>
  update-rc.d apache remove
</verb></tscreen>
per evitare che apache venga caricato durante l'avvio o lo shutdown. Un'altra alternativa
potrebbe essere quella di rimuovere del tutto apache (probabilmente inutile se non lo si 
fa partire a boot-up), con il solito:
<tscreen><verb>
  apt-get --purge remove apache
</verb></tscreen>
Per avere un elenco dei programmi attivi che offrono servizi in rete, potreste
voler utilizzare il comando netstat, con 
<tscreen><verb>
  &num; netstat -npla |less
</verb></tscreen>
che vi dovrebbe indicare le porte rimaste aperte ed i relativi processi.<p>


<sect2>Demoni<p>
In generale comunque, per i servizi che deciderete di lasciare attivi, ricordatevi
dove possibile di:
<itemize>
  <item>eliminare banner di benvenuto o comunque quelle informazioni che 
  	mostrino il nome e la versione dei programmi utilizzati.
  <item>controllate mailing list di sicurezza, come per esempio bugtraq, 
  	per verificare che i demoni lasciati attivi non contengano bug
	pericolosi.
  <item>non lasciate demoni attivi con privilegi di root.
</itemize>
Per ci&ograve; che offre servizi in rete, se vi voleste veramente divertire,
potreste utilizzare delle porte diverse rispetto quelle standard: se metteste per esempio 
ssh sulla porta 42 piuttosto che sulla 54, potreste evitare tutti quegli scanner che 
mandano pacchettini in giro per la rete alla ricerca di particolari versioni di particolari 
software da poter facilmente bucare. Certo, questo pu&oacute; creare parecchia confusione 
anche dal punto di vista dell'amministrazione (soprattutto se ogni volta utilizzate una porta 
diversa), ma a lungo andare potrebbe dimostrarsi una utile contromisura. Attenzione
per&ograve; che se il demone che state utilizzando contiene dei bachi di sicurezza, questo
continuer&agrave; ad averne anche se deciderete di utilizzare una diversa porta.<p>
Per cambiare impostazioni come la porta, i privilegi che il demone dovr&agrave;
avere o per cambiare i banner di benvenuto, riferitevi alla documentazione specifica
fornita col demone installato.

<sect1>Ripulire il sistema<p>
<itemize>
  <item>Eliminate tutti i tool di compilazione (make, gcc...), gli header file, o
tutti quei tool di debugging (gdb, objdump...) che potrebbero essere usati
contro di voi. Se avete bisogno di ricompilare, potrete sfruttare una macchina
di appoggio e i tool per creare i pacchetti messi a disposizione 
dalla vostra distribuzione. In questo modo, non rischierete di dimenticare
tool pericolosi o sorgenti in giro.<p>
  <item>Cercate poi tutti quei programmi noti come ``suid'' root, cioè che possono
prendere i privilegi dell'amministratore una volta caricati (find / -perm +4000),
e togliete loro questa possibilità <bf/valutando però caso per caso/. Ad esempio 
vorrete probabilmente lasciare /bin/login suid root, mentre a ping, mount &amp; co. credo
possa essere tolto tranquillamente questo privilegio con comandi del tipo ``chmod ug-s nomefile''.
  <item>Configurate propriamente <file>fstab</file>, lasciando solo
<file>/var</file> scrivibile e lasciando tutte le altre partizioni read-only, limitando persino la
creazione di dispositivi o l'esecuzione di file suid root. Un esempio di fstab 
potrebbe essere il seguente:
<tscreen><verb>
proc          /proc     proc      defaults                       0 0 
/dev/hda1     none      swap      sw                             0 0
/dev/hda5     /         ext2      ro,defaults,errors=remount-ro  0 1 
/dev/hda2     /boot     ext2      ro,nosuid,noexec,nodev,nouser  0 3 
/dev/hda7     /var      reiserfs  rw,nosuid,nodev,nouser         0 3 
/dev/hda8     /home     reiserfs  rw,nosuid,nodev,nouser         0 3
</verb></tscreen>
dove <it/nosuid/ indica al kernel di non eseguire programmi con privilegi suid, <it/noexec/ di non
eseguire alcun programma, <it/nodev/ di non consentire la creazione di dispositivi
e infine <it/nouser/ di non permettere agli utenti di montare o smontare la partizione indicata.<p>
Attenzione però che la vostra distribuzione potrebbe non essere troppo contenta
di avere a che fare con dischi readonly, soprattutto per quanto riguarda la 
root. Una soluzione che ho visto funzionare abbastanza bene (salvo qualche directory)
&eacute; stata quella di scrivere due script, mkro e mkrw, il primo per rendere la root
read only ed il secondo per renderla read write, e di installarli in modo che venissero
eseguiti rispettivamente come l'ultimo comando a startup ed il primo comando a shutdown.
In Debian, &egrave; possibile fare questo copiando i due file nella directory <file>/etc/init.d</file>
e dando i comandi ``update-rc.d mkro start 99 2'' e ``update-rc.d mkrw stop 00 6''.<p> 
Cos&igrave; facendo, la partizione di root dovrebbe essere indicata come ``rw'' nel file 
fstab.<p>
Notate inoltre che in <file>/var</file> viene consentita l'esecuzione di programmi: questo perché la 
maggior parte delle distribuzioni utilizzano <file>/var</file> per conservare gli 
script di installazione/disinstallazione dei vari pacchettini che devono essere eseguiti.<p>
Infine, attenzione che la partizione che contiene la directory <file>/dev</file> deve essere montata 
come rw... una buona soluzione &eacute; quella di utilizzare o una partizione a parte, o una partizione
creata da un ramdisk o shm, oppure utilizzare il devfs con il demone devfsd (soluzione sicuramente 
migliore).<p>
Per quanto riguarda <file>/tmp</file>, questa viene utilizzata da molti programmi e deve quindi 
essere scrivibile. Sempre che non abbiate creato una partizione indipendente per /tmp, una soluzione 
potrebbe essere quella di creare un symlink <file>/tmp</file> a <file>/var/tmp</file>, oppure sfruttare 
le nuove capacità del kernel 2.4 aggiungendo da qualche parte nei file eseguiti all'avvio un comando
del tipo:
<tscreen><verb>
  mount --bind /var/tmp /tmp
</verb></tscreen>
che monterebbe in maniera molto particolare (estremamente simile ad un hard link) la directory 
<file>/var/tmp</file> su <file>/tmp</file>. Attenzione per&ograve; che il FHS (lo standard per 
la struttura del file system), indica che in <file>/tmp</file> i file possono essere rimossi 
in qualsiasi istante dall'amministratore del sistema, e consiglia di ripulire /tmp durante i 
reboot. Al contrario, /var/tmp non deve essere ripulita durante i reboot e deve consentire la 
creazione di file ``abbastanza persistenti''.  Per evitare problemi con la vostra distribuzione, 
&egrave; quindi consigliabile far puntare <file>/tmp</file> ad una sottodirectory di /var/tmp in 
modo che un'eventuale pulizia periodica di <file>/tmp</file> non rimuova tutti i file di <file>/var/tmp</file>. 
Per esempio, potreste fare qualcosa del tipo:<p>
<tscreen><verb>
mkdir /var/tmp/removable/
mount --bind /var/tmp/removable/ /tmp
</verb></tscreen>
Piuttosto che
<tscreen><verb>
mkdir /var/tmp/removable/
cd /; ln -s /var/tmp/removable ./tmp
</verb></tscreen>
Infine, parlando di partizioni read only o read write, &egrave; bene dedicare un minimo di 
attenzione al file <file>/etc/mtab</file>. In questo file viene mantenuto l'elenco delle
partizioni montate col comando ``mount''. In pratica, quando date il comando ``mount'' da 
solo, per vedere le partizioni montate, vi viene mostrato il contenuto di questo file.
Il problema &egrave; che montando la root read only, mount non sar&agrave; in 
grado di aggiornare questo file e di capire quali partizioni sono montate, dando origine a 
degli errori piuttosto bizzarri. Una buona soluzione &egrave; quella di eliminare il file 
mtab completamente e di creare un link simbolico in <file>/etc</file> che punti al file
<file>/proc/mounts</file>. Questo file mostra le informazione conosciute dal kernel a proposito dei
dischi montati, e non pu&ograve; quindi contenere errori. In pratica date:
<tscreen><verb>
cd /etc
rm ./mtab
ln -s /proc/mounts ./mtab
</verb></tscreen>
  <item> Per i file system ext2/3 potreste poi volere utilizzare il comando ``chattr +i nomefile'',
per marcare i file a livello di filesystem come immodificabili. Questo è utile
soprattutto perché si tratta di una modifica poco visibile (normalmente non si vede con ls -al)
e non consente nemmeno a root di modificare il file, a meno che prima non esegua
un comando come ``chattr -i nomefile'', sempre che chattr non sia stato preventivamente
rimosso dal sistema :-).<p>
  <item>Date un'occhiata a <file>/etc/crontab</file> e alle varie directory, eliminando ci&ograve;
  	che non serve.  Ad esempio, su un sistema con dischi read-only non credo sia necessario
        aggiornare il database di ``locate''.  Spesso poi, gli script eseguiti da cron interagiscono con il
        sistema e può capitare che possano essere imbrogliati costringendoli a fare cose non volute. Normalmente
        tutte le distribuzioni tendono ad evitare errori di questo tipo ed &eacute; molto raro trovarne, ma una 
        verifica non costa nulla
        e può garantirvi un grado di sicurezza maggiore.
 <item>Se sul sistema vi saranno altri utenti oltre root, date un'occhiata alle restrizioni imposte dalla 
 	pam (<file>/etc/pam.d</file>) agli utenti ed al file <file>/etc/login.defs</file>.
 <item>Se avete un kernel relativamente recente, date un'occhiata al comando ``lcap'' (in Debian, installate
       l'omonimo pacchetto, con ``apt-get install lcap''). lcap &egrave; un comando che vi consente di
       dire al kernel che <bf/non/ volete pi&ugrave; usufruire di determinati servizi (capability, ovvero
       ``capacit&agrave;'' del kernel). Una volta detto questo al kernel, le capability non potranno
       pi&ugrave; essere acquisite dal kernel, a meno che la macchina non venga spenta e riavviata.
       Il fatto che il kernel di linux perda determinate ``capacit&agrave;'' pu&ograve; quindi dare 
       notevoli vantaggi dal punto di vista della sicurezza. Utilizzando il comando ``lcap'' senza
       alcun argomento, vi verr&agrave; data una lista delle ``capacit&agrave;'' che il kernel
       pu&ograve; decidere di lasciare, come per esempio:
       <tscreen><verb>
Current capabilities: 0xFFFFFEFF
   0) *CAP_CHOWN                   1) *CAP_DAC_OVERRIDE         
   2) *CAP_DAC_READ_SEARCH         3) *CAP_FOWNER               
   4) *CAP_FSETID                  5) *CAP_KILL                 
   6) *CAP_SETGID                  7) *CAP_SETUID               
   8)  CAP_SETPCAP                 9) *CAP_LINUX_IMMUTABLE      
  10) *CAP_NET_BIND_SERVICE       11) *CAP_NET_BROADCAST        
  12) *CAP_NET_ADMIN              13) *CAP_NET_RAW              
  14) *CAP_IPC_LOCK               15) *CAP_IPC_OWNER            
  16) *CAP_SYS_MODULE             17) *CAP_SYS_RAWIO            
  18) *CAP_SYS_CHROOT             19) *CAP_SYS_PTRACE           
  20) *CAP_SYS_PACCT              21) *CAP_SYS_ADMIN            
  22) *CAP_SYS_BOOT               23) *CAP_SYS_NICE             
  24) *CAP_SYS_RESOURCE           25) *CAP_SYS_TIME             
  26) *CAP_SYS_TTY_CONFIG       
    * = Capabilities currently allowed
      </verb></tscreen>
      Ad esempio, con ``lcap CAP_CHOWN'' il kernel mollerebbe la capacit&agrave; di far andare la
      chiamata di sistema CHOWN, rendendo impossibile il cambio di proprietario di un file.
      Eseguendo quindi il comando ``chown'', questo ci restituirebbe un errore del tipo ``Operation
      not permitted''. In breve, disattivare la capacit&agrave; del kernel:
      <itemize>
        <item>CAP_CHOWN -- inibisce il cambio di proprietario di un file, blocca il comando chown.
		Attenzione che, ad esempio in Debian, ogni volta che un utente completa il login
		viene fatto un chown sul dispositivo corrispondente alla sua console, onde evitare
		che altri (senza la sua autorizzazione) possano scrivere su tale dispositivo. Bloccare
		chown bloccher&agrave; quindi l'accesso a <bf/tutti/, compreso l'amministratore,
		a meno che questa feture non venga disabilitata.
	<item>CAP_NET_BIND_SERVICE -- inibisce l'apertura di porte TCP o UDP inferirori alla 1024, 
		impedendo il caricamento di nuovi servizi su porte standard.
	<item>CAP_NET_ADMIN -- inibisce: il cambio di configurazione delle interfacce di rete o
	        la configurazione di nuove interfacce, le operazioni di amministrazione del codice
		di firewalling, nat, accounting, l'abilitazione del debugging sulle socket, la 
		modifica delle tabelle di routing, l'abilitazione/disabilitazione del promiscuous
		mode e altre.
	<item>CAP_SYS_MODULE -- inibisce il caricamento o la rimozione di moduli.
	<item>CAP_SYS_CHROOT -- inibisce l'utilizzo di jail root, ovvero del comando chroot.
	<item>CAP_SYS_PACCT -- inibisce il cambio di configurazione del process accounting <!-- CROSS -->.
	<item>CAP_SYS_BOOT -- inibisce la possibilit&agrave; di riavviare la macchina tramite
		comandi.
	<item>CAP_SYS_RESOURCE -- inibisce il cambio dei limiti di risorse imposti ai vari
		processi o delle quote imposte su disco (per fs ext2).
	<item>CAP_SETUID -- inibisce l'utilizzo di programmi suid.
	<item>CAP_LINUX_IMMUTABLE -- inibisce la possibilit&agrave; di cambiare il flag 
	 	immutabile tramite il comando ``chattr''
	<item>CAP_NET_RAW -- inibisce la possibilt&agrave; di aprire PACKET o RAW socket,
		ovvero quelle socket che consentono a programmi come hping o nmap di
		scrivere direttamente i pacchetti sulle interfacce di rete.
	<item>CAP_SYS_RAWIO -- inibisce la possibilit&agrave; di accedere direttamente
		ai dispositivi fisici. In pratica, non sar&agrave; pi&ugrave; possibile
		accedere a /dev/hda, /dev/hdb e cos&igrave; via.
	<item>CAP_SYS_PTRACE -- inibisce l'utilizzo di ``ptrace()'', la chiamata che 
		consente a comandi come strace, ltrace o gdb di seguire il comportamento
		di un processo. 
	<item>CAP_SYS_ADMIN -- inibisce:
		<itemize>
		  <item>la configurazione di quote su disco, la creazione di dispositivi,
		  	l'amministrazione di /dev/random e urandom.
		  <item>la configurazione dei messaggi inviati dal kernel a syslog, il cambio
		  	di nome di dominio, il cambio di hostname.
		  <item>l'utilizzo di mount e umount, l'abilitazione disabilitazione dello swap,
		    	la configurazione di dispositivi raid ed il tuning dei parametri ide.
		</itemize>
		e cos&igrave; via.
	</itemize>
	Per maggiori informazioni, potete dare un'occhiata a ``lids.planetmirror.com'' <!-- CROSS -->
	oppure cercare le ``capacit&agrave;'' direttamente in google.
	L'utilizzo di ``lcap'' apre diversi nuovi orizzonti. Si potrebbe, per esempio, inserire
	in init.d uno script simile al seguente: 
<tscreen><verb>
	#!/bin/bash

	lcap CAP_NET_BIND_SERVICE CAP_NET_ADMIN CAP_SYS_MODULE CAP_SYS_PACCT \
	     CAP_SYS_RESOURCE CAP_SETUID CAP_LINUX_IMMUTABLE CAP_NET_RAW CAP_SYS_RAWIO \
	     CAP_SYS_PTRACE CAP_SYS_ADMIN
</verb></tscreen>
	in modo da disabilitare la maggior parte delle funzioni che potrebbero risultare
	pericolose. Allo stesso modo, utilizzando il comando ``chattr +i'' si potrebbero
	impostare come immutabili tutti i file coinvolti con il processo di boot, cos&igrave;
	da impedire che il sistema possa essere riavviato senza chiamare ``lcap''.
	Per avere ancora una maggior sicurezza, si potrebbe poi disabilitare il ``reboot''
	del sistema, in modo che da remoto, anche ipotizzando che un attaccante possa
	riuscire a far s&igrave; che lcap non venga chiamato nel prossimo reboot, il
	sistema non possa essere riavviato senza la presenza fisica di una persona
	in sala macchine. In pi&ugrave;, lasciare la capacit&agrave; CAP_NET_ADMIN
	e CAP_NET_RAW impedir&agrave; all'attaccante di installare degli sniffer che 
	impostino l'interfaccia in promiscuous mode ed il cambio delle regole di
	firewalling. <p>
	Questo stesso script, potrebbe poi essere inserito in ``runlevel 2'',
	creando un link da /etc/rc2.d/S99-lcap a /etc/init.d/script_appena_creato,
	in modo che specificando qualcosa come ``runlevel=3'' dal prompt di lilo
	e di grub sia possibile accedere al sistema senza i limiti imposti da 
	questo comando.
</itemize>

<sect1>Rilevare le intrusioni<p>
Beh, di tool per rilevare le intrusioni ce ne sono a decine disponibili sulla 
rete. Alcuni che vi posso consigliare sono:
<itemize>
  <item>logcheck, per rilevare le differenze nei file di log in maniera più o meno
  	intelligente, in modo da non aver mega e mega di log da leggere ogni giorno.
  <item>tripwire o equivalenti (in debian sono disponibili debsums e debsig-verify, sicuramente molto
  	utili e funzionali), per rilevare modifiche non volute ai file.
  <item>msyslogd o syslog-ng, per essere sicuri che i log non vengano alterati (possono usare entrambi
  	dei sistemi di checksumming crittografici per memorizzare i log). Inoltre, sono in grado di trasmettere in
	maniera abbastanza sicura i log da una macchina all'altra. Questo potrebbe darvi garanzie
	ancora maggiori sull'autenticit&agrave; di questi log.
  <item>snort, per rilevare scansioni o attacchi conosciuti dalla rete (viene considerato un
  	IDS, ovvero, Intrusion Detection System).
  <item>netacctd, per tenere traccia delle connessioni effettuate.
  <item>arpwatch, per monitorare le workstation sulle varie reti ed eventualmente
  	rilevare tentativi di arp spoofing.
  <item>tcpdump, nel caso in cui il peggio accada, per loggare tutto il traffico
   	e tentare di risalire al colpevole (creando, magari, uno script che lo carichi
	come demone con delle opzioni tipo -nei eth0 -s 2048 -w /var/log/traffic.dump).
</itemize>
E molti altri... (suggerimenti sono benvenuti).

<sect2>Process accounting<p>
Abilitando nel kernel l'opzione ``General Setup/BSD Process Accounting'' &egrave; 
possibile utilizzare
il ``process accounting''. Il ``process accounting'' consente di mantenere
delle statistiche su ogni comando eseguito sul sistema, statistiche come
l'utente che l'ha eseguito, la cpu che ha utilizzato, il tempo che e`
stato eseguito e simili.<p>
Per utilizzare il process accounting &egrave; possibile installare
utility come ``acct'', ``lastcomm'' ed ``sa'', in Debian contenute tutte
nel pacchetto ``acct''. Questo stesso pacchetto si occupa durante
il processo di boot di chiamare ``accton nomefile.log'', che altro
non fa che abilitare il process accounting dicendo al kernel di
salvare le informazioni acquisite nel file di log indicato, generalmente
``/var/account/pacct''.<p>
Una volta abilitato, sar&agrave; possibile utilizzare utility
come ``sa'', per avere delle statistiche sugli ultimi comandi eseguiti e
``lastcomm'' per vedere i comandi eseguiti da ogni utente, divisi
per tempo di esecuzione, terminale da cui sono stati lanciati e da
alcuni flag indicanti come il comando sia stato eseguito.

<sect>Pericoli -- ovvero, da cosa dovr&agrave; difendervi il firewall<p>
Per rendere la trattazione pi&ugrave; semplice, &egrave; meglio chiarirsi 
le idee fin dall'inizio. Il firewall che andr&agrave; a proteggere la vostra
rete sar&agrave; in grado di filtrare il traffico secondo delle regole
da voi stabilite. Lo scopo di queste regole sar&agrave; quindi principalmente
quello di: 
<enum>
  <item>proteggere i vostri computer e i vostri server, rendendo accessibili
  	solo alcuni servizi dall'esterno della vostra rete.
  <item>fare in modo che gli utenti della vostra rete non facciano operazioni non consentite.
  <item>evitare che il traffico consentito possa provocare dei danni. Per spiegarmi meglio,
  	se aveste un web server interno alla vostra rete disponibile anche tramite internet,
	dovreste consentire il traffico sulla porta 80 ma al contempo fareste il possibile
	per evitare attacchi come syn flood o simili (vedi prossima sezione), conosciuti
	come ``DoS'' o ``DDoS'', rispettivamente ``Denyal of Service'' e ``Distributed
	Denyal of Service'', attacchi che mirano a sovraccaricare o a interrempore un
	servizio da voi offerto.
  <item>evitare che i vostri server o i vostri client possano essere utilizzati da qualcun
   	altro per sferrare degli attacchi a danni di terzi.
  <item>evitare il pi&ugrave; possibile i danni che vi potrebbe arrecare un attaccante
  	nel caso riuscisse ad impossessarsi di una delle vostre macchine o dei vostri
	server.
</enum>
Per quanto riguarda i primi 3 punti, non credo di aver detto nulla di originale. 
Normalmente lo scopo di un firewall &egrave; proprio quello o di proteggere 
servizi da noi offerti (o utilizzati internamente
alla nostra rete), o limitare ci&ograve; che i nostri utenti possono fare. <p>
Gli ultimi due punti, invece, vengono spesso sottovalutati o completamente ingorati, pur essendo
fondamentali per almeno due motivi:
<enum>
  <item>Per evitare un effetto ``domino'', per evitare cio&egrave; che ``caduto'' (bucato) un
  	server, questo possa essere sfruttato per far ``cadere'' tutti gli altri. Spesso infatti, quando una ditta dispone
	di pi&ugrave; server, vengono impostate delle politiche meno restrittive (se queste vengono
	impostate) per le comunicazioni da un server all'altro che potrebbero consentire ad 
	un attaccante di bucare una macchina e da l&igrave; bucare tutte le altre.
  <item>Per evitare che la vostra macchina possa essere utilizzata per sferrare attacchi a terzi.
  	Se tutti utilizzassero delle politiche di questo tipo sarebbe molto pi&ugrave; facile
	tracciare eventuali attaccanti.
</enum>
Una configurazione normalmente utilizzata che tiene in considerazione
tutti i punti sopra elencati fa uso di quella che viene detta una DMZ, ovvero di una
``Zona Demilitarizzata''.<p>
In pratica la rete di un'azienda viene divisa dal punto di vista hardware in tre segmenti, ed il firewall
viene dotato di 3 schede di rete (ognuna collegata ad un segmento). Di queste schede,
una viene collegata alla rete interna (utilizzata, per esempio, dai dipendenti), una collegata ad internet 
mentre l'ultima ad una piccola rete che conterr&agrave; soltanto i vostri server.<p> 
In questo modo, il firewall sar&agrave; in grado di proteggere i vostri server sia da attacchi 
provenienti dalla rete interna (e, da questo punto di vista, ci sono stati casi davvero eclatanti) 
sia da attacchi provenienti da internet.<p>
Allo stesso modo, sar&agrave; in grado di proteggere la vostra rete interna da attacchi provenienti
sia dai vostri server che da internet, e di proteggere internet da attacchi provenienti 
sia dai vostri server che dalla vostra rete interna. Il fatto che <it/sia in grado/ non implica 
per&ograve; che lo faccia sul serio. Spesso viene sottovalutata la pericolosit&agrave; di attacchi 
provenienti dai propri server o dalla propria rete interna e vengono scritte delle regole meno restrittive 
o non vengono scritte affatto.  Questo &egrave; un errore sicuramente da evitare. Un altro
errore da evitare &egrave; quello di non sfruttrae le capacit&agrave; di firewalling sui 
server, o di allentare le politiche di sicurezza ``visto che c'&egrave; il firewall'': &egrave;
vero che il firewall c'&egrave; e funziona, ma essere un po' paranoici il pi&ugrave; delle volte
non guasta. Pu&ograve; capitare, per esempio, di fare una modifica sul firewall dimenticandosi 
del tale server, piuttosto che cambiare lo spinotto a cui era collegato. 

<sect1>Assunzioni errate<p>
Esistono poi alcuni errori che &egrave; facile commettere o miti che &egrave; bene sfatare prima di 
fare delle assunzioni errate a proposito della propria rete. Tenete quindi ben presente
che in una rete:
<itemize>
  <item><bf/tutti i dati possono essere falsificati/ -- una ``scheda di rete'' non &egrave; altro
  	che un dispositivo fatto per scrivere su di una rete, un po' come una testina &egrave;
	in grado di scrivere su dei dischi magnetici. I pacchetti non sono altro che dati che vengono
	scritti su di una rete, e possono essere quindi falsificati o inventati di sana pianta. Nessuno
	mi impedisce di ``scrivere'' con la mia scheda di rete dei pacchetti che indicano
	come mittente il computer di qualcun altro o delle informazioni assolutamente insensate.
	Scrivete quindi sempre delle regole che vietino o consentano anche ci&ograve; che pu&ograve;
	sembrare ovvio. Per esempio,
	se avete una intefaccia collegata alla rete 10.0.0.0/8, potreste scrivere come prima
	regola ``vieta tutto ci&ograve; che viene dalla determinata scheda di rete ma che non
	ha 10.0.0.0/8 come indirizzo del mittente''. Pu&ograve; sembrare stupido, ma questo vi
	potrebbe evitare un sacco di problemi. Cosa succederebbe ad esempio se riceveste dei
	pacchetti provenienti da 127.0.0.1? Con queste regole verrebbero immediatamente scartati,
	ma senza (e con l'rp_filter disabilitato, vedi prossima sezione) &egrave; difficile valutare
	cosa succederebbe (soprattutto su sistemi non linux -- 127.0.0.1 &egrave; un indirizzo di loopback).
  <item><bf/un computer collegato ad una lan &egrave; in grado di vedere tutto il traffico in transito dalla
  	rete/ -- se <it/foo/ &egrave; collegato allo stesso switch
	di <it/bar/, <it/foo/ sar&agrave; in grado di vedere (sniffare, da ``fare sniffing'') tutto il 
	traffico generato o ricevuto da <it/bar/, a partire
	dalle email fino ad arrivare alle password per accedere ai siti ftp preferiti.
	E' credenza comune che gli switch siano pi&ugrave; sicuri degli hub e che non consentano
	questo tipo di operazioni. Si tratta per&ograve; di un'assunzione il pi&ugrave; delle
	volte errata. Per maggiori informazioni vi consiglio di dare un'occhiata alla sezione dedicata
	agli switch.
  <item><bf/&egrave; possibile fare hijacking e spoofing/ -- 
  	spoofing consiste nel fingersi qualcun altro. In una rete locale, &egrave; possibile
	fare spoofing molto facilmente, per esempio con quello che viene definito ``arp spoofing''.
	Anche volendo utilizzare tecniche di spoofing pi&ugrave; ``classiche'' basate sul protocollo tcp e ip
	non esistono molti problemi: su una rete locale, potendo vedere i pacchetti, non c'&Egrave;
	bisogno di indovinare alcun parametro, e non &egrave; quindi necessario utilizzare tecniche 
	di ``blind spoofing'', notoriamente pi&ugrave; complesse.
	L'hijacking consiste invece nel ``dirottare'' le connessioni di qualcun 
	altro, dopo che sono state stabilite. L'utilit&agrave; dell'hijacking si dimostra 
	ad esempio con protocolli non cifrati dove l'autenticazione viene effettuata 
	in modo sicuro. Facendo sniffing non sarebbe possibile rubare la password, mentre utilizzando 
	l'hijacking si potrebbe rubare la connessione dopo che l'amministratore (o il nostro bersaglio)
	ha effettuato il login con successo, evitando il problema di aver bisogno di una password.
  <item><bf/il protocollo udp &egrave; insicuro/ -- se il tcp fa uso di syn e ack
  	per verificare e rendere le connessioni pi&ugrave; sicure e affidabili, l'udp 
	non fa uso di nessuno di questi sistemi. E' quindi estremamente facile falsificare
	delle trasmissioni udp, anche al di fuori di una lan. <p>
  <item><bf/il dns non &egrave; sicuro/ -- Il protocollo dns fa uso del protocollo udp. E' 
  	quindi difficile considerarlo un protocollo sicuro (nonostante qualche precauzione 
	venga presa), soprattutto in una lan, dove &egrave; estremamente facile falsificare dei 
	pacchetti. In pi&ugrave; spesso si parte dall'assunzione che se la comunicazione 
	tra client e dns &egrave; sicura allora i dati forniti dal dns sono corretti. Anche in
	questo caso esistono delle tecniche (usate per lo pi&ugrave; in passato o con software
	dns di pessima qualit&agrave; - compresi quelli inclusi in alcuni sistemi operativi) che 
	consentono di inserire nel dns informazioni false (cache poisoning). Infine, l'amministratore
	del vostro dns (o qualcuno in grado di gestire il dns da voi utilizzato), pu&ograve; 
	modificare quasi a piacimento le associazioni tra nomi di dominio ed indirizzi ip forniti
	da tale dns. Non si dovrebbe quindi mai fare affidamento sull'autenticit&agrave; e 
	correttezza delle informazioni fornite da un dns.
  <item><bf/tutti i dati, se non cifrati, possono essere intercettati e letti da 
  	chiunque si trovi tra il mittente e il destinatario/
  <item><bf/se un protocollo &egrave; cifrato, non &egrave; detto che sia sicuro/ -- un problema
  	di internet e delle reti in generale non &egrave; soltanto il fatto che i dati 
	possono essere facilmente intercettati. Anche ipotizzando che tutte le connessioni 
	fossero cifrate, si creerebbe un problema di <it/autenticazione/. Per fare un esempio, se A deve 
	mandare dei dati a B in maniera sicura, pu&ograve; creare un canale 
	cifrato da A a B. Ma come fa A ad essere veramente sicura dell'identit&agrave; di B?
	Se io fossi C, interessato ai dati trasmessi, potrei fingermi B (con
	tecniche di spoofing o simili). In questo caso, la connessione tra A e B sarebbe
	ancora cifrata, ma i dati arriverebbero in realt&agrave; a C. Il problema, in questo
	caso, &egrave; l'autenticazione del server. Esistono diverse soluzioni
	per questo problema. Con ssh, &egrave; consigliabile utilizzare sempre crittografia asimmetrica
	(le famose chiavi di ssh) anzich&eacute; digitare le password e verificare sempre
	il ``fingerprint'', un numero che rappresenta la chiave del computer remoto e mostrato
	ad ogni connessione.<p> 
	Con protocolli come l'http, l'ftp, o la posta elettronica (sia pop che imap e smtp),
	&egrave; possibile fare uso di ``certificati'' emessi da particolari autorit&agrave;
	(autorit&agrave; che si fanno garanti della identit&agrave; dell'utilizzatore del
	certificato) che provino l'identit&agrave; del server.<p>
	In Italia purtroppo, per risparmiare qualche euro, si &egrave; instaurata la pratica
	di generare da s&eacute; i propri certificati senza utilizzare quelli emessi da
	particolari autorit&agrave; anche in strutture che per dimensioni, per necessit&agrave;,
	e per competenze tecniche dovrebbero per lo meno porsi qualche problema (parlo di 
	universit&agrave;, enti pubblici, e di alcune strutture che costituiscono lo scheletro
	di internet in Italia). Vorrei pertanto approfittare di questo documento per evidenziare 
	che se un certificato non &egrave; emesso da una autorit&agrave; riconosciuta o da 
	un'autorit&agrave; terza di cui avete ottenuto i certificati in maniera sicura 
	(<bf/non/ scaricandoli da internet), la validit&agrave; del certificato stesso dovrebbe 
	essere considerata <bf/nulla/. Non ignorate quindi la finestrella di IE o Mozilla
	che vi si presenta davanti dicendo che il certificato del sito non &egrave; valido:
	chiunque potrebbe aver generato tale certificato
	(man 1 openssl) ed essersi messo in mezzo tra voi ed il vostro sito. Non siate
	tolleranti e mandate email all'amministratore di tale rete finch&eacute; non avr&agrave; 
	acquistato un valido certificato!<p>
	Protocolli di autenticazione come kerberos invece, partono dal principio che non
	&egrave; solo l'utente a dover provare la sua identit&agrave; ma anche il server remoto. 
	In questo caso, se il server non &egrave; chi dichiara di essere non sar&agrave; in 
	grado di decifrare i dati dell'utente stesso.
  <item><bf/un firewall non &egrave; in grado di garantirvi la sicurezza/ -- 
  	se sulla vostra rete usate sistemi operativi notoriamente insicuri,
	potreste trovarvi facilmente dei troiani (virus particolari)
	installati che consentono a terzi di controllare i vostri computer
	da remoto, senza che il vostro firewall possa farci nulla. Una politica
	di sicurezza deve quindi comprendere molto pi&ugrave; di un singolo firewall.
  <item><bf/un sistema non &egrave; sicuro solo se non possono rubarvi dati/ --
  	per esempio, potreste trovarvi nelle condizioni
	di avere un servizio critico per la vostra azienda offerto da una macchina
	estremamente sicura. Cosa succederebbe per&ograve; se un attaccante riuscisse
	a sovraccaricarla di lavoro fino a bloccarla, pur senza riuscire 
	ad entrarvici? Vi posso garantire che il vostro boss non sarebbe affatto felice...
	In alcuni ambiti poi, un'interruzione di servizio potrebbe portare molti pi&ugrave;
	danni di quanti potrebbe causarne un'intrusione.
  <item><bf/esiste sempre qualcuno pi&ugrave; bravo, pi&ugrave; competente o pi&ugrave; 
 	 furbo di voi/ -- per
  	quante difese possiate approntare, esister&agrave; sempre quel bug di cui
	non siete a conoscenza o quella persona in grado di ``bucare'' il vostro
	sistema. Se avrete usato per bene le carte a vostra disposizione, sar&agrave; per lui una dura
	partita ed il pi&ugrave; delle volte moller&agrave; prima di raggiungere
	l'obiettivo. Sarete inoltre in grado di rendervi conto di quello
	che sta succedendo e dei problemi che si sono venuti a creare.
  <item><bf/non fidatevi/ -- sebbene possa sembrare un'osservazione faziosa 
  	e quasi paranoica, ricordatevi che avere il codice sorgente dei programmi
	che state utilizzando vi mette <it/direttamente/ nelle condizioni di poter
	verificare l'assenza di backdoor (porte sul retro, accessi lasciati dai programmatori)
	o l'assenza di bug ed errori che potrebbero compromettere la sicurezza della vostra rete.<p>
	Mettere a disposizione il codice sorgente di un determinato prodotto pu&ograve;
	quindi essere considerato come un atto di fiducia nei vostri confronti
	e costituire garanzia del buon operato dei programmatori coinvolti, che
	dimostrano di non aver nulla da nascondere n&eacute; a voi ``clienti'' n&eacute; 
	ad eventuali attaccanti. 
	Una cassaforte non dovrebbe essere considerata sicura perch&egrave; il suo 
	meccanismo &egrave; tenuto segreto (un meccanismo si pu&ograve; sempre studiare), 
	ma perch&egrave; pur rendendone pubblico il funzionamento <it/nessuno &egrave; in
	grado di aprirla/ se non utilizzando la combinazione impostata. <p>
	Quando comprate un apparecchio come uno switch, un router o un firewall, provate a cercare
	sul sito del produttore le procedure indicate per il recupero delle password 
	dimenticate: alcune volte vi verr&agrave; detto di rendere l'apparecchiatura
	raggiungibile tramite internet e di contattare il servizio di assistenza (non 
	&egrave; uno scherzo). Questo
	dovrebbe dirla lunga sull'assenza di backdoor e sulla sicurezza del prodotto.<p>
	Infine, se la vostra preoccupazione maggiore &egrave; la sicurezza, ricordatevi
	che spesso questo non &egrave; l'interesse maggiore di chi 
	vi vende un prodotto (e non sta a me ricordarvi che viviamo in un mondo dove 
	l'economia &egrave; basata sul marketing e sulla massimizzazione dei guadagni). 
	Non accontentatevi di belle parole o pubblicit&agrave;
	accattivanti: se vi verr&agrave; rilasciato il codice sorgente sarete in grado
	di verificare in prima persona la qualit&agrave; del prodotto.

<!--
	E se nascondere il codice
	di un prgramma pu&ograve; rendere pi&ugrave; difficile l'individuazione di
	errori sfruttabili da eventuali attaccanti, &egrave; altrettanto vero che
	questo n&eacute; rende pi&ugrave; difficile la correzione e l'individuazione
	anche da parte dei ``buoni'' e sicuramente non vi mette nelle condizioni di poter 
	agire direttamente.<p>
	Infine, se la vostra preoccupazione maggiore &egrave; la sicurezza, ricordatevi
	che spesso questo non &egrave; l'interesse maggiore di chi 
	vi vende un prodotto. Non accontentatevi di belle parole o pubblicit&agrave;
	accattivanti: chiedete dei fatti, chiedete che vi venga rilasciato il codice
	sorgente dei prodotti che utilizzate. Sarete cos&igrave; in grado di verificare
	con mano la qualit&agrave; di questi prodotti. E se solo raramente (se mai) vi 
	verranno rilasciati, &egrave; importante che i produttori inizino a percepire
	questa come un'esigenza dei consumatori.
	-->
</itemize>
Se pu&ograve; tranquillizzarvi, in questo momento non mi viene pi&ugrave; in mente
nulla da aggiungere. Spero che questa notte riusciate a dormire sonni senza incubi...<p>
Le solite raccomandazioni, ormai, credo che siano superflue: non scambiate mail con
password (&egrave; molto pi&ugrave; facile falsificare una mail che non intercettare
una comunicazione), scegliete password che non siano contenute in un dizionario e che
contengano caratteri maiuscoli e minuscoli, cifre e simboli, utilizzate tecnologie
di firma digitale e verificate l'identit&agrave; delle persone che vi richiedono
informazioni sensibili, magari richiamandole per telefono o utilizzando qualche
sorta di Web Of Trust.

<sect1>Sicurezza degli switch<p>
Alcuni paragrafi fa avevo parlato di switch e della loro sicurezza. La differenza
principale tra uno switch ed un hub, &egrave; che gli hub rimandano tutti i dati ricevuti
a tutti i computer collegati all'hub stesso, mentre gli switch si limitano ad inviare
i dati ricevuti ai soli computer coinvolti in una trasmissione. Teoricamente, quindi,
utilizzando uno switch non sarebbe possibile in una rete effettuare lo ``sniffing'' dei
dati trasmessi nelle connessioni tra altri computer.<p>
In pratica per&ograve;, gli switch sono in grado di isolare le connessioni mantenendo
in memoria una sorta di tabella che associa ad ogni cavo un computer. Per cui, quando
due computer devono comunicare, lo switch consulta questa tabella ed in base a questa
sceglie su quali cavi dovr&agrave; trasmettere il traffico.<p>
Questo modello presenta diversi problemi:
<itemize>
  <item>Prima di tutto, questa tabella viene creata in base al traffico che inizialmente
  	viene visto transitare. Per cui, generando traffico fasullo, &egrave; possibile
	imbrogliare lo switch facendogli credere che un altro computer &egrave; collegato
	al cavo cui si &egrave; in realt&agrave; collegati (e se su due cavi risulta uno
	stesso computer, lo switch, normalmente, riinvier&agrave; i dati trasmessi su
	entrambi i cavi).
  <item>In secondo luogo, gli switch sono collegabili in cascata. Questo comporta che nella
  	tabella nella memoria dello switch ad ogni cavo possa essere associato pi&ugrave;
	di un computer. La memoria di uno switch, per&ograve;, ha dimensione limitata e la
	maggior parte degli switch si comporter&agrave; esattamente come un hub nel caso
	esaurisse la memoria e non fosse pi&ugrave; in grado di mantenere tale tabella.<p>
	Questo principalmente per evitare malfunzionamenti in reti di grosse dimensione.  
  <item>In terzo luogo, &egrave; possibile collegare pi&ugrave; switch tra di loro utilizzando 
  	collegamenti multipli. Per esempio, una 
  	rete di medie dimensioni potrebbe utilizzare qualcosa come 20/30 switch, tutti
	collegati tra di loro. Se fossero tutti collegati in cascata, il guasto di
	uno switch comporterebbe il malfunzionamento di buona parte della rete (probabilmente, 
	dividerebbe la rete in due parti).<p>
	Normalmente quindi, si stabiliscono pi&ugrave; connessioni tra gli stessi 
	switch (stendendo pi&ugrave; cavi) in modo che il guasto di un solo apparecchio
	comprometta la funzionalit&agrave; dei soli computer connessi a tale apparecchio.<p>
	Per consentire l'utilizzo di percorsi multipli, gli switch devono costruirsi una
	sorta di ``mappa'' della rete in modo da sapere che percorso far fare ai vari pacchettini
	per evitare che si vengano a creare dei loop (pacchetti che continuano a rimbalzare
	da uno switch ad un altro senza mai arrivare a destinazione). Per costruire questa
	mappa, gli switch devono comunicare tra di loro con un protocollo chiamato spanning
	tree protocol (IEEE 802.1d, scambiandosi quelli che vengono detti BPDU). In questo caso, 
	quindi, un computer collegato allo switch potrebbe falsificare
	i dati del protocollo spanning tree in modo da far credere di essere a sua volta
	uno switch e di costituire il percorso pi&ugrave; breve per raggiungere determinati
	computer, in modo da intercettare il traffico di tali computer.
  <item>Infine, gli switch possono essere solitamente configurati tramite 
  	interfacce web o telnet, che non fanno uso di alcun protocollo crittografico
	o di particolari protezioni, se non un username ed una password.<p>
	Allo stesso modo vengono spesso utilizzati protocolli come l'snmp (``Simple
	Network Management Protocol'' - le prime versioni del protocollo, definito dall'RFC1157), 
	che non richiedono nemmeno una password, se non un semplice nome di comunit&agrave;.<p>
</itemize>
Se la sicurezza della vostra rete dipende molto dalla sicurezza dei vostri switch,
potreste considerare l'utilizzo di:
<itemize>
  <item>VLAN (IEEE 802.1q) -- questa tecnologia vi consente di assegnare un numero ad ogni porta di
  	uno switch. Una volta fatto questo, solo le porte con lo stesso numero potranno
	comunicare tra di loro. In pi&ugrave;, i collegamenti tra uno switch ed un altro
	passeranno per quelli che alcuni produttori chiamano ``trunk'', ovvero dei collegamenti
	dove tutti i dati, indipendentemente dal numero di VLAN, possono essere trasmessi.
	Attenzione per&ograve;, che alcuni switch supportano una modalit&agrave; di apprendimento,
	dove ad una porta &egrave; assegnata una particolare VLAN in base alle caratteristiche
	dei pacchetti trasmessi. Un utente malizioso, con questa funzionalit&agrave; abilitata,
	potrebbe fingersi un altro switch e farsi inviare tutti i pacchetti delle VLAN che gli
	interessano. Inoltre, linux supporta il VLAN tagging (802.1Q), ovvero &egrave; in grado 
	di creare delle interfacce virtuali su diverse VLAN, senza bisogno di hardware aggiuntivo.<p>
	Un altro vantaggio delle VLAN consiste nel fatto che alcuni switch possono essere configurati
	in modo che esista una VLAN amministrativa: in questo caso, le configurazioni potranno essere
	cambiate e visualizzate soltanto da computer connessi ad una di queste VLAN.
  <item>Alcuni switch supportano delle funzionalit&agrave; di sicurezza relative alle porte ethernet.
	Per esempio, alcuni switch possono essere configurati in modo che se su una determinata porta 
	viene visto un indirizzo ip o un mac address (o una coppia dei due) diversi da quelli impostati, la porta
	viene spenta. In pi&ugrave;, possono essere normalmente indicate delle associazioni statiche
	tra porte ed indirizzi ip o mac address, senza che per questo venga bloccata la porta.
  <item>A volte, lo spanning tree protocol pu&ograve; essere semplicemente disabilitato o perch&egrave;
  	l'hardware utilizzato consente di impostare dei percorsi alternativi manualmente, o perch&egrave;
	non &egrave; necessario per la topologia della rete. In altre situazioni, alcuni switch supportano 
	restrizioni (normalmente basate su VLAN) sull'invio e sulla ricezione di questi pacchetti.
</itemize>
Ricordatevi infine che un router od uno switch potrebbero costituire un obiettivo molto pi&ugrave; 
succulento di quanto possiate pensare: controllando un router, infatti, si potrebbe creare un tunnel 
tra la vostra rete ed una rete bersaglio, piuttosto che impostare delle regole per deviare o fare delle 
modifiche al traffico.

<sect>Preparare il kernel ad andare in rete -- overview di /proc <p>
Adesso che siamo consapevoli di quello che ci pu&ograve; accadere e di quali
siano i nostri obiettivi, iniziamo dando un'occhiata alla directory
<file>/proc/sys/net</file>. In questa directory ci sono dei file e delle 
directory che ci consentono di modificare il comportamento della nostra 
macchina in rete, che ci consentono cio&egrave; di modificare molti
dei parametri usati dal kernel per prendere le decisioni sui pacchetti
che riceve o che deve trasmettere. <p>
In pratica, ad ogni file contenuto in questa directory corrisponde una variabile,
il cui valore regola il funzionamento di una determinata parte del kernel.<p>
Le directory, invece, sono utilizzate semplicemente per raggruppare i file
e per renderne pi&ugrave; facile l'utilizzo.

<sect1>Utilizzo dei file in /proc<p>
Per conoscere il valore delle variabili impostate in tali file, &egrave; sufficiente 
leggere il contenuto del file stesso, utilizzando, per esempio, un ``cat nomefile''.<p>
Per modificare tale valore, &egrave; sufficiente scrivere il nuovo valore
all'interno del file utilizzando un comando 
simile a ``echo nuovovlaore > nomefile''.<p>
Per convenzione, una variabile che pu&ograve; assumere come valore 
``vero'' o ``falso'' oppure ``attivo'' o ``inattivo'' avr&agrave;
rispettivamente come valori 1 o 0.<p>
Per esempio, per disabilitare l'ecn (di cui si parler&agrave; tra
poco), baster&agrave; un comando simile a:
<tscreen><verb>
echo "0" > /proc/sys/net/ipv4/tcp_ecn
</verb></tscreen>
Le modifiche fatte in questo modo, per&ograve;, non vengono conservate
tra un reboot e l'altro. Per renderle definitive, &egrave; quindi necessario 
inserire i relativi comandi in un file eseguito all'avvio della macchina oppure
usare il file di configurazione <file>/etc/sysctl.conf</file>. In questo file
dovrete scrivere la ``variabile'' seguita da un ``='' e dal valore
che volete assegnare. Il nome della variabile corrisponde al nome
del file nella directory di proc, togliendo per&ograve; ``/proc/sys''
e sostituendo dei ``.'' alle ``/''. Per esempio, per disabilitare
per sempre l'utilizzo dell'ecn, sar&agrave; sufficiente aggiungere
la riga:
<tscreen><verb>
net.ipv4.tcp_ecn=0
</verb></tscreen>
nel file <file>/etc/sysctl.conf</file>.<p>

<sect1>Alcuni file importanti<p>
Alcune delle variabili in /proc/sys/net sono particolarmente importanti dal 
nostro punto di vista in quanto ci consentono di proteggere il kernel da diversi
tipi di attacchi.<p>
Di base, la directory che pi&ugrave; ci interessa di 
<file>/proc/sys/net</file> &egrave; sicuramente
<file>ipv4</file>.<p> 
In quest directory, dovreste trovare alcuni file tra cui:
<itemize>
  <item><it/icmp_echo_ignore_broadcasts/ -- questo file vi consente
  	di dire al kernel se accettare o ignorare dei ``ping'' inviati
	ad indirizzi di broadcast. Un ping non &egrave; altro che il 
	pacchetto generato dal comando ``ping'' per vedere se un computer
	&egrave; in funzione o meno. In questo caso, un valore di 0 (falso)
	dice al kernel di non ignorare i ping di broadcast, mentre un valore
	di 1 (vero) di ignorarli. Normalmente, &egrave; meglio impostare
	questo file ad ``1''. Provate ad immaginare cosa potrebbe succedere se 
	una persona qualsiasi mandasse un ping (aka icmp echo request) a 16 milioni 
	di computer, utilizzando come destinazione un indirizzo di broadcast
	e come mittente l'indirizzo ip del vostro computer.<p>
	Con una cinquantina di byte, vi manderebbe contro circa 16 milioni 
	di risposte al ping... (fortunatamente, la maggior parte dei computer
	in rete non rispondono a ping di broadcast).<p>
	Questa variabile viene principalmente utilizzata all'interno di
	net/ipv4/icmp.c:icmp_rcv.
  <item><it/icmp_ignore_bogus_error_responses/ -- disabilita o abilita 
 	il logging di risposte errate mandate da alcune apparecchiature di rete.
	Utile soltanto per evitare di riempire i vostri log. Fa riferimento
	principalmente all'RFC1122 e alla funzione icmp_unreach chiamata da icmp_rcv
	in net/ipv4/icmp.c.
  <item><it/ip_forward/ -- questo file, invece, vi consente di abilitare
    	o disabilitare il ``forwarding''. Il forwarding consiste
	nel consentire a linux di ``copiare'' i dati ricevuti da un'interfaccia
	di rete ad un'altra. Senza il forwarding abilitato, non potremmo
	utilizzare linux come firewall ed i pacchettini non potrebbero passare
	da un'interfaccia all'altra. 
  <item><it/ipfrag_*/ -- sebbene i default siano normalmente pi&ugrave;
        che validi, &egrave; bene spendere due parole sui terribili frammenti.
	Alcune reti, a livello hardware, non riescono a trasmettere pi&ugrave;
	di un numero di byte limitato per volta. Una rete ethernet per esempio,
	non consente di trasmettere pi&ugrave; di 1500 (circa) bytes
	per volta (questo limite viene anche detto MTU, ovvero Max Transfer Unit). 
	Esiste per questo un sistema per spezzettare i pacchetti
	ed inviarli come tante unit&agrave; indipendenti. Questi vengono normalmente
	chiamati frammenti e possono creare diversi problemi:
	<itemize>
	  <item>Per esempio, inviando frammenti sufficientemente piccoli la
	  	parte iniziale del pacchetto che contiene le informazioni sul
		protocollo tcp o udp viene suddivisa su pi&ugrave; pacchetti. 
		Queste informazioni per&ograve;, vengono utilizzate proprio dai
		firewall per capire la destinazione e lo scopo del pacchetto.
		In passato, alcuni firewall facevano semplicemente
		passare questi frammenti, altri si inceppavano, mentre 
		altri ancora li buttavano via. L'approccio utilizzato attualmente
		da linux &egrave; quello di assemblare lui direttamente come firewall 
		tutti i frammenti. In pratica, linux decider&agrave; se far passare o
		meno un pacchetto solo dopo averlo completamente riassemblato.
		Questo protegger&agrave; i nostri server anche da altri tipi di attacco.
	  <item>Al contrario, dividendo il pacchetto in frammenti sufficientemente 
	  	grossi, l'header tcp/udp viene inserito solo nel primo frammento. 
		Cos&igrave;, se arrivano prima frammenti successivi al primo, il 
		firewall deve decidere se
		far passare o meno il pacchetto senza avere tutte le informazioni
		necessarie a disposizione. Anche in questo caso, far assemblare
		i pacchetti al firewall pu&ograve; essere una buona soluzione.
	  <item>Un altro esempio &egrave; quello di alcuni attacchi che prendevano
		dei grossi pacchetti, li spezzettavano in frammenti molto
		piccoli e li mandavono poi ad una macchina bersaglio in un ordine 
		completamente casuale. <p>
		Questa macchina si doveva quindi prodigare per ricomporre
		il puzzle riordinando e riunendo i pacchetti nel corretto ordine,
		sovraccaricando notevolmente la cpu arrivando persino a bloccare
		la macchina.<p>
		Per rimediare, in linux si utilizzano proprio i file ipfrag_*. In 
		pratica, si stabiliscono dei limiti oltrepassati i quali linux si 
		``arrender&agrave;'' nel tentare di riordinare i pacchetti, evitando
		di bloccarsi su questo compito. I valori di default di tali limiti
		sono ben tarati, anche se
		potrebbe rendersi necessario abbassarli, a seconda della tipologia di macchina
		utilizzata e a secondo dell'attacco cui si &egrave; soggetti.<p>
		Capita raramente poi, che per migliorare le prestazioni di alcuni
		servizi, come per esempio NFS, tali limiti debbano essere alzati.
	  <item>Alcuni vecchi attacchi attualmente praticamente
	  	inoffensivi erano basati sul produrre frammenti che si sovrapponessero (``overlapping
		fragments'') in modo da portare i 
		sistemi operativi a sbagliare il calcolo della memoria da utilizzare, bloccando
		il sistema (CERT CA-1997-28).
	</itemize>
	Il significato dei file &egrave; quello classico di tutti i meccanismi
	basati su un limite (threshold). Quando la memoria utilizzata per riassemblare
	i frammenti supera ipfrag_high_thresh questi vengono bloccati fintanto che il valore non
	torna sotto ipfrag_low_thresh. ipfrag_time indica per quanto tempo al
	massimo un frammento pu&ograve; essere mantenuto in memoria. <p>
	Questi limiti sono utilizzati principalmente in net/ipv4/ip_fragment.c:ip_defrag ed
	ip_evictor.
  <item><it/tcp_ecn/ -- questo file regola l'utilizzo dell'ecn, ovvero ``Explicit
  	Congestion Notification protocol''. Non che sia un rischio per la sicurezza,
	ma spesso firewall vecchi non conformi agli standard (RFC3168) tagliano via tutte
	le connessioni che utilizzano questo protocollo. Se da linux non riuscite
	a collegarvi a dei siti che invece non avete problemi a raggiungere con
	altri sistemi operativi, probabilmente dovete disabilitare l'ecn. Sicuramente
	quindi, almeno finch&eacute; le cose non saranno cambiate, vi conviene
	tenerlo sempre disabilitato.
  <item><it/tcp_max_syn_backlog e tcp_syncookies/ -- un altro tipo di attacco,
  	abbastanza pericoloso e abbastanza in voga di questi tempi viene detto
	syn flood, ovvero inondazione di syn (CERT CA-1996-21). Il giochetto 
	anche in questo caso &egrave; molto semplice: viene inviato il pacchetto 
	tcp per iniziare
	una connessione ma non ne viene mai confermata l'apertura, costringendo
	il sistema operativo a ricordarsi di questa connessione in attesa che
	una conferma venga inviata.<p>
	Facendo un paio di grossolani conti, considerando che esistono 65535 porte
	e che per ogni porta devono poter essere accettate pi&ugrave; connessioni,
	&egrave; abbastanza evidente che il kernel di un qualsiasi sistema operativo
	non pu&ograve; permettersi di ricordarsi tutti i pacchetti di inizio delle
	connessioni ricevuti. In pratica, per ogni porta viene creata una coda di 
	dimensioni molto piccole (si parla di numeri nell'ordine delle decine o 
	centinaia). 
	Quando questa coda &egrave; piena, la porta non pu&ograve; pi&ugrave; accettare
	pacchetti. A peggiorare la situazione, le rfc indicano un timeout abbastanza 
	alto (nell'ordine dei minuti) prima che il kernel possa buttare via questi 
	pacchetti, svuotando la coda e dedicandosi ad altro. E' quindi abbastanza facile
	dimostrare che
	un attaccante, mandando pochi kilobyte di syn al secondo con un semplice modem 
	56k, pu&ograve; rendere inutilizzabile una porta di un qualsiasi server, senza 
	nemmeno alzare il carico della cpu n&eacute; saturare la banda.<p>
	Le soluzioni sono diverse, ma poche si sono rivelate veramente valide:
	<itemize>
	  <item>alcuni firewall limitano il numero massimo di syn al secondo inviati
	  	ad ogni server protetto, facendo in modo che quando questo limite
		viene sorpassato vengano fatti passare ``equamente'' (e ci sono diverse discussioni
		su cosa si debba intendere per ``equamente'') syn inviati da mittenti
		diversi.  Il problema &egrave; che essendo
		sufficiente un basso numero di syn al secondo per bloccare
		un server, &egrave; difficile riconoscere un attacco da un comportamento
		``legale''. Esistono diversi algoritmi per gestire queste situazioni, e 
		su internet sono disponibili i benchmark sull'efficacia di questo tipo
		di protezione, divisi per firewall e per rivenditore (cercate con google!).
		Non si tratta comunque della soluzione migliore ed &egrave; stato mostrato
		che con attacchi di particolari dimensioni si tratta di una difesa molto
		poco efficace che pu&ograve; tagliare facilmente del traffico che invece
		dovrebbe essere consentito.  
	  <item>un approccio pi&ugrave; efficace adottato da altri firewall si &egrave; 
	  	rivelato quello di far gestire le connessioni dal firewall stesso.
		In pratica, quando il firewall riceve un syn, questo ``si finge'' il server 
		fino al ricevimento dell'ack di conferma della connessione. A questo punto,
		stabilisce una connessione ``vera'' con il server fingendosi il client
		dopodich&eacute; fa continuare la connessione come se il client ed il server
		si parlassero direttamente.<p>
		In questo modo, un syn flood andrebbe a colpire solo il firewall proteggendo
		molto efficacemente i server.<p>
		Firewall di questo tipo sono poi strutturati in modo da resistere 
		molto bene a dei syn flood anche con un numero molto alto di syn al
		secondo, utilizzando tabelle pi&ugrave; grosse di quanto si possa permettere 
		un normale server e creando delle infrastrutture dinamiche in grado di gestire
		tali situazioni.
	  <item>molto originale invece &egrave; l'approccio utilizzato da linux e da
	  	molti altri sistemi. Il sistema viene chiamato syn cookie, ``biscottini
		nel syn''. Tornando a parlare di three way handshake e tcp, quando un 
		syn viene ricevuto (e per syn si intende un pacchetto che contenga il
		numero iniziale di sequenza, o numero di sincronia, e il cui syn flag
		sia settato), il sistema che lo riceve deve rispondere a sua volta 
		inviando un syn con un ack. Questo secondo syn &egrave; normalmente un numero casuale difficile
		da indovinare ed &egrave; proprio dopo aver inviato quest'ultimo che il sistema deve
		rimanere in attesa del famoso ack.
		Il sistema utilizzato dai syn cookies
		consiste nel prendere un numero non casuale da inviare  
		che contenga quelle informazioni (o parte di quelle 
		informazioni) che verrebbero memorizzate nella famosa coda (se ci 
		fosse spazio a disposizione...). 
		In pratica, una volta che la coda &egrave; piena, le informazioni
		che dovrebbero essere memorizzate vengono inviate nel syn ack di
		risposta. Se l'handshake viene completato correttamente dal client
		inviando l'ack finale (il terzo passo dell'handshake), le informazioni
		vengono estratte dal pacchetto ricevuto (l'ack di risposta viene
		sempre calcolato a partire dal syn, ed &egrave; quindi possibile
		partendo da un ack ricalcolare il syn originale), non risentendo
		quindi del problema.<p>
		Il syn per&ograve;, deve continuare ad essere difficilmente indovinabile 
		ed aumentare di pacchetto in pacchetto (non avrebbe ragione di esistere
		altrimenti, e sono condizioni imposte dall'rfc 793). Vengono quindi normalmente utilizzate
		delle funzioni one-way o degli hash che rispecchino queste
		caratteristiche, e l'informazione inviata si riduce normalmente
		in un ``connessione inizializzata correttamente'' (per maggiori informazioni,
		potete vedere il file <file>net/ipv4/tcp_ipv4.c</file>, in particolare
		la funzione tcp_v4_conn_request, oppure il 
		file <file>drivers/char/random.c</file> funzione secure_tcp_syn_cookie per
		sapere come un syn cookie viene calcolato).
		Il problema &egrave; che 
		&egrave; stato dimostrato che in particolari condizioni con particolari
		versioni del kernel linux era possibile indovinare questi syn e 
		fare spoofing delle connessioni tcp. Sebbene attacchi di questo tipo
		siano stati raramente (se mai) utilizzati (non mi riferisco allo spoofing 
		in generale, pratica largamente utilizzata, ma all'indovinare i syn grazie
		a questo bug nella creazione dei syn cookies), &egrave; bene abilitare i syn 
		cookies solo su kernel relativamente recenti (dal 2.4.6 in su funzionano
		sicuramente correttamente), o in particolari condizioni
		(quando si &egrave; sotto attacco, per esempio).<p>
		Ultima cosa da dire a proposito dei syn cookies &egrave; che questi vengono
		considerati da alcuni violare lo standard del tcp (ci sono state diverse discussioni 
		in proposito, si veda per esempio il sito http://cr.yp.to/syncookies.html, di Dan Bernstein) e 
		possono quindi introdurre dei problemi. I syn cookies, se abilitati,
		verranno quindi utilizzati da linux soltanto nel caso in cui la famosa coda si
		riempia.
	</itemize>
	Tornando a parlare dei file in /proc, tcp_max_syn_backlog consente di specificare
	il numero massimo di connessioni che possono rimanere in coda per ogni porta (normalmente &egrave;
	impostato a 128 su sistemi con meno di 32 mega di ram e a 1024 su tutti gli altri
	sistemi - net/ipv4/tcp.c:tcp_listen_start, net/ipv4/tcp-ipv4.c:tcp_v4_conn_request e tcp_synq_is_full)
	mentre tcp_syncookies consente di abilitare o disabilitare i syn cookies. <p>
	Rimane soltanto da aggiungere una cosa: come si fa a rendersi conto di essere sotto
	syn flood? Beh, con i syn cookies disabilitati, potreste dare un comando come:
 	<tscreen><verb>
	  &num; netstat -npla |grep SYN_RECV
	</verb></tscreen>
	Normalmente, dovreste vedere non pi&ugrave; di 1-2 connessioni provenienti da
	indirizzi ip diversi. Se ne vedete pi&ugrave; di una trentina, allora &egrave; molto
	probabile che vi troviate sotto syn flood. Per esperienza, posso dirvi che con
	un kernel 2.2 senza i syn cookies abilitati con circa 110-120 connessioni in 
	SYN_RECV la porta attaccata diventava irraggiungibile.<p>
	Per avere una ulteriore conferma, potreste infine verificare con tcpdump...
	se arrivano dei nuovi syn da uno stesso ip prima ancora che voi abbiate risposto 
	con un altro syn-ack o dopo aver temporaneamente bloccato l'ip o il demone
	responsabile della porta, allora siete sotto syn-flood. Anche questa prova per&ograve;
	non pu&ograve; essere considerata definitiva: il syn-flood viene considerato un blind
	attack, ovvero un attacco che non ha bisogno di ricevere le risposte per poter essere
	effettuato, per cui &egrave; estremamente semplice utilizzare dei ``mittenti'' 
	falsificati nei pacchetti (ed utilizzare quindi ip multipli e differenti). L'ip che vedete in 
	netstat o tcpdump potrebbe quindi essere quello di qualcuno che 
	nulla ha a che vedere con l'attacco. L'unica condizione perch&egrave; un ip possa essere utilizzato &egrave; infatti che
	questo risulti irraggiungibile dalla vostra macchina (altrimenti manderebbe un reset
	dopo il vostro syn-ack). Infine, nel caso in cui il kernel si trovi a dover far uso
	dei syn cookies, dovreste vedere dei messaggi nei file di log.
  <item><it/directory conf/ ok, qua dentro trovate i parametri per le singole interfacce
  	di rete. A parte ``all'' e ``default'', che consentono rispettivamente di cambiare i
	parametri di tutte le interfacce o i default per le future
	interfacce, ogni sottodirectory contiene i parametri di una singola interfaccia di 
	rete.<p>
	Diamo quindi un'occhiata alla directory all (o eth0, o lo, o...):
	<itemize>
	  <item><it/accept_redirects/ fa in modo che vengano accettati redirect dalla particolare
	  	interfaccia. Un redirect consiste ``in un suggerimento'' per un percorso ``migliore''
		per raggiungere un determinato punto (RFC792, pagina 12). Il problema &egrave; che &egrave; facile
		dare questi ``suggerimenti'' deviando il traffico a proprio piacimento (o comunque
		in modo da poter fare cose poco piacevoli). Un tempo i redirect erano molto pericolosi,
		adesso vengono accettati solo se determinate condizioni vengono verificate. Per un firewall,
		&egrave; comunque bene disabilitare questi redirects, o se necessario affidarsi
		a demoni come zebra o bird  e a protocolli pi&ugrave; evoluti per aggiornare dinamicamente 
		le tabelle di routing.
	  <item><it/secure_redirects e send_redirects/ consentono rispettivamente di accettare
	 	i redirect che rispettino condizioni molto pi&ugrave; stringenti di quelle
		normali e di generare i redirect per gli altri host. In pratica, viene verificato
		che il redirect venga inviato da un gateway di default conosciuto 
		(net/ipv4/fib_semantics.c:ip_fib_check_default chiamato da route.c:ip_rt_redirect).
	  <item><it/accept_source_route/ fa in modo che vengano accettati ``source route'', ovvero
	 	pacchetti che chiedono che la risposta passi da determinati routers. Sebbene questo
		non sia un problema in se stesso, &egrave; meglio disabilitare questa opzione 
		per rendere la vita pi&ugrave; difficile a coloro che tentino la strada dello spoofing. Uno
		dei problemi principali dello spoofing &egrave; infatti quello di mettersi
		in grado di poter ricevere le risposte dei pacchetti falsificati, ed il 
		source_route facilita notevolmente il raggiungimento di questo obiettivo. 
		La maggior parte dei provider, infatti, bloccano pacchetti che utilizzano questa
		opzione del protocollo ip.
	  <item><it/forwarding e mc_forwarding/ abilitano o disabilitano rispettivamente il 
	  	forwarding ed il forwarding dei pacchetti di multicast per la singola interfaccia
		(lo stesso forwarding di cui parlavamo prima). Attenzione per&ograve; che il
		forwarding dei pacchetti di multicast ha bisogno di un demone di supporto.
	  <item><it/rp_filter/ abilita o disabilita il ``reversed path filter''. Con questo filtro
	  	abilitato, viene verificata la coerenza dell'indirizzo ip del mittente di un pacchetto 
		rispetto l'interfaccia su cui tale pacchetto &egrave; stato ricevuto e le informazioni
		contenute nelle tabelle di routing. In caso le informazioni non risultino coerenti,
		il pacchetto viene scartato. Quest'opzione pu&ograve; creare problemi con tabelle di 
		routing particolarmente complesse (utilizzando ip rule, per esempio, e tabelle di routing
		multiple) o quando si fa uso di link asimmetrici, ovvero dove le richieste escono
		da un'interfaccia mentre le risposte ritornano su un'altra (con collegamenti satellitari,
		per esempio, dove le richieste escono dal telefono e le risposte arrivano sulla
		parabolica). Utilizzato principalmente in sys/net/ipv4/fib_frontend.c:fib_validate_source.
	  <item><it/log_martians/ fa in modo che pacchetti strani, improbabili o impossibili 
	  	vengano registrati nei file di log. Il problema 
		&egrave; che a volte, magari con particolari configurazioni, un po' troppi pacchetti
		vengono loggati.
	</itemize>
</itemize>

<sect>Filtrare il traffico con iptables<p>
Di base, tutte le distribuzioni mettono a disposizione dei tool per configurare
la rete. Se avete molta fiducia nella vostra distribuzione o gli script sono 
particolarmente ben fatti, potete tranquillamente usare quelli... per quanto mi
riguarda, pur avendo molta fiducia negli script forniti con debian,
preferisco escludere completamente il supporto della distribuzione 
in maniera da non avere limiti e da poter usare con tranquillità le patch
sopra installate ed in modo da evitare interazioni non volute con script o programmi
di cui spesso non si ha il pieno controllo. Nelle prossime sezioni configureremo
un firewall ``from scratch'', aggiungendo cioè i nostri script in /etc/init.d
in modo che vengano caricati automaticamente all'accensione della vostra
macchina. 

<sect1>Preambolo<p>
Ok, il nostro primo script si chiamerà conffw. Ovviamente non dovrete scrivere i 
numeri di riga, usati soltanto per rendere la trattazione più semplice.<p>
Iniziamo allora con:
<tscreen><verb>
0: &num;!/bin/bash
1: echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts 
2: for a in /proc/sys/net/ipv4/conf/*/rp_filter; do 
3:     echo 1 &gt; &dollar;a 
4: done
5: echo 1 &gt; /proc/sys/net/ipv4/tcp_syncookies
6: echo 0 &gt; /proc/sys/net/ipv4/tcp_ecn
</verb></tscreen>
In queste prime righe, ci limitiamo a dire al kernel di ignorare 
i ping di broadcast e di abilitare l'rp_filter su tutte le interfacce.
Infine, abilitiamo i syn cookies e disabilitiamo l'ecn (vedi sezione
precedente per una spiegazione pi&ugrave; approfondita). In
maniera perfettamente equivalente avremmo potuto scrivere 
in /etc/sysctl.conf:
<tscreen><verb>
net.ipv4.icmp_echo_ignore_broadcasts=1
net.ipv4.conf.all.rp_filter=1
net.ipv4.conf.default.rp_filter=1
net.ipv4.tcp_syncookies=1
net.ipv4.tcp_ecn=0
</verb></tscreen>

<sect1>Configurare le interfacce<p>
Da adesso in poi prover&ograve; ad andare avanti configurando un ipotetico
firewall collegato ad un'ipotetica rete e spiegando man mano i vari passi. Inizier&ograve; 
quindi ora descrivendo
l'ipotetica rete che verr&agrave; utilizzata nei prossimi esempi. Nel nostro
caso, quindi, il firewall sar&agrave; equipaggiato con:
<itemize>
 <item>
una interfaccia eth0 collegata alla rete interna, con indirizzo 192.168.200.254
 e netmask 255.255.255.0.
 <item>
una interfaccia eth1 collegata alla nostra DMZ, con indirizzo 123.45.67.9 con netmask
 255.255.255.248, dove per DMZ si intende la rete dove verranno attaccati tutti quei
 server disponibili sia dall&apos;interno che dall&apos;esterno della nostra rete.
 <item>
ed infine una interfaccia eth2 collegata con il mondo esterno, con indirizzo
 123.45.68.1, netmask 255.255.255.0 e con gateway su 123.45.68.254.
</itemize>
Ok, una volta definito il comportamento di base del firewall e 
la configurazione hardware, possiamo andare avanti configurando le varie 
schede di rete tramite il comando ``ip'':
<tscreen><verb>
8: ip addr add 192.168.200.254/24 dev eth0
9: ip addr add 123.45.67.9/29 dev eth1
10: ip addr add 123.45.68.1/24 dev eth2
</verb></tscreen>
Vi rimando ad altra documentazione disponibile sul mio sito per una discussione sul comando
 ip. Vi basti sapere che in questo modo abbiamo configurato le schede
 di rete senza attivarle come indicato sopra.<p> A questo punto, possiamo
 dedicarci ad iptables e ad impostare le regole di firewalling vere e proprie.<p>
E' importante non abilitare le interfacce di rete in modo da evitare che i pacchetti
inizino a fluire prima che le regole di firewalling siano state aggiunte.

<sect1>Il comando iptables <p>
Sicuramente se avete sentito parlare di linux e di firewalling,
 avete anche sentito parlare di ipchains e di ipfwadm. Questi comandi
 consentivano l'impostazione delle regole di firewalling rispettivamente
 nei kernel 2.2 e 2.0. Nei kernel dal 2.4 in poi è stato introdotto un nuovo 
 comando: iptables, anche se il supporto sia per ipchains che ipfwadm è rimasto.<p>
Dovendo parlare di iptables, è indispensabile una piccola introduzione. Il parente 
più stretto di iptables è sicuramente ipchains. ipchains aveva introdotto il concetto
di ``catena''. iptables ha ripreso
il concetto di catena per estenderlo tramite l'introduzione di tabelle.<p>
Prima di parlare di tabelle però, ci conviene chiarire il
concetto di catena. L'idea di base è abbastanza semplice: un computer collegato 
in rete con una o più interfacce ha a che vedere con tre tipi di pacchetti:
<itemize>
  <item>Pacchetti destinati al firewall stesso
  <item>Pacchetti che devono transitare dal firewall ma destinati a qualcun'altro
  <item>Pacchetti originati dal firewall stesso
</itemize>
Di default ipchains ed iptables mettono quindi a disposizioni rispettivamente 3 catene:
<itemize>
  <item>La catena di input
  <item>La catena di forward
  <item>La catena di output
</itemize>
In un computer normale (o in un server) verrebbero principalmente utilizzate
le catene di input e di output per filtrare il traffico ricevuto e generato
dalla macchina presa in considerazione.<p>
In un firewall invece, i pacchetti transiterebbero da una scheda di rete 
all&apos;altra, passando quindi attraverso la catena di forward.<p>
Ogni catena è poi costituita da un insieme di regole. Ad ogni regola, è 
associata un&apos;azione (target). Ogni volta che un pacchetto transita per una catena, 
tutte le regole vengono controllate in ordine, dalla prima inserita fino all&apos;ultima. 
Quando una regola risulta applicabile al pacchetto (viene trovato un match) viene applicata 
al pacchetto l&apos;azione specificata e viene interrotto il processo di ricerca. <p>
Se non viene trovata una regola applicabile al pacchetto, la sua sorte (l'azione 
d'applicare) viene scelta in base alla politica (policy) della catena stessa. In pratica,
la policy indica cosa fare di tutti i pacchetti che non rientrano in nessuna regola.<p>
Sia ipchains che iptables poi, consentono di creare o rimuovere catene e di specificare
come azione quella di percorrere un'altra catena.
<p>Detto così può sembrare tutto molto complesso, ma vedrete che poi nella pratica diventerà 
molto più semplice.<p>

<sect1>Definizione delle policy<p>
Iniziamo quindi a parlare di iptables, ed iniziamo proprio definendo la ``politica'' di default
delle catene di base, cioè l'azione che deve essere presa nel caso in cui nessuna regola
si possa applicare al particolare pacchetto. Per fare questo, basta dare:
<tscreen><verb>
12: iptables -P INPUT DROP
13: iptables -P OUTPUT DROP
14: iptables -P FORWARD DROP
</verb></tscreen>
Qui vediamo proprio che se un match non viene trovato, i pacchetti devono essere ``buttati via'' (DROP),
proprio come se non fossero mai stati ricevuti (o richiesto l'invio, a secondo della catena).<p>
Oltre a DROP, esistono molte altre azioni che è possibile specificare, dove le principali sono:
<itemize>
  <item>ACCEPT -- lascia passare il pacchetto
  <item>QUEUE -- passa il pacchetto ad un programma in userspace
</itemize>  
Di base, le due azioni che userete di più sono ACCEPT e DROP. QUEUE difficilmente
lo userete. Spesso però vi capiterà di usare delle ``target extensions'', ossia
dei particolari target che sono forniti tramite dei moduli esterni (vi ricordate
tutte le patch applicate col patch-o-matic? Molte hanno dato origine a dei nuovi
target). <p>
E' buona abitudine mettere come politica di default quella di buttare via i pacchetti,
dopodich&egrave; consentire esplicitamente tutto ci&ograve; che vogliamo fare passare.
Questo principalmente per due motivi:
<itemize>
  <item>&egrave; facile rendersi conto di cosa si &egrave; dimenticato chiuso (molti dei
  	vostri utenti vi telefoneranno fino alla saturazione delle linee telefoniche pur di vedere il
	loro client preferito funzionare), mentre &egrave; molto pi&ugrave; difficile
	vedere cosa si &egrave; dimenticato aperto.
  <item>non &egrave; facile riconoscere tutto ci&ograve; che c'&egrave; da bloccare. Per esempio,
	Usando una politica
	di ACCEPT, &egrave; estremamente difficile prevedere ci&ograve; che potr&agrave; essere
	utilizzato per aggirare le restrizioni, contando che spesso non &egrave; obbligatorio
	seguire gli standard e una persona un po' sveglia potrebbe modificare il kernel di 
	due macchine linux per utilizzare un protocollo che nulla ha a che vedere col tcp
	e che mai noi ci saremmo immaginati di dover bloccare (trattandosi, magari, di un
	protocollo inventato di sana pianta)...
</itemize>
Un comando che vi pu&ograve; essere utile nello scrivere le regole si chiama ``nstreams'':
questo stamper&agrave; a video l'elenco di tutte le connessioni in corso su una rete...

<sect1>La nostra configurazione<p>
Prima di andare avanti e definire le regole di firewalling, dobbiamo avere un'idea
chiara di cosa vogliamo fare con la nostra rete.
Prima di procedere, è quindi fondamentale un minimo di pianificazione. Nel nostro caso,
abbiamo una dmz, una lan ed un collegamento ad internet.<p>
Abbiamo un firewall con tre interfacce di rete, ognuna collegata ad una rete diversa e 
abbiamo quindi una connessione ad internet relativamente lenta (rispetto
alle altre due reti).
L'idea di base è quella di mettere nella dmz i server e di fare in modo da risparmiare banda,
inserendo un proxy server.<p>
Sulla nostra dmz, ci troveremo quindi:
<itemize>
  <item>un web server, ad uso sia interno che esterno
  <item>un mail server (pop3 e smtp), ad uso sia interno che esterno
  <item>un proxy server, soltanto ad uso interno
  <item>un dns, ad uso sia interno che esterno
</itemize>
Per quanto riguarda le altre restrizioni da imporre alle comunicazioni tra le 
varie reti (ad esempio, non vogliamo che gli utenti della lan controllino altre
caselle di posta elettronica oltre quelle fornite dal nostro mail server), ne 
parleremo in ogni specifica sezione.<p>

<sect1>Prime catene<p>
Ok, due sezioni fa abbiamo detto al kernel di buttare via tutto quanto può avere a che fare
col nostro computer. Per andare avanti nella nostra configurazione, dobbiamo quindi
indicare cosa invece lasciare passare. Questo si fa aggiungendo delle regole. Una
soluzione potrebbe essere quella di aggiungere tutte le regole relative al traffico
che vogliamo lasciare passare nelle 3 catene di base. Funzionerebbe, ma vi posso garantire 
che sarebbe molto facile commettere degli errori e vi posso garantire che altrettanto 
facilmente diventerebbero così tante da non poter essere più gestibili. <p>
Uno degli approcci più semplici nella gestione delle regole di firewalling è quindi quello
di dividere il traffico in ``flussi'' di dati dopodichè considerare indipendentemente ogni 
singolo flusso, evitando così di avere tutte le regole insieme e formalizzandosi in modo da 
evitare gli errori più comuni.<p>
Analizzando il nostro esempio, potremmo quindi dividere il nostro traffico in 6 grandi
flussi:
<itemize>
 <item>
tutto ciò che dalla lan va alla dmz
 <item>
tutto ciò che dalla lan va su internet
 <item>
tutto ciò che dalla dmz va su internet
 <item>
tutto ciò che dalla dmz va sulla lan
 <item>
tutto ciò che da internet va sulla nostra dmz
 <item>
tutto ciò che da internet vuole andare sulla nostra lan
</itemize>
Possiamo poi, per esempio, creare per ogni flusso una catena e ad ogni
catena associare un suo insieme di regole indipendenti da quello di 
tutte le altre catene.<p>
Ma andiamo per gradi: iniziamo a creare delle nuove catene. Per 
fare questo dobbiamo eseguire iptables seguito da un ``-N'' e da un
nome per la catena:
<tscreen><verb>
16: iptables -N landmz       &num;dalla scheda di rete eth0 alla scheda di rete eth1
17: iptables -N laninet      &num;dalla scheda di rete eth0 alla scheda di rete eth2
18: iptables -N dmzinet      &num;dalla scheda di rete eth1 alla scheda di rete eth2
19: iptables -N dmzlan       &num;dalla scheda di rete eth1 alla scheda di rete eth0
20: iptables -N inetdmz      &num;dalla scheda di rete eth2 alla scheda di rete eth1
21: iptables -N inetlan      &num;dalla scheda di rete eth2 alla scheda di rete eth0
</verb></tscreen>
Per il kernel, però, il nome che abbiamo dato ed il commento non hanno alcun
significato. Dobbiamo quindi trovare un modo per indicare quali catene devono essere
percorse in quali situazioni. Per fare questo, possiamo specificare 6 semplici
regole. Trattandosi di regole per traffico che non &egrave; n&eacute; originato
n&eacute; destinato al firewall, dovremo inserirle nella catena di FORWARD.
Per esempio, potremmo dare dei comandi come:
<tscreen><verb>
23: iptables -A FORWARD -i eth0 -o eth1 -j landmz
24: iptables -A FORWARD -i eth0 -o eth2 -j laninet
25: iptables -A FORWARD -i eth1 -o eth2 -j dmzinet
26: iptables -A FORWARD -i eth1 -o eth0 -j dmzlan
27: iptables -A FORWARD -i eth2 -o eth1 -j inetdmz
28: iptables -A FORWARD -i eth2 -o eth0 -j inetlan
</verb></tscreen>
Il significato di queste righe è molto semplice: aggiungi (-A, append) alla
catena FORWARD, una regola per cui se un pacchetto proviene dalla scheda
di rete eth0 (-i) ed è destinato ad uscire dalla scheda eth1 (-o), la sua
sorte deve essere decisa (-j) dalla catena landmz e così via. In pratica,
abbiamo diviso tutti i pacchetti in transito nella catena di forward in
6 categorie, dove ogni categoria ha associata una catena e quindi una 
serie di regole. Riassumendo:  
<itemize>
  <item><it/-N/ crea una nuova catena
  <item><it/-A/ aggiunge una regola ad una catena
  <item><it/-i/ consente, in una regola, di discriminare i pacchetti in
  	base all'interfaccia fisica da cui sono entrati
  <item><it/-o/ in base all'interfaccia fisica da cui usciranno (scelta
  	in base alle tabelle di routing da noi impostate)
  <item><it/-j/ di mandare i pacchetti ad un'altra catena
</itemize>
Abbiamo visto quindi come una regola può identificare dei pacchetti in 
base alle schede di rete coinvolte. E' però possibile utilizzare molti
altri criteri, per esempio:
<itemize>
  <item>il protocollo (-p)
  <item>l'indirizzo ip sorgente (-s)
  <item>l'indirizzo ip destinazione (-d)
  <item>se si tratta di un frammento (-f)
  <item>o se non lo è (! -f)
</itemize>
Dove ogni protocollo può aggiungere dei criteri di classificazione. Per esempio,
se specifichiamo ``-p tcp'' per indicare il protocollo tcp, possiamo poi dividere
i pacchetti in base anche 
<itemize>
  <item>alla porta sorgente (--sport)
  <item>alla porta destinazione (--dport)
  <item>ai flag del tcp (--tcp-flags SYN, ACK, FIN...)
  <item>alle opzioni (--tcp-option)
</itemize>
Anche in questo caso, oltre alle estensioni fornite dai protocolli, è possibile
utilizzare delle estensioni fornite da moduli.<p>
A questo punto però, vi sarà venuto spontaneo chiedervi perché effettuare una
prima classificazione in base all'hardware e non, ad esempio, in base all'indirizzo
ip sorgente o all'indirizzo ip destinazione. Ancora una volta, la risposta è molto semplice:
il contenuto di un pacchetto si può falsificare. Il fatto che arrivi su un'interfaccia
piuttosto che un'altra, no. Utilizzando almeno per le prime regole le interfacce
di input e quelle di output, avremo quindi la certezza che i pacchetti saranno valutati
dalle regole contenute nella catena corretta e che nessuno potrà imbrogliarci utilizzando
ip fasulli (ancora, cosa succederebbe se basassimo le nostre regole solo sugli indirizzi ip
e qualcuno ci mandasse dei pacchetti provenienti da 127.0.0.1 con l'rp_filter disabilitato?).<p>

<!--
<sect2>Perch&egrave; usare le catene<p>
Ci sono diversi motivi validi per creare ed utilizzare le catene:
<itemize>
  <item>Prima di tutto pu&ograve; portare ad un formalismo 
  	che pu&ograve; aumentare la chiarezza delle vostre regole in maniera
	non indifferente, facilitando il compito di trovare errori
	di configurazione.<p>
	Nell'esempio mostrato poi, dividendo le regole per flussi e
	facendo delle piccole modifiche a delle singole catene, andremmo
	ad intaccare soltanto il traffico facente parte del determinato 
	flusso. Se non usassimo questo accorgimento, un piccolo errore
	potrebbe compromettere il funzionamento dell'intera rete.
  <item>In secondo luogo, una lista di regole deve essere consultata
  	dal netfilter fino a trovare una corrispondenza. Dividendo in catene, la
	ricerca si ferma alla fine della catena utilizzata. Avendo
	un totale di 40 regole, dividendole in 4 catene avremmo che
	nella peggiore delle ipotesi 10 (14, se ipotizziamo che debbano 
	essere percorse 4 regole prima di trovare la catena corretta da 
	utilizzare) regole verrebbero controllate
	(l'algoritmo di verifica delle regole lo potete vedere in 
	<file>linux/net/ipv4/netfilter/ip_tables.c</file>
	nella funzione ip_packet_match e ipt_do_table, riga 315 nel kernel
	2.4.18).<p>
	Al contrario, senza usare le catene, tutte e 40 le regole
	dovrebbero essere verificate. Avendo tante regole, pu&ograve;
	essere una buona cosa dividere razionalmente in catene, 
	anche per velocizzare il processo di ricerca. 
  <item>In terzo luogo, utilizzando le catene sarebbe possibile creare 
 	delle ``funzioni'', un po' come in un linguaggio di programmazione,
	utilizzando il target ``RETURN''. Ad esempio, si potrebbe
	creare una ``MACRO'' ``drop_web'' per bloccare il traffico web,
	con qualcosa come:
<tscreen><verb>
iptables -N drop_web
iptables -A drop_web -p tcp &min;&min;dport 80 -j DROP
iptables -A drop_web -p tcp &min;&min;dport 445 -j DROP
iptables -A drop_web -j RETURN
</verb></tscreen>
	utilizzandola poi con qualcosa come:
<tscreen><verb>
iptables -I INPUT -j drop_web
iptables -I INPUT -j allow_ftp
[...]
</verb></tscreen>
	ovviamente, iptables ed il meccanismo delle catene non sono stati
	fatti per questo, ed utilizzarli in questo modo non credo porti 
	a particolari benefici, oltre alla leggibilit&agrave; e ad una maggior
	user friendness. Se poi si tiene in considerazione il fatto che
	ogni ``MACRO'' aggiunge due regole che devono essere controllate...
	conviene cercare di usare questi metodi saggiamente.
</itemize>
Comunque, i primi due motivi sono pi&ugrave; che sufficienti per 
giustificare l'utilizzo delle catene. Non dite poi che non vi
avevo avvertito.
-->

<sect2>Dalla LAN alla DMZ<p>
Ricordandoci della configurazione della nostra ipotetica rete, abbiamo deciso
che dalla nostra lan vogliamo che tutte le richieste per
 pagine web vengano deviate sul nostro server proxy (transparent proxy) in maniera trasparente,
 che i nostri utenti non controllino altre caselle di posta elettronica
 se non quelle da noi fornite, che possano collegarsi al nostro server
 web direttamente e che siano in grado di scaricare file con ftp direttamente
 da internet. Dall&apos;esterno, vogliamo soltanto rendere accessibile
 il nostro dns, il server di posta elettronica, il nostro server web
 ed il server ftp. Ma lavoriamo anche qua per flussi, in modo da semplificare
 un po' le cose.<p>
 Iniziamo allora a creare le regole per la nostra
 lan, lasciando indietro (per ora) ciò che riguarda il ``deviare''. Dalla lan
 alla dmz, vogliamo quindi consentire:
<p>
<itemize>
 <item> le connessioni al nostro server web (www)
 <item> le connessioni per spedire la posta (smtp)
 <item> le connessioni per ricevere la posta (pop3)
 <item> le connessioni verso il server proxy (webcache)
 <item> nonché le connessioni necessarie per utilizzare il nostro dns
        (domain)
</itemize>
Aggiungiamo quindi le regole corrette, esattamente come indicato
 qua sopra:
<tscreen><verb>
30: iptables -A landmz -s ! 192.168.200.0/24 -j DROP
31: iptables -A landmz -p tcp -d nostro.server.web --dport www -j ACCEPT
32: iptables -A landmz -p tcp -d nostro.server.smtp --dport smtp -j ACCEPT
33: iptables -A landmz -p tcp -d nostro.server.pop3 --dport pop3 -j ACCEPT
34: iptables -A landmz -p tcp -d nostro.server.proxy --dport webcache -j ACCEPT
35: iptables -A landmz -p tcp -d nostro.dns --dport domain -j ACCEPT
36: iptables -A landmz -p udp -d nostro.dns --dport domain -j ACCEPT
</verb></tscreen>
Prima di tutto, qua dentro sarebbe molto meglio indicare direttamente
 degli indirizzi ip al posto dei nomi dei computer. Come abbiamo gi&agrave; detto,
 infatti, il protocollo dei DNS deve essere considerato insicuro. Se proprio
 volessimo usare i nomi dei computer, potremmo utilizzare il vecchio file
 degli hosts, in /etc/hosts, dove ogni linea &egrave; formata dall'indirizzo
 ip di un computer seguito dal suo nome (e separati da spazi).<p>
 Come potete vedere, questa volta le regole le ``appendiamo'' (-A) non più alla
 catena di FORWARD bensì alla catena landmz, trattandosi di regole
 che andranno a discriminare il traffico tra la nostra lan e la nostra
 dmz.<p>
 Ora, la prima regola indica che non vogliamo
 che passi niente che non abbia un indirizzo ip proveniente dalla
 nostra rete interna. Questa regola eviter&agrave; quindi che qualcuno
 dei nostri utenti possa fare spoofing verso la nostra dmz o che comunque
 tenti di imbrogliarci con dei giochi strani sull'indirizzo ip. E' una
 regola un po' superflua, avendo gi&agrave; abilitato la protezione del
 kernel, ma a volte &egrave; meglio aggiungere qualche regola in pi&ugrave;
 piuttosto che avere qualche regola in meno (e poi, siete sicuri che nelle
 prossime versioni del kernel il filtro sar&agrave; ancora disponibile o
 che si comporter&agrave; sempre nello stesso modo?).<p>
 Le altre sono ancora regole molto semplici. Le uniche novità introdotte 
 rispetto prima sono la negazione (il !), che indica che perché una regola venga 
 applicata una certa condizione <bf/non/ deve essere soddisfatta, ed il fatto 
 che finalmente potete vedere diversi criteri messi in pratica. -s, specifica 
 un ip sorgente e può essere seguito da un indirizzo ip o da un indirizzo di rete (indicato 
 come x.x.x.x/y) o dal nome di un host. -p può essere seguito dal nome o dal numero 
 di un protocollo (file <file>/etc/protocols</file> conserva le associazioni). 
 -d, ancora, indica la destinazione di un pacchettino e può essere 
 seguito sempre da un indirizzo ip, da un nome di host o da un indirizzo di rete (con lo stesso 
 formato indicato prima). --dport, invece, indica una porta di destinazione e può essere seguito 
 da un numero o dal nome di una porta (il file <file>/etc/services</file> conserva le associazioni). 
 In tutti i casi, è possibile usare la negazione 
 dopo l'indicazione del criterio.<p> Infine, ACCEPT dice ad iptables di accettare tali 
 pacchetti nel caso in cui la regola risulti applicabile. Per configurare un firewall, è 
 necessaria una buona conoscenza dei vari
 protocolli di rete: l&apos;ultima riga è stata aggiunta in quanto il protocollo
 per la comunicazione con i dns utilizza il più delle volte connessioni
 udp, mentre utilizza connessioni tcp solo in condizioni particolari. Senza questa
 regola, il dns avrebbe funzionato sempre tranne qualche volta, e sarebbe stato estremamente
 difficile trovare il problema (se mai ce ne fossimo resi conto).<p>
 Per chi di voi si fosse invece chiesto come si fa a specificare una rete o
 che senso ha il /24, basti sapere che si tratta di un sistema estremamente
 comodo per indicare le netmask. Per esempio, una netmask 255.255.255.0 indica che se i
 primi 24 bit di due indirizzi ip sono uguali, allora i due si
 trovano sulla stessa rete (255.255.255.0 scritto in notazione binaria sarebbe
 11111111.11111111.11111111.00000000, con 24 uno). 255.255.255.0 è quindi equivalente a /24 (ogni
 ottetto - 255 - sono 8 bit).<p>
 Visto però che si tratta delle prime regole ``serie'' della nostra trattazione,
 vediamo comunque di descriverle a parole, un po' come abbiamo fatto prima:
<itemize>
  <item>30: Butta via ogni pacchetto in transito nella catena landmz che <bf/non/ venga
        da un indirizzo ip facente parte la nostra lan. 
  <item>31: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 80 (www) del nostro.server.web
  <item>32: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 25 (smtp) del nostro.server.smtp
  <item>33: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 110 (pop3) del nostro.server.pop3
  <item>34: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 8080 (webcache) del nostro.server.proxy
  <item>35: Accetta ogni pacchetto udp in transito dalla catena landmz destinato alla porta 53 (dns) del nostro.dns
  <item>36: Accetta ogni pacchetto tcp in transito dalla catena landmz destinato alla porta 53 (dns) del nostro.dns
  <item>(Butta via tutto il resto, come definito dalla policy)
</itemize>
Ad alcuni di voi sar&agrave; venuto spontaneo chiedersi come mai &egrave; stata messa come
prima regola un ``butta via'' con una negazione, anzich&egrave; una pi&ugrave; semplice accetta 
(qualcosa del tipo: accetta ogni pacchetto in transito nella
catena landmz che viene da un indirizzo ip facente parte della nostra lan). 
Il problema &egrave; che il controllo delle regole si ferma alla prima regola soddisfatta. Se fosse stata quindi
un'accept, la regola sarebbe stata soddisfatta per ogni pacchetto proveniente dalla lan, e la scansione
delle regole non sarebbe andata avanti a quelle successive, vanificando buona parte del nostro lavoro. 
Un'altra possibilit&agrave; sarebbe stata quella di omettere la prima regola e di specificare ogni 
volta esplicitamente l'indirizzo ip, aggiungendo alle righe dalla 31 alla 36 qualcosa come ``-s 192.168.200.0/24''.
Siccome per&ograve; sono una persona molto pigra, ho scelto il metodo pi&ugrave; veloce da scrivere.<p>
L'ultima regola indicata tra parentesi, poi, non è stata da noi scritta: &egrave; implicitamente aggiunta
dalla policy (DROP) che abbiamo deciso di utilizzare.<p>
L'esperienza però mi insegna che a questo punto potrebbe essere conveniente inserire come regola 38 qualcosa
di simile a:
<tscreen><verb>
38: iptables -A landmz -p tcp -j REJECT --reject-with tcp-reset
</verb></tscreen>
Questo ha a che vedere con i meandri del tcp. Ma vediamo di spiegarla in poche parole: quando
avviene una connessione TCP/IP, ha luogo il solito ``three way handshake''. In pratica, per
avere la certezza che i pacchetti arrivino a destinazione, il computer A manda un messaggio
del tipo ``questo &egrave; il mio numero, e se ci sei, mandami il tuo'', dopodichè il computer B 
risponde con un messaggio del
tipo ``ho ricevuto il tuo numero, questo è il mio'', infine il computer A risponde dicendo ``ho ricevuto
il tuo numero'' e la comunicazione ha inizio. Normalmente però, rispettando il protocollo TCP/IP, 
se il computer A dovesse tentare di collegarsi ad una porta chiusa (ad un servizio non disponibile) su
B, allora B dovrebbe rispondere con ``la porta è chiusa''.<p> Ma vediamo cosa succede nel nostro caso:
<itemize>
  <item>Tra <it/A/ e <it/B/ c'è il nostro firewall <it/F/.
  <item><it/A/ manda il messaggio a <it/B/ ad una porta non consentita.
  <item>senza regola 38, <it/F/ riceve il messaggio e lo butta via.
  <item><it/A/ rimane in attesa di una risposta per parecchi secondi e ci riprova, sempre con
  	lo stesso risultato.
  <item>A questo punto, <it/A/ è rimasto in attesa di un tempo valutabile in minuti, mentre <it/B/
        è rimasto inconsapevole di tutto. 
</itemize>
Bene, la regola 38 dice che per ogni connessione tcp arrivata in fondo alla catena (essendo stata aggiunta
per ultima), invece di essere buttato via il pacchetto, deve essere utilizzata l'estensione (modulo
esterno) REJECT per mandare un ``tcp-reset'', il messaggio che indica il fatto che la porta è chiusa.<p>
Vediamo però che il target REJECT è stato specificato semplicemente con un -j, come per tutti gli 
altri target. Quando si parla di target, infatti, non c'è alcuna differenza tra ``estensioni'' esterne
e target forniti direttamente da iptables, se non la pagina di manuale.<p>
Alcuni di voi si potranno chiedere a questo punto ``ma che diavolo, cosa mi interessa se l'altro tentando di accedere
ad una porta non consentita rimane in attesa?? Così impara per la prossima volta...''. 
Beh, ci sono almeno tre buoni motivi per non lasciarlo in attesa:
<itemize>
  <item>A volte, quando vi collegate per esempio ad un server di posta elettronica, alcuni sistemi
  	fanno quello che viene definito un ``ident lookup'', cercano cioè di capire chi siete 
	collegandosi alla porta 113 della vostra macchina, dove teoricamente ci dovrebbe essere un
	demone in ascolto che fornisce questo tipo di informazioni.<p>
	Il problema &egrave; che questi sistemi non vi fanno accedere al servizio fino a quando
	non scoprono la vostra identit&agrave; o non appurano che il vostro sistema non offre questo
	servizio (rispondendo che la porta &egrave; chiusa). In entrambi i casi, il sistema remoto
	rimane in attesa di una risposta, e se questa non arriva, pu&ograve; ipotizzare due cose:
	<enum>
	  <item>che la richiesta sia andata persa
	  <item>che il vostro computer sia improvvisamente morto
	</enum>
	Proveranno quindi a rimandare il pacchetto per diverse volte prima di arrendersi e farvi entrare
	(ma come, il vostro computer non era morto? Non ha risposto quando abbiamo tentato di contattarlo...), 
	introducendo spesso dei delay valutabili nell'ordine 
	delle decine di secondi o addirittura dei minuti.<p>
	L'esempio più classico è questo, ma altri protocolli usano un approccio simile, 
	e vi posso garantire che una regola come la 38 può evitarvi diversi delay nell'utilizzo della rete 
	altrimenti difficilmente spiegabili.
  <item>Molti ``scanner'' sono tratti in inganno da questa regola che fa credere loro che la porta sia
  	effettivamente chiusa rendendo quindi più difficile l'identificazione del firewall (vi siete 
	mai chiesti come nmap faccia ad indicare che una porta &egrave; ``filtered'' piuttosto che
	``closed''?). Attenzione però che
	scanner più intelligenti potrebbero rilevare le differenze di TTL (il firewall si trova un passo
	prima del vero client), rendendo vano tale tentativo (se volete divertirvi, date un'occhiata al 
	target TTL, che vi consente di evitare persino quest'effetto).
</itemize>
Questa regola la vedrete apparire molto spesso nelle catene seguenti, sempre per lo stesso motivo...
Dovremmo quindi aver finito con il traffico dalla LAN alla nostra DMZ.


<sect2>Dalla DMZ alla LAN<p>
Ok, qua (a dirsi) le cose sono molto più semplici: dobbiamo consentire
soltanto quei pacchettini in risposta alle richieste partite dalla LAN (i
server non si devono connettere di loro spontanea volontà ai nostri client -- teoricamente,
nessuno dovrebbe usarli).<p>
Fare questo in ipchains era una cosa abbastanza complessa: 
bisognava specificare delle regole per consentire ogni tipo di pacchetto
che ci sarebbe potuto tornare in risposta (giocando con l'opzione --syn, che 
seleziona i pacchetti che stabiliscono nuove connessioni) e si doveva quindi avere una buona
conoscenza (se non ottima) dei vari protocolli. iptables facilita molto le cose
tramite l'introduzione di ``moduli per il tracciamento delle connessioni''
(conntrack -- uno dei molti vantaggi dei firewall statefull rispetto quelli stateless).<p>
Vediamo quindi una delle soluzioni che potremmo adottare:
<tscreen><verb>
40: iptables -A dmzlan -s ! 123.45.67.9/29 -j DROP
41: iptables -A dmzlan -m state --state ESTABLISHED,RELATED -j ACCEPT
42: iptables -A dmzlan -p tcp -j REJECT --reject-with tcp-reset
</verb></tscreen>
Bene, il primo comando è la solita regola per evitare lo spoofing.
Il secondo invece, è diverso da ogni altro comando finora incontrato:
-m chiede ad iptables di caricare un modulo esterno, in questo caso il modulo
state (si ricorda lo stato delle connessioni), per il tracciamento delle connessioni. 
L'opzione --state relativa
al modulo state è quello che ci permette di identificare i pacchetti: in pratica,
la regola ha come significato quello di consentire tutti i pacchetti
facenti parte connessioni già stabilite (ESTABLISHED, e se sono già stabilite vuol dire
che sono state consentite) e tutte quelle connessioni relative a connessioni già esistenti (RELATED).
<p>In questo caso, la parolina magica è proprio RELATED. Ci consente cioè di scaricare
sul modulo state la responsabilità di identificare i pacchettini che non soltanto
sono risposte a pacchetti già inviati, ma anche quelli che fanno parte dello stesso protocollo.<p>
Vediamo però qualche esempio:
<itemize>
  <item>Quando volete scaricare un file tramite ftp il vostro browser (o qualsivoglia programma stiate
        utilizzando) apre prima una connessione di controllo sul server remoto, sulla classica
	porta 21. Dopodich&eacute; si mette d'accordo con il computer remoto su una porta da utilizzare
	per creare una nuova connessione per l'invio dei dati. Ma proprio qui sorge il problema:
	per passare dal nostro firewall (che ha una politica di DROP), questa connessione dovrebbe
	essere esplicitamente consentita a priori con una regola che termina con un -j ACCEPT. 
	A priori, però, non possiamo creare questa regola in quanto non sappiamo le porte che verranno utilizzate
	(possono essere liberamente negoziate sia dal client che dal server). La soluzione normalmente adottata
	prima dell'introduzione dei moduli di tracciamento
	era molto semplice: consentire tutte le connessioni salvo quelle a porte problematiche. Il modulo
	state, invece, ci viene in aiuto aggiungendo e rimuovendo regole dinamicamente secondo quanto necessario.
  <item>Il protocollo ip lavora in collaborazione con il  
  	protocollo ICMP che viene utilizzato per la segnalazione e la gestione degli errori. 
	Ebbene, senza utilizzare il modulo state con l'opzione
	RELATED, avremmo dovuto impostare per ogni connessione consentita una regola del tipo ``consenti tutti i messaggi
	di errore relativi a questa connessione'', oppure consentire l'entrata di tutti i pacchetti ICMP di 
	alcuni tipi. Bene, il modulo state si prende in carico anche di questo aggiungendo e togliendo regole
	dinamicamente ed in maniera trasparente.
</itemize>
La differenza &egrave; quindi questa: ESTABLISHED, fa passare tutti i pacchetti che fanno parte
di una connessione gi&agrave; stabilita, mentre RELATED fa passare tutti i pacchetti di controllo (errori,
piuttosto che...) o connessioni relative alle connessioni conosciute.<p>
Se state configurando un firewall, però, e la vostra preoccupazione principale è la sicurezza, vi
sarà sorta spontanea una domanda: ``e se qualcuno imbrogliasse il modulo di state, facendo aprire
connessioni non volute?''. Bene, in passato qualche problema di questo tipo è stato sollevato,
ma il codice del netfilter dovrebbe essere attualmente abbastanza maturo per evitare questo tipo di
problemi. <p> Vi consiglio però di seguire le mailing list dedicate, per essere eventualmente
prontamente avvisati di possibili problemi, e di leggere qualche documento in pi&ugrave; sul funzionamento
del protocollo ftp.<p>
Attenzione però che perch&eacute; le regole sopra elencate funzionino, potrebbe essere necessario caricare
dei moduli nel kernel, con comandi del tipo ``modprobe ip_conntrack'',
``modprobe ip_conntrack_ftp'', ``modprobe ip_conntrack_altri_moduli_di_protocolli_che_volete_utilizzare''.<p>
Per quanto riguarda le prestazioni, il modulo state utilizza un po' più di risorse rispetto 
alle regole manuali, ma comunque nulla di rilevante se rapportato ai vantaggi che offre (alcune cose,
non &egrave; proprio possibile farle con firewall stateless, a meno di non aprire migliaia di porte).<p>
Un'altra cosa da dire è che prima, nella definizione della catena dalla LAN alla DMZ, ho volutamente
dimenticato la regola 37:
<tscreen><verb>
37: iptables -A landmz -m state ESTABLISHED,RELATED -j ACCEPT
</verb></tscreen>
che sarebbe stata troppo prematura da discutere. In pratica, anche dalla 
lan alla dmz &egrave; importante far passare tutti quei dati relativi a connessioni
gi&agrave; stabilite o comunque i messaggi di errore.
Probabilmente non molto importante per reti di piccole dimensioni,
ma rilevante in reti più grosse o con regole più complicate. Anche questa regola la
vedrete apparire molto spesso.

<sect2>Dalla LAN ad Internet<p>
Dalla nostra lan ad internet vogliamo invece essenzialmente
 che passi traffico ftp (che non può essere deviato sul proxy), in modo che gli utenti 
 possano scaricare
 direttamente il loro materiale. Per fare questo, basta aggiungere
 le regole:
<tscreen><verb>
44: iptables -A laninet -s ! 192.168.200.0/24 -j DROP
45: iptables -A laninet -p tcp --dport ftp -j ACCEPT
48: iptables -A laninet -m state ESTABLISHED,RELATED -j ACCEPT
49: iptables -A laninet -p tcp -j REJECT --reject-with tcp-reset
</verb></tscreen>
Dove però non c'è nulla di nuovo di cui parlare...

<sect2>Da Internet alla LAN<p>
Infine, per terminare con la nostra lan:
<tscreen><verb>
50: iptables -A inetlan -s 192.168.200.0/24 -j DROP
51: iptables -A inetlan -s 123.15.67.9/29 -j DROP
52: iptables -A inetlan -m state --state ESTABLISHED,RELATED -j ACCEPT
53: iptables -A inetlan -p tcp -j REJECT --reject-with tcp-reset
</verb></tscreen>
In questo caso, le prime due regole bloccano tutti quei pacchetti
che hanno come mittente l'indirizzo di una delle nostre due reti.<p>
La terza regola, invece, consente a tutte le connessioni create
dall'interno di poter ricevere una risposta, senza dover scrivere
troppe regole.<p>
All'epoca di ipchains invece, non c'era un modo di ``tenere traccia'' 
delle connessioni ed era quindi necessario aprire molte più porte per consentire a
 ftp di funzionare, cosa che diminuiva notevolmente l'efficacia
 del firewall.

<sect2>Da Internet alla DMZ<p>
 Andiamo avanti ora con la configurazione della nostra
 dmz. Abbiamo detto che da internet saranno accessibili i seguenti
 servizi:
<itemize>
  <item>server web
  <item>server smtp
  <item>server dns
  <item>server ftp
</itemize>
Che si traduce linearmente in qualcosa del tipo:
<tscreen><verb>
54: iptables -A inetdmz -s 192.168.200.0/24 -j DROP
55: iptables -A inetdmz -s 123.15.67.9/29 -j DROP
56: iptables -A inetdmz -p tcp -d nostro.server.web --dport www -j ACCEPT
57: iptables -A inetdmz -p tcp -d nostro.server.smtp --dport smtp -j ACCEPT
58: iptables -A inetdmz -p tcp -d nostro.dns --dport domain -j ACCEPT
59: iptables -A inetdmz -p udp -d nostro.dns --dport domain -j ACCEPT
60: iptables -A inetdmz -p tcp -d nostro.ftpserver --dport ftp -j ACCEPT 
61: iptables -A inetdmz -m state --state ESTABLISHED,RELATED
62: iptables -A inetdmz -p tcp -j REJECT --reject-with tcp-reset
</verb></tscreen>
In questo caso, la prima regola &egrave; un po' superflua ma estremamente
importante. I nostri server, infatti, potrebbero essere configurati per essere un 
po' meno restrittivi nei confronti dei nostri utenti. Se qualcun altro
riuscisse da internet ad usare i nostri indirizzi ip, sarebbe in 
grado di usufruire di questi benefici.

<sect2>Dalla DMZ ad Internet<p>
Dalla DMZ ad Internet, invece
<tscreen><verb>
63: iptables -A dmsinet -s ! 123.15.67.9/29 -j DROP
64: iptables -A dmzinet -p tcp -s nostro.server.smtp --dport smtp -j ACCEPT
65: iptables -A dmzinet -p udp -s nostro.server.dns --dport domain -j ACCEPT
66: iptables -A dmzinet -p tcp -s nostro.server.dns --dport domain -j ACCEPT
67: iptables -A dmzinet -p tcp -s nostro.server.proxy --dport www -j ACCEPT
68: iptables -A dmzinet -m state --state ESTABLISHED,RELATED -j ACCEPT
69: iptables -A dmzinet -p tcp -j REJECT --reject-with tcp-reset
</verb></tscreen>
Qui qualche commento è doveroso farlo... <p>
La prima regola consente al server smtp di inviare la 
posta elettronica dei nostri utenti.<p>
Dello stesso tipo sono la seconda e terza regola, che consentono
invece al dns server di effettuare delle query ricorsive ed eventualmente
degli zone transfer. <p>
La quarta regola, infine, è quella che consente al proxy server di uscire
all'esterno a procurarsi le pagine non in cache. Attenzione, però, che 
a secondo delle configurazioni del vostro proxy server, potrebbe essere
necessario aprire più porte (per fare comunicare più proxy tra di loro,
per consentire l'utilizzo al proxy del protocollo ftp...).<p>
Le ultime due sono le solite regole:
consenti le risposte alle richieste effettuate, chiudi le connessioni
tcp vietate.
<p>

<sect2>Traffico da e per il firewall<p>
Come ultima cosa, ci rimane da filtrare il traffico originato o destinato
al firewall direttamente.
Giusto a titolo esemplificativo, ecco alcune regole:
<tscreen><verb>
71: iptables -A INPUT -m limit --limit 10/min -p tcp --syn --dport ssh -j ACCEPT
72: iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT
73: iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
74: iptables -A INPUT -p tcp -j REJECT --reject-with tcp-reset

75: iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</verb></tscreen>
Buona norma sarebbe quello di consentire il meno possibile verso il 
firewall, e di bloccare tutto ciò che può da lui essere originato.
In questo caso, viene accettato il traffico ssh ed i ping (non sempre una buona
idea) e tutto il traffico relativo, mentre in uscita vengono consentite solo le risposte ai
pacchettini ricevuti. Se utilizzate demoni come zebra o simili, potrebbe essere
necessario aprire più porte ed allentare un po' la cintura soprattutto per quanto
riguarda icmp. Ricordatevi inoltre che se non viene specificata esplicitamente
una interfaccia, la catena di INPUT e di OUTPUT determineranno il comportamento
di <bf/input e output/ da tutte le interfacce (compreso il loopback!!!). State
quindi molto attenti a quello che fate.<p>
Potete vedere anche l'utilizzo di un nuovo
modulo: il limit, che consente di impostare dei limiti di frequenza,
e per la prima volta dell'opzione (tcp) --syn, che seleziona soltanto
le nuove connessioni (i famosi pacchettini ``mandami il tuo numero'').
Questo per evitare un problema con ssh segnalato diverso tempo fa (e probabilmente
già corretto) per cui in determinate condizioni e con reti molto veloci
era possibile fare hijacking di una connessione tentando di indovinare
alcuni parametri. <p>
Ultima cosa importante da dire prima di passare ad altro: a differenza
da ipchains, in iptables ciò che non è esplicitamente consentito non passa (o
vice versa, a secondo della policy). Per esempio, nel nostro caso un client
interno alla rete non potrebbe ``pingare'' alcun server all'esterno n&eacute; sarebbe
in grado di utilizzare altri messaggi ICMP che non siano imparentati (related)
con connessioni esistenti.<p>
Con questo paragrafo viene chiuso l'argomento filtraggio. Nel prossimo paragrafo
si parler&agrave; infatti del NAT e di come fare quelle ``deviazioni'' di cui 
ci siamo temporaneamente dimenticati.<p> 
Lo scopo era quello di introdurre l'utente all'uso di
iptables e di metterlo nelle condizioni di poter leggere facilmente le pagine
del manuale, dove può trovare un elenco di tutti i possibili match
che si possono effettuare (divisi per protocollo e modulo) e di tutti
i target che si possono utilizzare. Per le target extension installate
con il patch-o-matic, riferitevi alla documentazione fornita.<p> 

<sect>NAT con iptables<p>
Col paragrafo precedente abbiamo completato la configurazione di una
piccola rete per quanto riguarda il filtraggio. <p>
Argomento di questa sezione è il NAT, ovvero ``Network Address Translation''.<p>
Il NAT consente ad un firewall o router linux di non limitarsi 
a bloccare o consentire i pacchetti in transito, bensì anche di
modficarli secondo delle regole ben definite. <p>
Il codice che in linux gestisce il NAT è stato completamente 
ridisegnato per iptables ed il risultato è stato un sistema molto più
pulito e flessibile rispetto quello utilizzato da ipchains. ipchains,
per effettuare modifiche ai pacchetti, utilizzava semplicemente dei 
target diversi come MASQ (per mascherare i pacchetti). Questo però creava
molta confusione sul meccanismo di scansione delle regole ed andava ad interferire
con le regole di filtraggio. In iptables, invece, la parte di filtraggio 
dei pacchetti è completamente indipendente da quella di modifica 
e di gestione delle regole di nat. Per raggiungere questa indipendenza
è stato infatti introdotto il concetto di ``tabella'' di cui fin'ora
non avevamo parlato. Ebbene, le 3 catene principali di cui abbiamo
parlato fin'ora (INPUT, OUTPUT, FORWARD) si trovano nella tabella ``filter''.
La tabella di filter è quella che viene scelta in automatico se non
viene specificata un'altra tabella (per questioni di compatibilit&agrave;). <p>
Esistono quindi altre tabelle in iptables, ognuna delle quali mette
a disposizione diverse catene di base:
<itemize>
  <item>la tabella <it/filter/, le cui catene principali sono <bf/INPUT, OUTPUT, FORWARD/
  <item>la tabella <it/nat/, le cui catene principali sono <bf/PREROUTING, OUTPUT, POSTROUTING/
  <item>la tabella <it/mangle/, le cui catene principali sono <bf/PREROUTING, OUTPUT/
</itemize>
Beh, ci sono 3 tabelle in totale. La prima, che normalmente non viene mai 
indicata esplicitamente, che serve per filtrare i pacchetti. La seconda, quella di
nat, che serve normalmente per modificare ciò che ha a che vedere col mittente o il
destinatario di un pacchetto, ed infine la tabella di mangle che consente di modificare 
tutte le altre caratteristiche dei pacchetti. <p>
La distinzione tra mangle e nat non è così netta, si tratta soltanto di un
criterio di base, ed il manuale vi saprà sicuramente indicare la tabella migliore 
da utilizzare a secondo delle vostre necessit&agrave;.<p>
Ma guardiamo meglio i nomi delle catene: nella tabella filter, ci troviamo
le solite INPUT, OUTPUT, FORWARD, col significato che ormai conosciamo.
Nella tabella di nat abbiamo invece 3 nuove catene: la catena di PREROUTING,
la catena di OUTPUT e la catena di POSTROUTING. La catena di OUTPUT mantiene
lo stesso significato che aveva nella tabella di filter. La catena di PREROUTING
e quella di POSTROUTING classificano invece i pacchetti diversamente: non più in
base alla direzione dei pacchetti, bensì al fatto che sia già stata presa
una decisione di routing su questi pacchetti. Vediamo di spiegare meglio l'idea:
quando un pacchetto di qualsiasi protocollo deve uscire da una macchina connessa ad una rete (poco
importa la provenienza del pacchetto) deve essere presa una decisione di routing. Deve cioè essere
stabilito da che interfaccia dovr&agrave; uscire questo pacchetto e con quali caratteristiche dovr&agrave; 
essere mandato (es, il TTL dovrebbe essere decrementato, l'MTU potrebbe essere diverso
e necessitare una frammentazione, l'indirizzo hardware specificato potrebbe essere quello
di un gateway...). Dal punto 
di vista logico, quindi, ogni pacchetto che deve uscire da un'interfaccia di 
rete passa prima dalla catena di PREROUTING, viene presa una decisione sull'interfaccia
da cui fare uscire il pacchetto, dopodichè passa dalla catena di POSTROUTING. <p>
PREROUTING e POSTROUTING sono state introdotte proprio per consentire di realizzare diversi
comportamenti: ad esempio, se si vuole cambiare l'indirizzo di destinazione di un pacchetto
sarà importante farlo prima che venga deciso da dove fare uscire il pacchetto (se così non 
fosse, il pacchetto uscirebbe dall'interfaccia sbagliata, a meno che questo non sia
l'effetto desiderato). Mentre, al
contrario, quando si cambia il mittente di un pacchetto potrebbe essere importante farlo dopo
che una decisione di routing è stata presa (in questo caso però l'errore non sarebbe così palese).<p>
Comunque sia, in ognuna di queste tabelle è possibile specificare dei target differenti utilizzando
però le stesse opzioni e gli stessi moduli per creare delle regole. Di base, i target più conosciuti
per la tabella di NAT sono proprio:
<itemize>
  <item> <bf/SNAT/ consente di cambiare l'indirizzo ip sorgente di un pacchetto (POSTROUTING)
  <item> <bf/DNAT/ consente di cambiare l'indirizzo ip destinazione di un pacchetto (PREROUTING)
  <item> <bf/MASQUERADE/ consente di cambiare l'indirizzo ip sorgente di un pacchetto (verrà spiegata in 
  	 seguito la differenza - POSTROUTING).
  <item> <bf/REDIRECT/ consente di cambiare la porta di destinazione di un pacchetto (PREROUTING)
</itemize>
Torniamo ora al nostro esempio: la nostra lan utilizza degli indirizzi ip del tipo 192.168, e 
come tali non possono viaggiare su internet (192.168 è  una classe di indirizzi ip riservati per reti private). 
Per consentire 
quindi ai computer della nostra rete di navigare, sarebbe necessario o un proxy (che però gestisca
tutti i protocolli) o fare in modo che l'indirizzo ip sorgente dei pacchetti originati dalla nostra
rete venga cambiato con un indirizzo ip valido per viaggiare in internet (come quello del nostro firewall,
per esempio).<p>
Realizzare questo a livello di regole di iptables è estremamente facile. Bisogna però fare una piccola introduzione
e dare un minimo di spiegazioni. A molti di voi, ad esempio, sarà sorto spontaneo chiedersi come 
diavolo può fare un firewall a nascondere 20 computer (per esempio) dietro un unico indirizzo ip. Voglio dire,
in uscita funziona bene: il client FOO dietro il firewall manda un pacchettino al gateway (il nostro firewall),
il nostro firewall cambia l'indirizzo ip sorgente col suo (valido su internet) e manda avanti il pacchettino, 
il server remoto risponde, il pacchettino torna indietro, e... il pacchettino che gli torna indietro ha come 
mittente il server remoto, come destinatario il firewall... non sembra funzionare tanto... come fa il firewall 
a capire a quale dei nostri client deve rimandare il pacchetto, se l'indirizzo di destinazione &egrave; il suo 
indirizzo esterno? E anche ipotizzando di avere un indirizzo ip solo per i client, come farebbe a mandare la
risposta al client corretto? Se guardasse l'indirizzo ip del server remoto, solo un client per volta potrebbe
navigare su un determinato sito... non proprio funzionale. Una soluzione potrebbe essere quella di avere
tanti ip esterni quanti client. Ma allora perch&eacute; usare il nat? La sicurezza potrebbe essere un
buon motivo, ma normalmente il nat si usa quando ci sono meno (o molti meno) indirizzi esterni a disposizione
rispetto ai client della propria rete (attualmente, gli indirizzi ip hanno un costo, e non indifferente).<p>
Beh, la soluzione che è stata trovata per risolvere questo problema si basa sull'idea di porta. Quando stabilite
una connessione tcp verso un server, l'unica porta veramente importante &egrave; quella di destinazione, che identifica
univocamente un servizio. Quella mittente, invece, non viene quasi mai guardata e spesso viene scelta a caso.<p>
Con il NAT, il nostro firewall linux cambier&agrave; (se necessario) la porta sorgente dei pacchetti in uscita
ed utilizzer&agrave; quella per identificare univocamente un client. Se la soluzione vi convince poco, provate
a pensare al flusso dei pacchetti... il client A manda un pacchetto proveniente da A porta <it/x/ al server
B porta 80. Il firewall riceve il pacchetto, cambia x in y (dove x pu&ograve; essere uguale a y, se tale
porta non &egrave; utilizzata da nessuno), si segna che y &egrave; associata solo ad A e cambia l'indirizzo
ip sorgente con il suo, il pacchetto arriva al server remoto R porta 80 come proveniente da F:y, e risponde creando un pacchetto
proveniente da R:80 e destinato al firewall F porta y. Firewall riceve il pacchetto, vede che la connessione
non &egrave; stata creata direttamente da lui (ogni sistema operativo sa quali connessioni ha iniziato)
cerca nella tabella e vede che la porta y era in origine x ed era associata al client A. Prende il pacchetto,
modifica il destinatario in modo che indichi A porta x e rimanda il pacchetto ad A. Sembra funzionare, no?
L'idea è abbastanza furba e permette di identificare univocamente un client utilizzando qualche bit
in più di informazioni. Il problema è che a volte questa tecnica non funziona:
<itemize>
  <item>ad esempio, quando la trasmissione non fa uso del concetto di porta (solo le trasmissioni tcp e udp
  	hanno delle porte associate). Fortunatamente per&ograve;, oltre all'icmp, non esistono protocolli
	realmente utilizzati che non usino il concetto di porta, e gli errori sono facilmente associabili
	(non sono specifici al client: se un server non &egrave; raggiungibile, questo non sar&agrave;
	raggiungibile per <em/tutti/ i client dietro al NAT box). Cio&egrave;, questi protocolli esistono ma vengono comunque
	normalmente gestiti non dal kernel ma da demoni dedicati per cui il problema non si pone.
  <item>ad esempio, quando c'è bisogno che i pacchettini provengano da una porta specifica: un client, nascosto
        dal firewall, non saprà mai in realtà che porta sorgente utilizzerà il firewall per rispedire i suoi
	pacchetti.
  <item>ad esempio, quando il protocollo si basa su connessioni effettuate da un server
  	esterno verso un client interno. <p> Per vedere dove sta il problema, proviamo a vedere un esempio.
        Ipotizziamo che il solito client FOO si colleghi a uno strano server con uno strano protocollo. 
	Per via di questo strano protocollo, il server deve aprire una connessione verso
	la porta 789 del client e tenta quindi di collegarsi. Quello che per&ograve; per lui 
	&egrave; l'indirizzo del client &egrave; in realt&agrave; l'indirizzo del firewall, per via
	del NAT che ha cambiato l'indirizzo del mittente. <p>
	Cos&igrave; facendo, il server tenter&agrave; di collegarsi al firewall, che per&ograve; questa volta
	non avr&agrave; nessuna associazione nella sua tabella (l'associazione si crea solo per le  
	connessioni che escono, e non &egrave; possibile indovinarle per quelle che entrano, a meno
	che non vengano stabilite a priori dall'amministratore) e sar&agrave; quindi costretto a
	buttare via il pacchetto rispondendo al server con un messaggio icmp con scritto qualcosa del 
	tipo ``la porta &egrave; chiusa e io non so chi tu sia''. 
</itemize>
Fortunatamente però il primo caso è estremamente raro (non credo sia stato mai nemmeno preso in considerazione
il problema), il secondo capita ancora molto raramente, mentre per il terzo esistono delle soluzioni: il
tracciamento delle connessioni.<p> 
Infatti, i moduli del kernel prima caricati che si occupavano di aprire o chiudere dinamicamente le 
porte sono anche in grado di aggiungere o rimuovere associazioni dalla famosa tabella, o di fare
delle piccole modifiche al protocollo in modo che questo possa funzionare. Per fare questo per&ograve;,
se non avete compilato staticamente il kernel, dovete caricare anche i moduli ``ip_nat_ftp'', ``ip_nat_irc''
o ``ip_nat_protocollo_strano_che volete usare'' con il solito ``modprobe''.<p>
Il problema che a volte si incontra, per&ograve;, &egrave; che questi moduli non sono proprio facili
da scrivere, per cui &egrave; relativamente facile trovarne per i protocolli standard, mentre non 
esistono per quei protocolli inventati dalla fantasia dei venditori di software di turno,
che non sentono il dovere morale di rispettare degli standard.<p> Normalmente i problemi si incontrano
solo per parti dei vari ``protocolli'' (ad esempio, dietro un firewall linux di questo tipo, col messanger
sarebbe difficile farsi mandare dei file da altri utenti, pur funzionando per tutte le altre cose).
E se per ftp e IRC (anche netmeeting, ma sperimentale) sono stati scritti dei moduli, per altri protocolli
meno utilizzati credo che sarà difficile che qualcuno si occupi di realizzarli.<p>
In questi casi, un ``socks server'' vi consentir&agrave; il pi&ugrave; delle volte di rendere felici i 
vostri utenti. Il prezzo da pagare &egrave; che un socks server di base &egrave; molto aperto ed una 
configurazione errata o superficiale di questo potrebbe vanificare completamente i vostri sforzi. In
pi&ugrave;, preparatevi a ricevere chiamate a tutte le ore del tipo ``come si fa ad impostare il socks
server su fuffolo 3.0 piuttosto che kazzat 2.8''...

<sect1>Dalla teoria alla pratica<p>
Passando dalla teoria alla pratica, occorre prima di tutto parlare in maniera un pochettino più approfondita
dei target di default messi a disposizione dalla tabella di NAT.<p>
<itemize>
  <item>SNAT: serve per modificare il mittente di un pacchetto (l'indirizzo ip sorgente). Viene utilizzato nella
        catena di POSTROUTING proprio perché il cambiare il mittente non interferisce sulla scelta dell'interfaccia
	da utilizzare per raggiungere il destinatario. Consente anche di modificare manualmente la porta sorgente
	di un pacchetto. Attenzione! Funziona solo con indirizzi ip statici!
  <item>DNAT: serve per modificare il destinatario di un pacchetto (l'indirizzo ip destinatario). Viene utilizzato
        nella catena di PREROUTING in quanto la modifica deve essere effettuata prima di decidere da che parte
	fare uscire il pacchettino. E' possibile inoltre specificare una diversa porta di destinazione.
  <item>MASQUERADE: è un tipo particolare di SNAT: fa in modo che i pacchettini abbiano come mittente l'indirizzo
        IP della interfaccia di rete dalla quale usciranno. Si utilizza nella tabella di POSTROUTING (modifica il
	mittente) e viene utilizzato al posto dello SNAT su interfacce con IP assegnato dinamicamente, ad esempio
	tramite dhcp o bootp.
  <item>REDIRECT: è una versione semplificata del DNAT mantenuta più che altro per motivi di compatibilità e fa in
  	modo che il pacchettino venga rediretto sulla macchina locale (127.0.0.1) ad una porta specifica. 
	Equivale a qualcosa
	del tipo: -j DNAT --to 127.0.0.1:porta &lt;--&gt; -j REDIRECT --to-ports porta.
</itemize>
Esistono molti altri target che possono essere aggiunti tramite il patch-o-matic adatti a tutte
le esigenze. Date un'occhiata al manuale di iptables ed alle informazioni mostrate sullo schermo
durante l'aggiornamento di iptables per maggiori informazioni.<p>
Tornando invece al nostro esempio (presentato nei paragrafi sul filtraggio), è per noi indispensabile 
utilizzare il NAT in quanto:
<itemize>
 <item> dobbiamo ``deviare'' tutti le connessioni web verso internet sul nostro proxy server che si 
        trova nella dmz (transparent proxy).  
<item> dobbiamo fare in modo che la nostra rete interna che utilizza indirizzi ip di classe 192.168.200.x 
	(indirizzi per reti private) possa navigare su internet.
</itemize>
<p>
Avendo però spesso a che fare con reti di discrete dimensioni dove il
dhcp è raramente utilizzato, mi piace aggiungere alcune regole per rendere
le macchine ``indipendenti'' dalle modifiche del provider di turno 
o eventuali riconfigurazioni della rete (vi è mai capitato di dover 
cambiare l'ip del dns su n macchine diverse, dove n tende ad infinito?).<p>
Per fare questo normalmente si possono utilizzare diversi approcci:
<itemize>
  <item>Se la rete è divisa in diverse sottoreti (subnet), si possono
  	``inventare'' due indirizzi ip che non risiedano su nessuna delle
	nostre reti ed impostare tutti i client per utilizzare quegli indirizzi
	ip come dns primario e secondario.
  <item>Si possono semplicemente deviare <bf/tutti/ i pacchetti destinati
  	ad un dns verso il dns reale (c'è il problema del dns secondario,
	però).
  <item>Semplicemente ignorare il problema inizialmente ed in caso di 
  	cambio di ISP aggiungere due regole per deviare il traffico
	sui nuovi dns.
</itemize>
Trattandosi comunque di regole abbastanza semplici ed interessanti dal 
punto di vista didattico, verranno presentate tutte e tre le soluzioni
(la prima è quasi perfettamente equivalente alla terza).  <p>
Vediamo quindi le nostre prime regole di NAT:  	
<tscreen><verb>
77: iptables -t nat -A PREROUTING -p tcp -i eth0 --dport www -j DNAT --to nostro.proxy.server:8080
78: iptables -t nat -A POSTROUTING -o eth2 -s 192.168.200.0/24 -j SNAT --to 123.45.68.1
</verb></tscreen>
Ok, la prima regola dice, a parole, di inserire una regola nella tabella di nat per intercettare tutti 
i pacchetti provenienti da eth0 e destinati ad un server www (porta 80 -- prima che venga deciso
da che interfaccia farli uscire) e di deviarli sul nostro.proxy.server porta 8080. <p>
Attenzione per&ograve; che proxy server come squid devono essere configurati per poter accettare
connessioni deviate in questo modo, in quanto non seguono perfettamente lo standard utilizzato
dai proxy (leggete la documentazione di squid!).<p>
Tornando a parlare delle regole, la seconda dice di modificare il mittente (l'indirizzo ip sorgente) dei
pacchetti uscenti da eth2 e provenienti dalla nostra LAN (192.168.200.0/24) con l'indirizzo
ip esterno del nostro firewall. <p>
A proposito di queste due regole ci sono alcune cose importanti da dire:
<itemize>
  <item>Prima di tutto, nella prima regola si è reso necessario indicare
  	la scheda di rete sorgente in modo da non deviare le richieste del 
	nostro proxy server. Per la cronaca: quando facciamo una richiesta 
	al nostro proxy server, questo se non ha le pagine richieste in cache
	dovr&agrave; collegarsi al server web richiesto, e dobbiamo quindi stare 
	attenti a non deviare anche le richieste provenienti dal proxy (si creerebbe una
	sorta di circolo vizioso (loop) né molto bello né molto positivo per
	la salute della nostra rete).
  <item>Nella seconda regola, invece, è importante fare in modo che soltanto
   	i pacchetti provenienti dalla nostra rete interna (e non dalla DMZ!)
	vengano modificati e soltanto quelli uscenti verso internet (quelli
	destinati al nostro proxy non devono essere toccati: saremo così in
	grado di fare un minimo di statistiche sui siti più interessanti per
	i nostri utenti).
  <item>Nella seconda regola, è fondamentale fare in modo che i pacchetti abbiano
  	come mittente uno degli indirizzi ip esterni del firewall. Per chi si
	accontenta di poche parole, basti dire che in caso contrario non funzionerebbe.
	Per tutti gli altri, invece, il motivo sta nell'arp, address resolution protocol.
	Ovvero, se l'indirizzo ip non fosse uno di quelli del firewall (aggiunti con
	ip o ifconfig, per intenderci), il firewall
	non risponderebbe alle query ARP, ed i pacchetti uscirebbero felici dalla
	rete ma il gateway di default del nostro firewall non sarebbe in grado
	di rimandare i pacchetti indietro. Come sempre, linux lascia la massima 
	libertà: sta all'amministratore evitare di farsi male con errori di questo
	tipo.
  <item>Riferendosi al funzionamento del SNAT come prima descritto, a volte (in 
  	reti particolarmente affollate) potrebbe essere indispensabile utilizzare
	più indirizzi ip per effettuare lo SNAT (il numero di porte disponibili
	ed utilizzabili su un host per fare il giochettino descritto è abbastanza limitato).
	Il target fortunatamente consente di indicare più indirizzi ip (date un'occhiata
	al manuale di iptables).<p> L'esperienza però mi insegna che in tali reti si
	supererebbe molto prima il numero massimo di connessioni tracciabili rispetto alle porte
	disponibili. Per aumentare questo numero, basta dare un:
<tscreen><verb>
  echo 16384 &gt; /proc/sys/net/ipv4/ip_conntrack_max
</verb></tscreen>
o, in maniera del tutto equivalente, scrivere qualcosa come
<tscreen><verb>
net.ipv4.ip_conntrack_max=16384
</verb></tscreen>
	nel file <file>/etc/sysctl.conf</file>.
	Comunque sia, tenete presente che già una rete di 100-200 computer potrebbe
	aver bisogno di essere in grado di tracciare più connessioni, mentre non 
	mi è ancora capitato di dover utilizzare più di un indirizzo ip in uscita.<p>
	Il kernel comunque, vi avviserà in caso fosse necessario aumentare questi
	limiti, con un messaggio nei log per ogni connessione scartata.
  <item>Nell'ultima regola, infine, se avessimo avuto a disposizione una connessione
  	dial-up (come isdn) o tramite adsl con indirizzi ip assegnati dinamicamente,
	si sarebbe dovuto usare come target ``MASQUERADE'', senza però specificare
	alcun indirizzo ip sorgente. Attenzione! Lo SNAT proprio non funziona su
	interfacce con ip dinamici assegnati! Potete vedere un esempio di come utilizzare
	il target MASQUERADE in uno dei paragrafi introduttivi...
  <item>Per quanto riguarda le regole di NAT e filtraggio, &egrave; fondamentale notare
   	(per poter ottenere un firewall funzionante) che le <bf/regole di firewalling, inserite 
	nella tabella di filter, vedranno i pacchetti con i loro indirizzi reali/. Nel
	caso di DNAT, per esempio, il filtro vedr&agrave; pacchetti con la destinazione
	modificata (in questo caso, il proxy server). In caso invece di SNAT, il filtro
	vedr&agrave; come mittente l'indirizzo reale del mittente (non quello modificato),
	come se il codice di filtraggio fosse inserito dopo la catena di PREROUTING ma
	prima della catena di POSTROUTING.
</itemize>
Volendo fare il giochettino con il DNS, le due possibilità sono realizzabili
utilizzando o queste regole:
<tscreen><verb>
80: iptables -t nat -A PREROUTING -p tcp --dport domain -j DNAT --to nostro.dns
81: iptables -t nat -A PREROUTING -p udp --dport domain -j DNAT --to nostro.dns
</verb></tscreen>
che deviano tutto il traffico verso un qualsiasi dns su nostro.dns,
o queste altre, che similmente intercettano il traffico verso un dns 
da noi specificato e deviano il traffico verso il nostro dns reale:
<tscreen><verb>
83: iptables -t nat -A PREROUTING -p tcp -d un.dns --dport domain -j DNAT --to nostro.dns
84: iptables -t nat -A PREROUTING -p udp -d un.dns --dport domain -j DNAT --to nostro.dns
</verb></tscreen>
A questo punto, non vi rimane che divertirvi con i pacchetti che fluiscono dalle
vostre reti...

<sect>Mettere tutto insieme<p>
Ok, abbiamo visto come configurare dei filtri ed il NAT. Mancano per&ograve; ancora
un paio di cosettine di cui sarebbe il caso di parlare.<p>
Prima di tutto, soprattutto quando staremo correggendo gli errori nelle nostre regole,
caricheremo e ricaricheremo il nostro script finch&eacute; non vedremo queste regole
funzionare (molte volte). Il fatto &egrave; che creando delle catene, non chiediamo
di svuotarle nel caso queste esistano gi&agrave;, per cui continueremmo ad aggiungere
regole su regole, non semplificandoci affatto la correzione degli errori.<p>
Potreste quindi voler aggiungere qualcosa come:
<tscreen><verb>
for table in nat mangle filter
do
   iptables -t $table -F
   iptables -t $table -X
done
</verb></tscreen>
all'inizio del vostro script... che elimina tutte le catene e tutte le regole inserite
in ogni tabella. Allo stesso modo, potreste voler aggiungere qualcosa come 
<tscreen><verb>
(
for interface in eth0 eth1 eth2 eth3
do
  ip route flush dev $interface
  ip addr flush dev $interface
  ip link set down dev $interface
done;
) &>/dev/null
</verb></tscreen>
Sempre all'inizio del nostro script, per riportare tutte le interfacce e le impostazioni
ad uno stato conosciuto, in modo che non si vadano in continuazione ad aggiungere route
o indirizzi, che, aggiunti per ultimi, verrebbero ignorati in favore di vecchie configurazioni
che si combinerebbero e mischierebbero in maniera poco prevedibile. Comunque, ``ip route flush dev ethx''
elimina tutti i route relativi ad ethx, ``ip addr flush'' elimina tutti gli indirizzi dell'interfaccia
ed infine ``ip link set down'' spegnere la scheda di rete.<p>
Infine, dobbiamo attivare le nostre interfacce di rete, configurare la tabella di routing ed abilitare
il ``forwarding'', dicendo al kernel di iniziare a trasmettere i pacchetti da una scheda di rete all'altra:
<tscreen><verb>
86: ip link set up dev eth0
87: ip link set up dev eth1
88: ip link set up dev eth2

89: ip route add default via 123.45.68.254

90: echo 1 > /proc/sys/net/ipv4/ip_forward
</verb></tscreen>
In questo caso, ip_forward non pu&ograve; essere aggiunto al file
sysctl.conf, in quanto vogliamo che il forwarding venga attivato
solo dopo che abbiamo impostato correttamente le regole di firewalling.<p>

Non ci resta quindi che creare in /etc/rcS.d/ o rc2.d (a secondo della
distribuzione) un link al file appena completato, in modo che questo venga 
eseguito ad ogni reboot, con qualcosa come ``ln -s ../init.d/ifconffw ./S40ifconffw''
oppure ``update-rc.d ifconffw start 40 S'' in Debian. <p>

<sect1>Configurazione dei client<p>
Se il firewall ha un indirizzo ip diverso per ogni interfaccia ed utilizza
come gateway il gateway fornito dal vostro provider, i vostri client
dovranno utilizzare come gateway, come cancello che gli permetta di 
connettersi ad altre reti, l'indirizzo ip del vostro firewall relativo
alla rete cui il vostro client &egrave; collegato.<p>
Un server collegato alla dmz dovr&agrave; quindi utilizzare come 
gateway l'indirizzo ip della vostra interfaccia collegata alla DMZ. Allo
stesso modo un client collegato alla LAN dovr&agrave; utilizzare come
gateway l'indirizzo ip dell'interfaccia collegata alla lan. Per
il resto, la configurazione dei client dipender&agrave; principalmente
dai server presenti (proxy, socks...) e dai giochini che avrete deciso
di fare col NAT.

<sect>Modifiche on the fly - iptables da riga di comando<p>
Sebbene sia veramente poco piacevole, &egrave; possibile utilizzare 
iptables direttamente da riga di comando. <p>
Nonostante questo, alcune di queste funzioni possono  risultare molto utili 
in fase di testing. Ad esempio, dovendo
fare delle misure di banda pu&ograve; essere utile consentire temporaneamente
solo il traffico tra determinate macchine, e non  &egrave; il caso di 
perdere tempo a modificare file di configurazione o script dalla
provata affidabilit&agrave;. Ok, iniziamo quindi col vedere le 
regole attive sul kernel da me correntemente utilizzate, col
comando ``iptables -nL'', dove ``n'' dice di non risolvere i nomi (passando
da indirizzi ip a nomi di domini) e ``L'' di ``listare'' o elencare (in italiano)
tutte le regole:
<tscreen><verb>
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
</verb></tscreen>
-n lo uso principalmente perch&eacute; altrimenti ci metterebbe molto tempo
a generare l'output (tentando di connettersi al database), per il resto,
credo che l'output in se stesso credo che risulti abbastanza autoesplicativo...
un problema di ``iptables -nL'' (rispetto ad usare un file di configurazione) 
&egrave; che molti dettagli non vengono mostrati e comunque la leggibilit&agrave;
&egrave; molto minore.<p>
Per avere pi&ugrave; dettagli, comunque, &egrave; possibile utilizzare l'opzione ``-v'' o ``-vv'',
con un comando simile a ``iptables -v -nL'':
<tscreen><verb>
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
41512   83M ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0          
    0     0 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
    0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 41513 packets, 83M bytes)
 pkts bytes target     prot opt in     out     source               destination         
</verb></tscreen>
ancora, l'output &egrave; abbastanza autoesplicativo. Se state leggendo
il pdf notate per&ograve; come le righe vengono troncate. Immaginate su
un terminale con le classiche 80 colonne cosa verrebbe fuori.<p>
Se siete interessati ad un'unica catena, potete specificarne il 
nome dopo il ``-nL''. Con qualcosa di simile a ``iptables -vv -nL INPUT''
vedreste solo la catena di ``INPUT'' ed un dump delle informazioni del kernel. 
Come altre
opzioni generiche, potete utilizzare ``-x'', che mostrer&agrave;
i valori esatti dei contatori, mentre ``-Z'' li azzerer&agrave;, oppure ``-t nometabella''
per visualizzare altre tabelle.

<sect1>Manipolare le catene<p>
Gi&agrave; conosciamo i parametri:
<itemize>
  <item><it/-N/ -- per creare nuove catene
  <item><it/-X/ -- per eliminare una catena (tutte, se non viene specificato un argomento)
  <item><it/-F/ -- per eliminare tutte le regole di una catena (tutte, se non viene specificato
  		   un argomento)
  <item><it/-A/ -- per aggiungere regole alle catene
  <item><it/-P/ -- per impostare le politiche
</itemize>
In pi&ugrave;, vi possono tornare utili i comandi
<itemize>
  <item><it/-I/ -- per inserire una nuova regola
  	in una determinata posizione di una catena
  <item><it/-R/ -- per sostituire una regola con un'altra
  <item><it/-D/ -- per rimuovere una regola
</itemize>
Cerchiamo per&ograve; di vedere questi parametri nella pratica. Ipotizzando
di avere una situazione come quella mostrata sopra con 
``iptables -nL'', immaginiamo di voler inserire una regola 
dopo quella relativa ad ssh (catena di INPUT, porta 22, riga 2) per consentire
l'accesso ad un web server installato sul mio portatile.
In questo caso, potremmo dare un comando come
<tscreen><verb>
iptables -I INPUT 3 -p tcp --dport 80 -j ACCEPT
</verb></tscreen>
Il 3 indica che questa regola deve essere inserita nella
terza riga, spostando tutte le altre righe pi&ugrave; in basso.
Dopo questo comando, ``iptables -nL INPUT'' mostrerebbe qualcosa come
<tscreen><verb>
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:80 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 
</verb></tscreen>
proprio come volevamo. Immaginiamo ora di spostare il web server sulla porta 443,
e di voler rimpiazzare la regola appena inserita con qualcosa come ``-p tcp --dport 443
-j ACCEPT''. In questo caso sarebbe sufficiente utilizzare
<tscreen><verb>
iptables -R INPUT 3 -p tcp --dport 443 -j ACCEPT
</verb></tscreen>
per ottenere qualcosa come
<tscreen><verb>
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:22 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0          tcp dpt:443 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0          state RELATED,ESTABLISHED 
REJECT     tcp  --  0.0.0.0/0            0.0.0.0/0          reject-with tcp-reset 
</verb></tscreen>
Infine, per rimuovere la regola, basterebbe qualcosa come 
<tscreen><verb>
iptables -D INPUT 3
</verb></tscreen>
Se siete meno pigri di me, potete utilizzare anche
<tscreen><verb>
iptables -D INPUT -p tcp --dport 443 -j ACCEPT
</verb></tscreen>
che porterebbe esattamente allo stesso risultato.

<sect1>Salvare le modifiche<p>
Versioni relativamente recenti di iptables mettono anche a disposizione due
tools: iptables-save ed iptables-restore. Il primo, stampa a video in un
formato standard tutte le regole di firewalling, mentre il secondo &egrave;
in grado di leggere delle regole in questo formato standard da standard 
input e di impostarle nel kernel. Ad esempio, per salvare delle regole
correntemente utilizzate dal kernel, &egrave; possibile utilizzare il
comando:
<tscreen><verb>
  &num; iptables-save &gt; nomefile
</verb></tscreen>
mentre per ripristinarle il comando
<tscreen><verb>
  &num; iptables-restore &lt; nomefile
</verb></tscreen>
In Debian, &egrave; possibile utilizzare ``/etc/init.d/iptables save nomefile''
oppure ``/etc/init.d/iptables load nomefile''. Utilizzando come nomefile ``active'',
le regole verranno automaticamente caricate ad ogni accensione della macchina.
In quest'ultimo caso, potreste voler dare un'occhiata a <file>/etc/default/iptables</file>.


<!--
<sect>Troubleshooting<p>
Cos&igrave; avete configurato il vostro primo firewall, eh?
Beh, immagino che una volta caricato il vostro script abbia funzionato
tutto al primo colpo, giusto? Internet funzionava, gli utenti
erano contenti, ed il firewall sembrava macinare pacchetti come
un trattore...<p>
No? Beh, vediamo allora cosa si pu&ograve; fare... la, procedura,
anche in questo caso, &egrave; abbastanza semplice. Il primo passo,
come in qualsiasi procedura di troubleshooting, &egrave; capire cosa
c'&egrave; che non va. Il secondo, &egrave; tentare di capire qual'&egrave; il 
problema. Partite <bf><it>sempre</it></bf> dall'assunzione che non
ci sono errori nel codice di networking, risparmierete un sacco
di tempo. Per il resto, non intestarditevi sulla vostra configurazione e
tentate di limitarvi ad analizzare i fatti, i pacchetti che vedete 
passare e quelli che invece non vedete passare. Terzo, 
cercate di isolare il problema e di analizzare un unico problema
per volta. Infine, verificate che si &egrave; individuato effettivamente 
il problema, facendo delle prove e dei test, dopodich&eacute; provate
a cambiare la configurazione. Se il problema cessa di esistere, allora
l'avete risolto. Se ancora c'&egrave; qualcosa che non va, ripartite
dal primo passo. La procedura dovrebbe esservi utile anche se la
vostra rete ha appena smesso di funzionare...<p> Come vedrete,
per&ograve;, &egrave; estremamente difficile individuare e risolvere 
i problemi di networking senza avere dei punti stabili di appoggio: non &egrave; possibile 
correggere problemi di configurazione di un client con il firewall
che non funziona, ed &egrave; difficile capire cosa ci sia che non va 
in un firewall utilizzando un client mal configurato. L'esperienza vi potr&agrave;
essere di aiuto, ma un nuovo firewall porta sempre a delle  
modifiche nei client, per cui sar&agrave; difficile crearsi dei punti 
stabili di appoggio.

<sect1>Capire cosa c'&egrave; che non va<p>
Beh, prima di tutto se avete affermato che un problema c'&egrave;
e se lo state cercando vuol dire che avete fatto qualche prova
che non ha dato buoni risultati. Con buona probabilit&agrave;,
avete preso un client windows vicino al vostro firewall
e avete provato a raggiungere un sito internet, che non &egrave;
venuto fuori. Di base, i problemi relativi al networking possono
essere classificati in una delle seguenti categorie:
<itemize>
  <item>Problemi fisici di comunicazione<p>
  <item>Problemi di configurazione del client<p>
  <item>Problemi di configurazione del firewall (dns, gateway, interfacce...)<p>
  <item>Problemi nelle regole di firewalling o nat<p>
  <item>Problemi di connettivit&agrave; ad internet<p>
  <item>Problemi di configurazione di uno dei server (il dns, per esempio, o il proxy)<p>
</itemize>
Per ogni categoria, esistono una serie di operazioni che ci
consentono di verificare se l'errore appartiene veramente alla 
determinata categoria.

<sect2>Problemi fisici di comunicazione<p>
Prima di iniziare a fare delle prove, vi conviene fare
delle semplici verifiche che vi consentiranno poi
di lavorare pi&ugrave; serenamente (potete saltarle
se il firewall ha sempre funzionato correttamente
e solo recentemente ha smesso di andare):
<enum>
  <item>Prima di tutto, verificate tutti i cavi inseriti
  	nel vostro firewall. Dopo aver smanettato tutta una
	mattina, magari vi siete dimenticati che per fare
	delle prove ne avete staccato/attaccato uno...
  <item>Verificate che tutte le lucine si accendano.
  	Ricordatevi, inoltre, che, con una rete ethernet:
	<itemize>
	  <item>Per collegare due computer <bf/direttamente/
	  	(senza passare da uno switch o da un hub) serve 
		un cavo <it/crossover/, aka cavo invertito.
	  <item>Per collegare due switch tra di loro, serve
	  	ancora un cavo <it/crossover/. Attenzione
		per&ograve; che gli switch e gli hub hanno
		spesso uno spinotto chiamato ``uplink''. 
		In alcuni switch/hub un cavo collegato in questo
		spinotto verr&agrave; invertito automaticamente
		(invece di necessitare un cavo invertito, viene
		invertita la spina). In altri
		invece, ci sar&agrave; un bottone da qualche 
		parte per permettere di invertire il cavo 
		inserito in tale spinotto.<p>
		Ancora, attenzione che se state collegando
		due switch/hub tra di loro solo uno dei due
		spinotti deve essere invertito, altrimenti 
		andrete a finire ancora ad avere bisogno
		di un cavo crossover. In pratica &egrave;
		bene su uno switch/hub usare l'uplink, mentre
		sull'altro utilizzare uno spinotto normale.
	  <item>Per collegare un computer ad un hub/switch,
	  	vi servir&agrave; invece un cavo normale.
	</itemize>
	Infine, attenzione che in Italia spesso vengono
	venduti cavi ethernet ``crossover'' inutilizzabili:
	in questi cavi, tutti i fili sono collegati al
	contrario. Perch&egrave; il cavo sia utilizzabile,
	invece, solo 2/3 fili devono avere la posizione scambiata.
	Fate molta attenzione!
  <item>Se avete diverse schede di rete (caso piuttosto comune
  	in un firewall), verificate che alla scheda corretta sia
	collegato il cavo corretto. Se infatti avete configurato
	il tutto in modo che eth0 fosse collegata alla rete interna,
	eth1, alla rete esterna e cos&igrave; via, dovrete essere
	sicuri di aver collegato il cavo interno a eth0, il cavo
	estern... il problema &egrave; che spesso &egrave; difficile
	capire quale scheda di rete linux abbia chiamato eth0 o eth1. 
	Un metodo molto veloce &egrave; quello di munirsi di un pennarello
	per acetato (di quelli usati per scrivere sui cd) e di staccare
	tutte le intefaccie lasciando una sola scheda di rete collegata
	ad una rete un po' trafficata (non so, qualcuno star&agrave; usando
	la vostra rete interna, no?), dopodich&eacute; dare un comando
	come ``tcpdump -nei eth0'', ``tcpdump -nei eth1'' e cos&igrave;
	via fino a trovarne una dove si veda del traffico. Se non 
	avete mai utilizzato tcpdump, non lasciatevi spaventare dall'output. 
	L'unica cosa che fa tcpdump &egrave; mostrarvi le intestazioni
	dei pacchettini che vede transitare sulle interfacce. A questo 
	punto, potrete scrivere il nome dell'interfaccia direttamente
	col pennarello sulla scheda di rete in questione. Attenzione per&ograve;
	che a voi non interessa vedere il traffico generato da voi, ma quello
	generato dagli altri. Se le tabelle di routing sono configurate, infatti,
	le schede di rete tenteranno di trovare il gateway, a volte anche 
	con il cavo staccato. Prima di andar di pennarello, verificate quindi
	che il mittente dei pacchetti che state vedendo non sia il vostro
	computer :-).
</enum>
Ok, se avete fatto tutte le verifiche indicate qua sopra e nulla vi &egrave;
parso risolutivo, proviamo ora a verificare la connettivit&agrave; di rete:
dal firewall, per ogni rete, provate a raggiungere un computer sicuramente
acceso. Per fare questo, &egrave; indispensabile disabilitare tutte le regole
di firewalling in input/output, con qualcosa tipo:
<tscreen><verb>
iptables -I INPUT -j ACCEPT
iptables -I OUTPUT -j ACCEPT
</verb></tscreen>
A questo punto, ipotizzando di avere eth0, eth1, ed eth2, collegate rispettivamente
alla lan, internet e dmz, potete prima dare un ``ping indirizzo_computer_lan'', 
poi un ``ping indirizzo_gateway'', ed infine ``ping indirizzo_server'', dove indirizzo_* 
&egrave; l'indirizzo di un computer acceso, collegato in rete e che accetta i ping. Se da tutti
e tre ricevete risposte (ctrl+c per bloccare) con uno 0&percnt; di ``packet loss'', ovvero
perdita dei pacchetti, allora non ci dovrebbero essere problemi
di cablatura. Se avete un'alta rata di errore, qualcosa anche pi&ugrave; del 20&percnt;, 
c'&egrave; qualcosa che non va nell'hardware di rete. In pratica,
i dati vengono trasmessi a tratti o con errori. Questo non &egrave; normalmente
un problema software. Cause potrebbero essere:
<itemize>
<item>Cavi che coprono una distanza troppo alta (non pi&ugrave; di 100 metri
con ethernet su cavo)
<item>Cavi che passano vicino a fonti forti di radiazioni elettromagnetiche 
(motori elettrici, alternatori...)
<item>Switch/hub o schede di rete guaste. Potrebbe essere dallo switch che
ha subito un forte sbalzo di tensione (pu&ograve; capitare) ad una
scheda di rete che &egrave; andata in pappa.
</itemize>
Se vedete invece un errore del tipo:
<tscreen><verb>
PING 10.0.0.1 (10.0.0.1): 56 data bytes
ping: sendto: Network is unreachable
ping: wrote 10.0.0.1 64 chars, ret=-1
[...]
</verb></tscreen>
vuol dire che la scheda di rete in questione non &egrave;
stata configurata correttamente. Passate
alla sezione sulla configurazione del
firewall per maggiori informazioni.<p>
Infine, se anche per una sola rete, avete avuto una perdita del 100&percnt;,
verificate che la macchina che avete scelto di pingare sia accessa e che
accetti i ping (provando, magari, da un computer vicino a fare la stessa
operazione). Se dagli altri computer tutto funziona perfettamente, ci sono
diverse possibilit&agrave;:
<itemize>
  <item>Se due o pi&ugrave; schede di rete non stanno andando, &egrave;
  	possibile che abbiate scambiato i nomi e collegato i cavi in maniera errata.
  <item>Se una sola non sta andando, verificate tutto il percorso del cavo, che 
  	vada nello switch corretto e che le luci siano accese. Verificate inoltre
	che l'indirizzo ip dell'interfaccia e la netmask siano corrette.
  <item>Se il problema &egrave; col gateway, verificate che sia acceso, funzionante
  	e correttamente collegato.
</itemize>
Se ancora avete problemi, un 100&percnt; di packet loss &egrave; sicuramente indice
o di un grave errore di configurazione o di un errore di collegamento. Un'altra possibilit&agrave;
&egrave; che si sia completamente rotto uno switch o che manchi il collegamento tra due
switch. In questi casi, alcuni computer della vostra rete saranno raggiungibili
senza problemi, altri con una perdita del 100&percnt; dei pacchetti. Fate le verifiche
del caso, e provate a pingare diversi client prima di trarre conclusioni affrettate.<p>
Un'altra classe di problemi che pu&ograve; essere difficile da individuare sono le
incompatibilit&agrave; hardware. Normalmente, queste dovrebbero dare sintomi abbastanza
chiari in linux: ``ip link show'' potrebbe non mostrarvi tutte le interfacce (nel qual
caso potrebbe essere anche un problema di moduli caricati), oppure, al contrario, potrebbe
mostrarvene in pi&ugrave; (e s&igrave;, pu&ograve; capitare anche questo). Infine,
quando tentate di usare la rete, potreste vedere dei messaggi poco rassicuranti nei
log o con comandi come ``dmesg''. In questi casi, l'unica soluzione &egrave; provare
finch&eacute; non si arriva ad una configurazione stabile.

<sect2>Problemi di configurazione del client<p>
E' facile individuare problemi di configurazione dei client partendo dall'assunzione
che la rete stia funzionando. Se la rete non sta funzionando, pu&ograve; essere un pochino
pi&ugrave; problematico. Comunque sia, c'&egrave; una serie di operazioni che possono
essere fatte per individuare ed isolare il problema:
<enum>
  <item>Prima di tutto, &egrave; bene verificare che il client sia collegato correttamente
   	in rete, pingando altri computer e con facendo le verifiche indicate nella sezione
	precedente. Se avete client windows <bf/non fidatevi assolutamente/ del contenuto
	della finestrella ``risorse di rete''. Questa viene aggiornata solo periodicamente
	ed il protocollo smb e veramente poco affidabile se ci sono problemi di connettivit&agrave;
  <item>In secondo luogo, provate a risolvere dei nomi tramite dns con il comando ``nslookup'',
  	disponibile solo in linux, NT, 2k, MX e OS X 10.0. In pratica, digitate qualcosa come
<tscreen><verb>
nslookup www.debian.org
</verb></tscreen>
	se vedete l'indirizzo apparire, allora il dns sta funzionando. Se non avete il comando
	nslookup, potreste utilizzare sempre il comando ``ping www.debian.org'', se nella 
	prima riga vi appare l'indirizzo ip di www.debian.org, allora il dns sta andando,
	mentre se ping rimane in attesa per un po' dopodich&eacute; vi da un errore, c'&egrave;
	qualcosa che non va nel dns. Il dns non vi serve
	solo se tutti i client sono configurati per utilizzare il proxy (non un proxy trasparente,
	un proxy normale). Altrimenti, dovrebbe andare. Se vedete un errore del tipo ``connection
	timed out'', verificate che il dns sia configurato correttamente sulla macchina che state
	usando. Se &egrave; configurato correttamente, allora o il server dns non sta funzionando
	o non &egrave; raggiungibile. Nel primo caso, provate ad usare un altro dns di quelli
	pubblicamente disponibili, normalmente quelli delle naming authority nazionali non
	dovrebbero avere problemi (cercateli su internet!). Nel secondo caso, si tratta probabilmente
	di un problema delle regole del firewall o di connettivit&agrave; ad internet.
  <item>Provate a collegarvi direttamente utilizzando l'indirizzo IP ad un server WEB che sicuramente
  	sta funzionando. Potreste usare come indirizzi ip quelli del %TODO%, che quasi sicuramente
	sono attivi e funzionanti. Per fare questo, potreste dare un comando come
<tscreen><verb>
&num; telnet x.x.x.x 80
&gt; Trying x.x.x.x...
&gt; Connected to joshua.
&gt; Escape character is '^]'.
&num; GET / HTTP/1.0
&num; Host: www.nomedominio.ip
&num;
&gt; HTTP/1.1 200 OK
&gt; Date: Sun, 20 Oct 2002 13:02:11 GMT
[...]
</verb></tscreen>
	dove le righe precedute da &num; sono quelle che dovete digitare, mentre quelle
	precedute da &gt; sono quelle che dovreste vedere in output. Se riceveste
	un output simile a quello mostrato, probabilmente il traffico web sta funzionando
	correttamente. Per cui, se non riuscite a collegarvi con IE o con Netscape a dei
	siti internet si tratta o di un problema di proxy, o ancora di un problema di dns.
	Per verificare questo, provate a disabilitare il proxy (in IE o Netscape) e provate
	a scrivere nella barrettina degli indirizzi direttamente l'indirizzo ip di un sito.
	Guardate la precedente sezione per verificare invece che non si tratti di un problema
	di dns. Se invece non avete ricevuto alcun output, oppure telnet si &egrave; rifiutato
	di partire con qualche strano messaggio, il problema &egrave; che la connessione non pu&ograve;
	essere stabilita. Se state usando un transparent proxy, verificatene la configurazione,
	altrimenti, controllate le regole del firewall.
  <item>Se solo alcuni software di rete non vanno, con buona probabilit&agrave; si tratter&agrave;
  	di problemi di configurazione di un proxy/socks server o delle regole di firewalling e nat.
</enum>
  
<sect2>Problemi di configurazione del firewall<p>
Problemi di questo tipo sono dovuti normalmente a:
<itemize>
  <item>Errori nell'assegnamento degli indirizzi ip
  	alle varie interfacce
  <item>Errori nella configurazione delle tabelle
  	di routing
  <item>Mancata abilitazione del forwarding
</itemize>
Raramente la configurazione del dns del firewall pu&ograve;
influenzare il resto della rete. Comunque sia, &egrave; 
bene configurarlo correttamente. Un buon metodo per
verificare la corretta configurazione del firewall
&egrave; quello di eliminare tutte le regole di firewalling
in INPUT/OUTPUT con gli stessi comandi mostrati prima:
<tscreen><verb>
iptables -I INPUT -j ACCEPT
iptables -I OUTPUT -j ACCEPT
</verb></tscreen>
dopodich&egrave; provare prima a navigare in internet,
con links ed utilizzando le stesse procedure descritte
per verificare la corretta configurazione di un client.
Se la navigazione in internet funziona correttamente, 
non vi rimane che verificare che il firewall possa 
comunicare con i computer della vostra lan e della
dmz, utilizzando le procedure descritte per verificare
l'assenza di errori fisici di comunicazione. <p>
Se doveste poi vedori errori del tipo ``network is unreachable'',
controllate che:
<itemize>
  <item>L'interfaccia collegata alla rete in questione
  	sia attiva, utilizzando il comando ``ip link show'' (l'interfaccia
	deve avere il flag di UP).
  <item>Sia configurata correttamente la netmask. Utilizzando
  	``ip addr add'' &egrave; abbastanza facile dimenticarsi
	un /24 nell'indirizzo ip, e se non si mette la 
	rete non risulter&agrave; raggiungibile.
  <item>Siano correttamente configurate le tabelle di routing. Con ``ip route show''
  	dovreste vedere a sinistra l'indirizzo di ogni rete seguito dal nome
	dell interfaccia utilizzata per raggiungerla in fondo alla riga.
  <item>Se il messaggio ``network unreachable'' l'avete avuto tentando
  	di raggiungere un sito internet, &egrave; probabile che vi siate
	dimenticati un route di default. Provate con ``ip route show''
	a vedere se esiste un route per la rete chaimata ``default''.
	Se non esiste, dovete usare un comando come ``ip route add
	default via IP.DEL.VOSTRO.GATEWAY''.
</itemize>
Fatte queste verifiche, se il vostro gateway sta funzionando, dovreste
essere in grado di navigare in internet con comandi come ``links'' o
``lynx''. Se ancora non ci riuscite, fate dei controlli sulla corretta
configurazione del gateway.<p>
Infine, trattandosi di un firewall, controllate che il file <file>``/proc/sys/net/ipv4/ip_forward''</file>
contenga il valore 1.

<sect2>Problemi nelle regole di firewalling o nat<p>
-->


<sect>Conclusioni<p>
Le funzioni viste qua sopra non costituiscono probabilmente neanche
 il 25&percnt; di tutto ciò che il kernel 2.4 può fare. Mi basti
 ricordarvi che delle tre tabelle a disposizione ne abbiamo utilizzate
 soltanto 2 e che molte delle nuove funzionalità sono state soltanto
 accennate, senza dimenticare poi che nulla è stato visto in proposito
 del QoS e del fair queuing. Giusto per stuzzicare la vostra curiosità,
 la tabella di mangle serve per ``maneggiare'' i pacchetti in maniera
 più sottile, in modo che comandi come ip e tc possano interagire
 tra di loro distinguendo pacchetti scelti da iptables o per modificare
 i parametri del pacchetto (modulo ttl &amp; co.).  <p>
Giusto per fare un accenno, il fair queuing si gestisce attraverso
 il comando tc, e consente di suddividere tutti i pacchetti in transito
 in classi, dove ogni classe può avere una certa larghezza di banda
 riservata o una certa priorità. Si potrebbe poi parlare di funzioni
 come il proxy_arp, che in combinazione con il modulo ttl consentono
 di creare dei firewall (praticamente) invisibili.
</article>
